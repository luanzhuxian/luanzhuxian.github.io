<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue-awesome-swiper 切换导航导致轮播停止的问题</title>
    <url>/post/6903b776.html</url>
    <content><![CDATA[<p><code>vue-awesome-swiper</code>版本<code>3.1.3</code>。且使用了<code>keep-alive</code>。    </p>
<p>今天发现页面跳转后再返回，轮播会停止，不自动播放了。看了看文档，鼓捣了配置也还是一样。那么把实例打印出来看看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// template</span><br><span class="line">&lt;swiper ref=&quot;swiper&quot; :options=&quot;swiperOption&quot;&gt;</span><br><span class="line"></span><br><span class="line">// script</span><br><span class="line">console.log(this.$refs.swiper.swiper)</span><br></pre></td></tr></table></figure>
<p>发现有个<code>autoplay</code>对象，其中<code>paused: true</code>，表示被暂停了，等于每次组件被<code>deactivated</code>停用时轮播也会被暂停。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoplay: &#123;</span><br><span class="line">    onTransitionEnd: ƒ onTransitionEnd(e)</span><br><span class="line">    pause: ƒ ()</span><br><span class="line">    paused: true</span><br><span class="line">    run: ƒ ()</span><br><span class="line">    running: true</span><br><span class="line">    start: ƒ ()</span><br><span class="line">    stop: ƒ ()</span><br><span class="line">    timeout: 81</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那就在<code>activated</code>钩子函数中加入如下逻辑试试，每次返回触发钩子会手动恢复自动播放：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activated () &#123;</span><br><span class="line">    if (this.$refs.swiper &amp;&amp; this.$refs.swiper.swiper.autoplay.paused) &#123;</span><br><span class="line">        this.swiper.autoplay.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在打印可以看到<code>paused: false</code>，自动播放恢复了，问题解决了。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片</title>
    <url>/post/a13d0f96.html</url>
    <content><![CDATA[<h1 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h1><p>首先没有域名的要去购买，这个就不多说了。</p>
<h1 id="域名解析到-Github-Page"><a href="#域名解析到-Github-Page" class="headerlink" title="域名解析到 Github Page"></a>域名解析到 Github Page</h1><p>购买域名的供应商会提供域名解析，我们的目的是将域名解析到你<code>github page</code>的 ip 地址。这个也不多说了，不清楚可以百度。或者参考我的。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/1.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<h1 id="github-仓库添加域名解析记录"><a href="#github-仓库添加域名解析记录" class="headerlink" title="github 仓库添加域名解析记录"></a>github 仓库添加域名解析记录</h1><p>可以通过命令在<code>github page</code>仓库中添加<code>CNAME</code>文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch CNAME</span><br><span class="line">echo &apos;luanzhuxian.com&apos;&gt; CNAME</span><br></pre></td></tr></table></figure></p>
<p>或者在仓库的<code>settings</code>中找到<code>Custom Domain</code>添加自己的域名</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/2.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>之后就可以通过域名访问了。</p>
<h1 id="支持-https-访问自定义域名"><a href="#支持-https-访问自定义域名" class="headerlink" title="支持 https 访问自定义域名"></a>支持 https 访问自定义域名</h1><p>现在只能通过<code>http</code>访问域名，想要通过<code>https</code>访问，需要域名服务商颁发<code>SSL</code>证书，我是在阿里云买的域名，而阿里云的<code>SSL</code>证书是付费的。<br>我们可以将域名解析服务迁移到提供免费<code>SSL</code>的服务商处，我选择了<a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a>。  </p>
<p>首先要注册，接着右上角<code>Add site</code>添加你的域名。之后<code>Cloudflare</code>会自动扫描你的<code>DNS</code>解析记录。完成后会自动显示你的域名当前DNS记录，如果记录有问题或者有遗漏，你可以自己手动<code>Add record</code>添加<code>DNS</code>解析，然后再点击到下一步。  </p>
<p>之后选择免费<code>CDN</code>套餐，点确定，<code>Cloudflare</code>会分配两个<code>CDN</code>加速的<code>NS</code>服务器地址。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/3.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>之后登陆阿里云 &gt; 控制台 &gt; 产品与服务 &gt; 域名 &gt; 找到你的域名右侧点击管理 &gt; 左侧菜单<code>DNS管理</code>：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/4.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>可以看到当前的阿里云的<code>DNS</code>服务器，我们要用<code>Cloudflare</code>的将之替代。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/5.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>点右上角<code>修改DNS服务器</code>，将<code>Cloudflare</code>的两个<code>NS</code>地址分别复制进去，点确定。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/6.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>也就是将域名的<code>DNS</code>解析服务从阿里云迁移到了提供免费证书的<code>Cloudflare</code>，生效后可以用<code>https</code>访问了。</p>
<h1 id="支持七牛云图片"><a href="#支持七牛云图片" class="headerlink" title="支持七牛云图片"></a>支持七牛云图片</h1><p>我的图片放到了<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛</a>上，因为是免费的。  </p>
<p>首先要 &gt; 控制台 &gt; 左侧对象储存 &gt; 空间管理 &gt; 新建空间，就不详细说了。创建好右侧点击文件进入文件管理就可以上传文件了。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/7.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>以前上传文件后文件的外链地址是七牛给的，比如<code>http://pw5hoox1r.bkt.clouddn.com/test.png</code>直接拿这个外链地址就能获取图片。现在不行了，必须要绑定已备案的域名，否则上传的文件没有外链地址。比如你绑定一个二级域名<code>cdn.abc.com</code>，绑定后图片的外链地址就变为<code>http://cdn.abc.com/test.png</code>。  </p>
<p>空间管理 &gt; 点击右侧的域名，进入域名管理页面 &gt; 添加域名。之后输入你的域名，必须是已备案的。通信协议的话<code>HTTP</code>是免费的，<code>HTTPS</code>是付费的。源站配置选择你的储存空间，点创建就行了。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/8.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>之后要配置<code>CNAME</code>。去你的<code>DNS</code>服务商处添加一条<code>CNAME</code>的解析，将你七牛绑定的的域名解析到七牛的域名，这个域名就在刚创建的加速域名的详情页里可以找到。  </p>
<p>空间管理 &gt; 域名管理 &gt; 下方找到你刚绑定的域名，点进去。基本信息下面的<code>CNAME</code>就是了。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/9.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>因为我上面选的<code>Cloudflare</code>，所以去添加一条<code>CNAME</code>的解析，目标就是刚刚七牛给的<code>CNAME</code>地址。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/10.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>这里注意如果你添加了<code>a记录</code>，比如使用通配符<code>泛域名a记录</code>，有可能会和刚才添加的<code>CNAME</code>记录冲突，也就是刚才绑定的域名会被解析到<code>github page</code>而不是七牛，也就拿不到图片，所以可以把冲突的<code>a记录</code>删了。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/11.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>生效后通过<code>https</code>打开博客，发现七牛的图片请求报错，原来是<code>https</code>下图片也被改为<code>https</code>请求的。要么去七牛的域名管理处改为支持<code>https</code>，但是付费的。或者去<code>Cloudflare</code>修改<code>SSL</code>证书。</p>
<p>进入<code>Cloudflare</code>点击上面的<code>SSL/TLS</code>，右边有四种模式：<code>OFF、Flexible、Full、Full(strict)</code>。默认是<code>Full</code>，也就是<code>客户端 到 Cloudflare</code>和<code>Cloudflare 到 服务器</code>这两段都是<code>https</code>加密传输。  </p>
<p>改为<code>Flexible</code>，即是<code>客户端 到 Cloudflare</code>是<code>https</code>加密传输，而<code>Cloudflare 到 服务器</code>是<code>http</code>传输，这样<code>Cloudflare</code>可以拿到七牛云的图片再返给客户端了。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/hexo-custom-domain/12.png" alt="Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片"></p>
<p>生效后再打开文章就可以看到图片了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 的批量异步操作</title>
    <url>/post/60c2c548.html</url>
    <content><![CDATA[<h1 id="按顺序完成异步操作"><a href="#按顺序完成异步操作" class="headerlink" title="按顺序完成异步操作"></a>按顺序完成异步操作</h1><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。  </p>
<p>Promise 的写法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function logInOrder(urls) &#123;</span><br><span class="line">  // 远程读取所有URL</span><br><span class="line">  const textPromises = urls.map(url =&gt; &#123;</span><br><span class="line">    return fetch(url).then(response =&gt; response.text());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  textPromises.reduce((chain, textPromise) =&gt; &#123;</span><br><span class="line">    return chain.then(() =&gt; textPromise)</span><br><span class="line">      .then(text =&gt; console.log(text));</span><br><span class="line">  &#125;, Promise.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入 textPromises 数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。  </p>
<p>这种写法不太直观，可读性比较差。下面是 async 函数实现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function logInOrder(urls) &#123;</span><br><span class="line">  for (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并行发出远程请求。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function logInOrder(urls) &#123;</span><br><span class="line">  // 并行读取远程URL</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    return response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  for (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，虽然<code>map</code>方法的参数是<code>async函数</code>，但它是并行执行的，因为只有<code>async函数</code>内部是继发执行，外部不受影响。后面的<code>for...of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。  </p>
<p>再举个例子，下面这两段代码有什么区别？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import fs from &apos;fs-promise&apos;</span><br><span class="line"></span><br><span class="line">async function printFiles () &#123;</span><br><span class="line">  const files = await getFilePaths()</span><br><span class="line"></span><br><span class="line">  files.forEach(async (file) =&gt; &#123;</span><br><span class="line">    const contents = await fs.readFile(file, &apos;utf8&apos;)</span><br><span class="line">    console.log(contents)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFiles()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import fs from &apos;fs-promise&apos;</span><br><span class="line"></span><br><span class="line">async function printFiles () &#123;</span><br><span class="line">  const files = await getFilePaths()</span><br><span class="line"></span><br><span class="line">  for (const file of files) &#123;</span><br><span class="line">    const contents = await fs.readFile(file, &apos;utf8&apos;)</span><br><span class="line">    console.log(contents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFiles()</span><br></pre></td></tr></table></figure>
<p>第一段每个<code>forEach</code>的回调都是一个<code>async</code>函数，所以每个回调有自己的阻塞范围，回调内的<code>await</code>是相互独立的，不会互相阻塞，所以可以看为是并行的。<br>第二段只有一个<code>async</code>函数，就是外层的<code>printFiles</code>，<code>for...of</code>内的所有<code>await</code>不是互相独立的，要按次序执行，所以可以看成是继发的。<br>所以如果我们希望按顺序读取文件，那么第一段显然是错的，第二段是对的。  </p>
<p>其他实现方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function printFiles () &#123;</span><br><span class="line">  const files = await getFilePaths()</span><br><span class="line"></span><br><span class="line">  await Promise.all(files.map(async (file) =&gt; &#123;</span><br><span class="line">    const contents = await fs.readFile(file, &apos;utf8&apos;)</span><br><span class="line">    console.log(contents)</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仍然是并行的，<code>forEach</code>是没有返回值的，而用<code>map</code>配合<code>Promise.all</code>，可以通过<code>await</code>获得返回的 promise 数组。  </p>
<p>下面通过<code>reduce</code>实现，是按顺序执行的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function printFiles () &#123;</span><br><span class="line">  const files = await getFilePaths()</span><br><span class="line"></span><br><span class="line">  await files.reduce(async (promise, file) =&gt; &#123;</span><br><span class="line">    await promise</span><br><span class="line">    const contents = await fs.readFile(file, &apos;utf8&apos;)</span><br><span class="line">    console.log(contents)</span><br><span class="line">  &#125;, Promise.resolve())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES2018 的异步遍历器，是按顺序执行的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function printFiles () &#123;</span><br><span class="line">  const files = await getFilePaths()</span><br><span class="line"></span><br><span class="line">  for await (const file of fs.readFile(file, &apos;utf8&apos;)) &#123;</span><br><span class="line">    console.log(contents)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于理解异步遍历器，看下面的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let timeout = 1000</span><br><span class="line">const arr = [`h`, `e`, `l`, `l`, `o`, `w`, `o`, `r`, `l`, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">const test = &#123;</span><br><span class="line">  [Symbol.asyncIterator]: () =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      next: () =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          timeout += 1000</span><br><span class="line">          resolve(&#123; done: arr.length === 0, value: arr.shift() &#125;)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for await (const item of test) &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="并行执行异步操作"><a href="#并行执行异步操作" class="headerlink" title="并行执行异步操作"></a>并行执行异步操作</h1><p>如果一组异步操作是无关联相互独立的，比如首屏调用多个不相互依赖的接口，可以使用<code>Promise.all</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let [ra, rb, rc] = await Promise.all([a, b, c])</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>但如果其中任何一个接口挂掉了，任一 promise 被<code>reject</code>，则直接会被<code>catch</code>捕获走<code>catch</code>内的逻辑，那么其他接口的返回数据就无法获取，这显然不是我们想看到的。  </p>
<p>解决办法就是对每一个 promise 做异常处理：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.all([a, b, c].map(p =&gt; p.catch(e =&gt; &#123;...&#125;)))</span><br><span class="line">  .then(res =&gt; &#123;...&#125;)</span><br><span class="line">  .catch(err =&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure></p>
<p>也就是在第一个<code>catch</code>内并不抛出异常，而是返回给下一个<code>then</code>，在下一个<code>then</code>内判断哪些是正常返回，哪些是异常返回。举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a = Promise.resolve(1)</span><br><span class="line">const b = Promise.reject(2)</span><br><span class="line">const c = Promise.resolve(3)</span><br><span class="line"></span><br><span class="line">Promise.all([a, b, c].map(p =&gt; p.catch(e =&gt; &#123;</span><br><span class="line">  console.log(`pe=$&#123;e&#125;`)</span><br><span class="line">  return 100</span><br><span class="line">&#125;)))</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  console.log(&apos;then&apos;, `res=$&#123;res&#125;`);</span><br><span class="line">  for (let i of res) &#123;</span><br><span class="line">    console.log(&apos;then&apos;, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">  console.log(&apos;catch&apos;, `err=$&#123;err&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 打印结果</span><br><span class="line">pe=2</span><br><span class="line">then res=1,100,3</span><br><span class="line">then 1</span><br><span class="line">then 100</span><br><span class="line">then 3</span><br></pre></td></tr></table></figure></p>
<p>虽然 b 被<code>reject</code>，但并不影响其他<code>resolve</code>的返回值。  </p>
<p>配合<code>await</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const a = Promise.resolve(1)</span><br><span class="line">    const b = Promise.reject(2)</span><br><span class="line">    const c = Promise.resolve(3)</span><br><span class="line"></span><br><span class="line">    let [ra, rb, rc] = await Promise.all([a, b, c].map(p =&gt; p.catch(e =&gt; 100)))</span><br><span class="line">    console.log(ra, rb, rc)  // 1 100 3</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    throw err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>通过 ES2020 的<code>Promise.allSettled()</code>实现。和<code>Promise.all</code>类似，但即使有 promise 失败变为<code>rejected</code>，也不会影响其他 promise 的状态。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a = Promise.resolve(1)</span><br><span class="line">const b = Promise.reject(2)</span><br><span class="line"></span><br><span class="line">Promise.allSettled([a, b]).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">// [&#123; status: &apos;fulfilled&apos;, value: 1 &#125;, &#123; status: &apos;rejected&apos;, reason: 2 &#125;]</span><br></pre></td></tr></table></figure></p>
<h1 id="控制-promise-并发"><a href="#控制-promise-并发" class="headerlink" title="控制 promise 并发"></a>控制 promise 并发</h1><p>当<code>Promise.all</code>中任务数量过多时，希望控制每个时刻并发执行的<code>promise</code>任务数量是固定的。当所有<code>promise</code>完成时，触发总的<code>resolve</code>。<br>因为<code>Promise.all</code>中的任务，其实是<code>promise</code>实例化的时候执行的，所以要限制并发，就要限制<code>promise</code>的实例化。就是把生成<code>promise</code>数组的的控制权交给并发控制逻辑。<br>这里参考一个第三方的库 <a href="https://www.npmjs.com/package/tiny-async-pool" target="_blank" rel="noopener">async-pool</a> 的实现。去掉不必要的代码，大概内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @param poolLimit 并发控制数 (&gt;= 1)</span><br><span class="line">* @param array</span><br><span class="line">* @param iteratorFn 异步任务，返回 promise 或是 async 方法</span><br><span class="line">*/</span><br><span class="line">function asyncPool (poolLimit, array, iteratorFn) &#123;</span><br><span class="line">    let i = 0</span><br><span class="line">    const ret = []  // Promise.all(ret) 的数组</span><br><span class="line">    const executing = []</span><br><span class="line">    const enqueue = function () &#123;</span><br><span class="line">        // array 遍历完，进入 Promise.all 流程</span><br><span class="line">        if (i === array.length) &#123;</span><br><span class="line">            return Promise.resolve()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 每调用一次 enqueue，就初始化一个 promise，并放入 ret 队列</span><br><span class="line">        const item = array[i++]</span><br><span class="line">        const p = Promise.resolve().then(() =&gt; iteratorFn(item, array))</span><br><span class="line">        ret.push(p)</span><br><span class="line"></span><br><span class="line">        // 插入 executing 队列，即正在执行的 promise 队列，并且 promise 执行完毕后，会从 executing 队列中移除</span><br><span class="line">        const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1))</span><br><span class="line">        executing.push(e)</span><br><span class="line"></span><br><span class="line">        // 每当 executing 数组中 promise 数量达到 poolLimit 时，就利用 Promise.race 控制并发数，完成的 promise 会从 executing 队列中移除，并触发 Promise.race 也就是 r 的回调，继续递归调用 enqueue，继续 加入新的 promise 任务至 executing 队列</span><br><span class="line">        let r = Promise.resolve()</span><br><span class="line">        if (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">            r = Promise.race(executing)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 递归，链式调用，直到遍历完 array</span><br><span class="line">        return r.then(() =&gt; enqueue())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return enqueue().then(() =&gt; Promise.all(ret))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array = [1000, 5000, 2000, 3000]</span><br><span class="line">const timeout = i =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(i), i))</span><br><span class="line"></span><br><span class="line">return asyncPool(3, array, timeout).then(results =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>大概过程如下：</p>
<ul>
<li>将 1000、5000 和 2000 的<code>promise</code>依次加入<code>ret</code>和<code>executing</code>队列</li>
<li>之后发现达到 poolLimit = 3，调用<code>Promise.race(executing)</code></li>
<li>1000 的<code>promise</code>会率先<code>resolve</code>，并从<code>executing</code>队列移除，之后继续递归</li>
<li>将 3000 的<code>promise</code>加入<code>executing</code>队列，此时 5000 和 2000 的<code>promise</code>还是<code>pending</code>状态，<code>executing</code>队列中为 5000、2000、3000 三个任务，达到<code>poolLimit</code>，再次调用<code>Promise.race</code>，</li>
<li>一秒后 2000 的<code>promise</code>被<code>resolve</code>，从队列中移除，接着发现遍历结束，中断递归，最后调用<code>Promise.all(ret)</code></li>
<li>此时<code>ret</code>队列中 1000 和 2000 的<code>promise</code>都是<code>resolve</code>，等待 3000 和 5000 的都完成后，最后触发<code>Promise.all</code>实例的回调，并将结果返回  </li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><strong><a href="http://es6.ruanyifeng.com/#docs/async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">ECMAScript 6 入门</a> - 阮一峰</strong>  </p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 的 Symbol</title>
    <url>/post/f44a9376.html</url>
    <content><![CDATA[<h1 id="第七种数据类型"><a href="#第七种数据类型" class="headerlink" title="第七种数据类型"></a>第七种数据类型</h1><p>在 ES6 出现前，Javascript 有 6 种数据类型：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Object</li>
</ul>
<p>每种类型都可以看做值的集合。前 5 种集合值的数量是有限的。比如 Boolean，只有<code>true</code>和<code>false</code>两种情况。Number 和 String 值的数量显然要多得多。根据 ECMA Standard，Number 大约有18,437,736,874,454,810,627 个值，String 的话大约有 (2144,115,188,075,855,872 − 1) ÷ 65,535 种可能。而对象的范围是无限的，每一个对象都是独一无二的。  </p>
<p>ES6 Symbol 是第七种数据类型。它有什么用处呢？  </p>
<h1 id="ES5-的问题"><a href="#ES5-的问题" class="headerlink" title="ES5 的问题"></a>ES5 的问题</h1><p>在 JavaScript 对象上存储数据是很容易的。<br>比如说，我们想要写一个库通过 CSS transitions 让 DOM 元素随机游走，但是我们发现 CSS 效果没有生效，元素的运动轨迹不连贯。我们想跟踪哪些元素在运动，可以把元素给元素上加一个布尔类型属性 flag：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (element.isMoving) &#123;</span><br><span class="line">  smoothAnimations(element)</span><br><span class="line">&#125;</span><br><span class="line">element.isMoving = true</span><br></pre></td></tr></table></figure></p>
<p>但这样做会有潜在问题。</p>
<ol>
<li>其他的使用者如果用<code>for-in</code>或<code>Object.keys()</code>遍历该元素的话，会将<code>isMoving</code>遍历出来，带来混肴。</li>
<li>如果其他人碰巧也在该元素上添加了<code>isMoving</code>同名的属性或方法，会产生冲突。</li>
</ol>
<p>当然，你可以通过复杂的命名来解决第二个问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123;</span><br><span class="line">  smoothAnimations(element)</span><br><span class="line">&#125;</span><br><span class="line">element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true</span><br></pre></td></tr></table></figure></p>
<p>这显然不是一个好的办法。</p>
<p>那么我们可以通过加密包生成一个唯一的属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isMoving = Random.generateName();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if (element[isMoving]) &#123;</span><br><span class="line">  smoothAnimations(element)</span><br><span class="line">&#125;</span><br><span class="line">element[isMoving] = true</span><br></pre></td></tr></table></figure></p>
<p>这样就可以避免冲突了。但是这样如何调试？每次加载的属性名都不同，debug的话也不方便。</p>
<h1 id="Symbol-的引入"><a href="#Symbol-的引入" class="headerlink" title="Symbol 的引入"></a>Symbol 的引入</h1><p>Symbol 的出现解决了属性名冲突的问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mySymbol = Symbol()</span><br></pre></td></tr></table></figure></p>
<p>Symbol() 会生成一个第一无二的 Symbol 值。就像 Number 和 String 一样，Symbol 也可以被当作属性名，凡是属性名属于 Symbol 类型，就都是独一无二的，不会与其他属性名产生冲突。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj[mySymbol] = &apos;ok!&apos;</span><br><span class="line">console.log(obj[mySymbol])  // ok!</span><br></pre></td></tr></table></figure></p>
<p>对于上述问题，可以用 Symbol 来解决，不用加密也可以达到相同的效果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isMoving = Symbol(&apos;isMoving&apos;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if (element[isMoving]) &#123;</span><br><span class="line">  smoothAnimations(element)</span><br><span class="line">&#125;</span><br><span class="line">element[isMoving] = true</span><br></pre></td></tr></table></figure></p>
<p><code>element[isMoving]</code>是<code>symbol-keyed property</code>，不能通过点获取<code>obj.name</code>，只能通过方括号获取。  </p>
<p>因为 Symbol 的出现是为了避免冲突，所以它未被包含在对象自身的属性名集合<code>(property names)</code>之中。所以 JS 常规的对象检测方法会忽略 Symbol 属性名。比如<code>for-in</code>循环，会跳过 Symbol keys，<code>Object.keys(obj)、Object.getOwnPropertyNames(obj)、JSON.stringify()</code>也一样会忽略。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用 Symbol 来定义。  </p>
<p>但是 Symbol 不是私有的，可用通过新的 API <code>Object.getOwnPropertySymbols(obj)</code>获取，该方法返回一个数组，包含对象所有的 Symbol keys。也可通过<code>Reflect.ownKeys(obj)</code>，返回包含 Symbol keys 在内的所有属性名。  </p>
<p>我们会发现在很多库和框架中用到了 Symbol，当然 JS 中本身在很多地方也用到了 Symbol。</p>
<h1 id="什么是-Symbol-？"><a href="#什么是-Symbol-？" class="headerlink" title="什么是 Symbol ？"></a>什么是 Symbol ？</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sym = Symbol(&apos;foo&apos;) // Symbol(foo)</span><br><span class="line"></span><br><span class="line">typeof sym // &apos;symbol&apos;</span><br></pre></td></tr></table></figure>
<p>通过 Symbol() 生成一个原始类型的值，不是对象。一经创建就不会被改变，不能在上面添加属性，是一种类似于字符串的数据类型。  </p>
<p>另一方面，每个 Symbol 都是独一无二的，任何两个 Symbol 都不一样，即使传的描述一样，这一点和对象很像。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol()</span><br><span class="line">let s2 = Symbol()</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br><span class="line"></span><br><span class="line">let s1 = Symbol(&apos;foo&apos;)</span><br><span class="line">let s2 = Symbol(&apos;foo&apos;)</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br></pre></td></tr></table></figure></p>
<p>读取描述需要将 Symbol 显式转为字符串，或者利用 ES2019 提供的<code>description</code>属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sym = Symbol(&apos;foo&apos;)</span><br><span class="line"></span><br><span class="line">String(sym) // Symbol(foo)</span><br><span class="line">sym.toString() // Symbol(foo)</span><br><span class="line">sym.description // &apos;foo&apos;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，Symbol 不能被隐式转换为字符串，不能和其他数据类型计算。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sym = Symbol(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">&quot;your symbol is &quot; + sym</span><br><span class="line">// TypeError: can&apos;t convert symbol to string</span><br><span class="line">`your symbol is $&#123;sym&#125;`</span><br><span class="line">// TypeError: can&apos;t convert symbol to string</span><br></pre></td></tr></table></figure></p>
<h1 id="三种-Symbol"><a href="#三种-Symbol" class="headerlink" title="三种 Symbol"></a>三种 Symbol</h1><p>有三种获取 Symbol 的方法：</p>
<ul>
<li><strong>Symbol()</strong>：就像上文所述，每次调用都会返回一个唯一的 Symbol 值。</li>
<li><strong>Symbol.for(string)</strong>：传入字符串作为描述，会在现有的全局 Symbol 集合中查找有没有以该描述作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。如果我们调用<code>Symbol.for(&#39;cat&#39;)</code>三次，则每次都会返回相同的 Symbol 值，不同于每次返回唯一值的 <code>Symbol()</code>，<code>Symbol.for()</code>使我们可以重复使用同一个 Symbol 值。</li>
<li><strong>Symbol.iterator</strong>：由规范定义，每种有不同的目的。</li>
</ul>
<h1 id="ES6-中-Symbol-使如何使用的"><a href="#ES6-中-Symbol-使如何使用的" class="headerlink" title="ES6 中 Symbol 使如何使用的 ?"></a>ES6 中 Symbol 使如何使用的 ?</h1><p>iterator 是一种设计模式，很多语言（比如java）通过 iterator 实现遍历功能，如果一个值支持遍历，那么它只需要实现 iterator 接口即可。  </p>
<p>在 JS 中也是一样，只是在 Symbol 出现之前这是一个隐藏的特性，我们只能通过 for 循环来实现数组遍历。</p>
<p>在 ES6 中的<code>for-of</code>遍历，就是通过隐藏的 iterator 来实现遍历的。其实是被遍历的对象已经部署了遍历器，遍历时其实是调用<code>array[Symbol.iterator]()</code>，返回该对象的默认遍历器。所以能被<code>for-of</code>遍历的数据类型像 Array、String、Map、Set 都部署了<code>Symbol.iterator</code>属性。  </p>
<p>而且现在我们可以通过 Symbol.iterator 来取到 iterator 对象，并且自己调用 iterator.next() 来实现遍历：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const iterator = arr[Symbol.iterator]()</span><br><span class="line">iterator.next() // &#123;value: 1, done: false&#125;</span><br><span class="line">iterator.next() // &#123;value: 2, done: false&#125;</span><br><span class="line">iterator.next() // &#123;value: 3, done: false&#125;</span><br><span class="line">iterator.next() // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然也可以通过<code>array.iterator()</code>来实现，但 Symbol 的使用避免了冲突保证了唯一性，可以更好的向后兼容。  </p>
<p>除此之外，还有几处 Symbol 的应用场景：</p>
<ul>
<li><strong>使 instanceof 更具扩展性</strong>：在 ES6 中，<code>object instanceof constructor</code>被指定为构造方法<code>constructor[Symbol.hasInstance](object)</code>，使其更加灵活。</li>
<li><strong>消除新旧特性的冲突</strong>：是由动态作用域造成的，所以 ES6 引入了<code>Symbol.unscopables</code>，Web 标准可以用来将某些属性方法排除在动态作用域之外。</li>
<li><strong>支持新的 string-matching</strong>：在 ES5 中， <code>str.match(object)</code>会把<code>object</code>转换为<code>RegExp</code>。在 ES6 中，会先查看是否有<code>object[Symbol.match](str)</code>方法。  </li>
</ul>
<p>总之，从长远角度来看，ECMA 标准会通过 Symbol 添加更多的新特性，并且不用担心冲突问题。在实际应用中，我们也可以用 Symbol 作为对象属性名，定义类的私有属性方法。</p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2019</title>
    <url>/post/46ad9c0.html</url>
    <content><![CDATA[<h1 id="Array-flat-depth"><a href="#Array-flat-depth" class="headerlink" title="Array.flat(depth)"></a>Array.flat(depth)</h1><p>递归平铺多维数组，<code>depth</code>指定嵌套数组中的结构深度，也就是指定的递归层级，默认是 1。此方法并不修改原数组，而是返回一个新的数组。  </p>
<p>之前如果我们想平铺数组可以这样做：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flatten = arr =&gt; arr.reduce((flat, next) =&gt; flat.concat(Array.isArray(next) ? flatten(next) : next), [])</span><br></pre></td></tr></table></figure></p>
<p>或者利用展开运算符，但只适用于二维数组，不过可以通过递归平铺任意维度的数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flattenArray(arr) &#123;</span><br><span class="line">    const flattened = [].concat(...arr)</span><br><span class="line">    return flattened.some(item =&gt; Array.isArray(item))</span><br><span class="line">    ? flattenArray(flattened) </span><br><span class="line">    : flattened</span><br><span class="line">&#125;</span><br><span class="line">const arr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]]</span><br><span class="line">const flatArr = flattenArray(arr) // =&gt; [11, 22, 33, 44, 55, 66, 77, 88, 99]</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以直接使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2, [3, 4]]</span><br><span class="line">arr1.flat() // [1, 2, 3, 4]</span><br><span class="line">const arr2 = [1, 2, [3, 4, [5, 6]]]</span><br><span class="line"></span><br><span class="line">arr2.flat(2) // [1, 2, 3, 4, 5, 6]</span><br><span class="line">const arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]]</span><br><span class="line"></span><br><span class="line">arr3.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure></p>
<p>如果数组中有空值，则会在平铺后移除：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr4 = [1, 2, , 4, 5]</span><br><span class="line">arr4.flat() // [1, 2, 4, 5]</span><br></pre></td></tr></table></figure></p>
<h1 id="Array-flatMap"><a href="#Array-flatMap" class="headerlink" title="Array.flatMap()"></a>Array.flatMap()</h1><p>结合了<code>map</code>方法和<code>Array.flat()</code>方法，若<code>map</code>返回多维数组，会对该数组进行<code>depth</code>为 1 的平铺：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">arr1.map(x =&gt; [x * 4]) // [[4], [8], [12]]</span><br><span class="line">arr1.flatMap(x =&gt; [x * 4]) // [4, 8, 12]</span><br></pre></td></tr></table></figure></p>
<p>可以这样使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sentence = [&apos;This is a&apos;, &apos;regular&apos;, &apos;sentence&apos;]</span><br><span class="line"></span><br><span class="line">sentence.map(x =&gt; x.split(&apos; &apos;)) // [[&apos;This&apos;,&apos;is&apos;,&apos;a&apos;],[&apos;regular&apos;],[&apos;sentence&apos;]]</span><br><span class="line">sentence.flatMap(x =&gt; x.split(&apos; &apos;)) // [&apos;This&apos;,&apos;is&apos;,&apos;a&apos;,&apos;regular&apos;, &apos;sentence&apos;]</span><br></pre></td></tr></table></figure></p>
<h1 id="String-trimStart-和-String-trimEnd"><a href="#String-trimStart-和-String-trimEnd" class="headerlink" title="String.trimStart() 和 String.trimEnd()"></a>String.trimStart() 和 String.trimEnd()</h1><p>已有的<code>String.Trim()</code>会去除字符串前后的空格。而现在可以指定只移除一侧的空格：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const test = &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">test.trim() // &apos;hello&apos;</span><br><span class="line">test.trimStart() // &apos;hello &apos;</span><br><span class="line">test.trimEnd() // &apos; hello&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h1><p>将键值对数组转化为对象。是<code>Object.Entries</code>的反操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123; prop1: 2, prop2: 10, prop3: 15 &#125;                                   </span><br><span class="line">let array = Object.entries(obj) // [[&apos;prop1&apos;, 2], [&apos;prop2&apos;, 10], [&apos;prop3&apos;, 15]]</span><br><span class="line">array = array.map(([key, value]) =&gt; [key, Math.pow(value, 2)]) // [[&apos;prop1&apos;, 4], [&apos;prop2&apos;, 100], [&apos;prop3&apos;, 225]]</span><br><span class="line">const newObj = Object.fromEntries(array) // &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Optional-Catch-Binding"><a href="#Optional-Catch-Binding" class="headerlink" title="Optional Catch Binding"></a>Optional Catch Binding</h1><p>可省略<code>catch</code>的参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125; catch (er) &#123;</span><br><span class="line">    //handle error with parameter er</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    //...</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    //handle error without parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Symbol-description"><a href="#Symbol-description" class="headerlink" title="Symbol.description"></a>Symbol.description</h1><p>可通过新增的<code>description</code>属性读取<code>Symbol</code>的描述，在之前需要通过<code>toString()</code>将<code>Symbol</code>显式转为字符串：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const testSymbol = Symbol(&apos;Desc&apos;)</span><br><span class="line"></span><br><span class="line">testSymbol.description // &apos;Desc&apos;</span><br></pre></td></tr></table></figure></p>
<h1 id="Function-toString"><a href="#Function-toString" class="headerlink" title="Function.toString()"></a>Function.toString()</h1><p>返回表示函数源代码的字符串（包括空格和逗号）。之前调用该方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function /* foo comment */ foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString() // &apos;function foo() &#123;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在的话：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.toString(); // &apos;function /* foo comment */ foo() &#123;&#125;&apos;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Object.create()：创建对象的新方式</title>
    <url>/post/f92303d3.html</url>
    <content><![CDATA[<blockquote bgcolor="#FF4500">在 Vue 和 Vuex 的源码中，作者都使用了<code>Object.create(null)</code>来初始化一个新对象。为什么不用更简洁的<code>{}</code>呢？</blockquote>

<h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create(proto[, propertiesObject])</span><br></pre></td></tr></table></figure>
<ul>
<li>proto：新创建对象的原型对象。</li>
<li>propertiesObject：可选。要添加到新创建对象的<strong>可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）</strong>的属性描述符以及相应的属性名称。这些属性对应<code>Object.defineProperties()</code>的第二个参数。</li>
</ul>
<h1 id="new-一个函数-和-Object-create-都发生了什么"><a href="#new-一个函数-和-Object-create-都发生了什么" class="headerlink" title="new 一个函数 和 Object.create 都发生了什么"></a>new 一个函数 和 Object.create 都发生了什么</h1><p>new 一个构造函数时相当于：</p>
<ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// new Father()</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj._proto_ = Father.prototype</span><br><span class="line">Father.call(obj)</span><br><span class="line">return obj</span><br></pre></td></tr></table></figure>
<p>Object.create() 创建一个新对象，其中第一个参数是对象的原型。本质上来说是对一个对象进行了浅拷贝：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create = function (obj) &#123;</span><br><span class="line">  var F = function () &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="和-Object-create-的区别"><a href="#和-Object-create-的区别" class="headerlink" title="{} 和 Object.create() 的区别"></a>{} 和 Object.create() 的区别</h1><p><code>{}</code>相当于 <code>new Object()</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure></p>
<p>新创建的对象继承了<code>Object</code>自身的方法，如<code>hasOwnProperty、toString</code>等，在新对象上可以直接使用。  </p>
<p>再看看使用<code>Object.create()</code>创建对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = Object.create(null)</span><br><span class="line">obj.__proto__ === Object.prototype  // false</span><br><span class="line">console.log(obj.__proto__)  // undefined</span><br></pre></td></tr></table></figure></p>
<p>打印出来 obj 是没有<code>_proto_</code>属性的。参考上一段，因为在创建过程中 <code>F.prototype = null</code> 原型链被切断了。<br>如果把上面例子改一改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = Object.create(&#123;&#125;)</span><br><span class="line">obj.__proto__.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure></p>
<p>打印出来 obj 是有<code>_proto_</code>属性的。<br>那么再改一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = Object.create(Object.prototype)</span><br><span class="line">obj.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure></p>
<p>则结果和使用<code>{}</code>创建对象的结果一样了。所以：</p>
<ul>
<li><code>{}</code>或<code>new Object()</code>相当于<code>Object.create(Object.prototype)</code>。</li>
<li><code>{}</code>或<code>new Object()</code>是将新创建的对象的<code>_proto_</code>指向构造函数的原型对象<code>Object.prototype</code>；而<code>Object.create()</code>是将新创建的对象的<code>_proto_</code>指向传入的对象；所以<code>Object.create()</code>如果传入的对象本身没有任何属性，比如<code>null</code>连<code>_proto_</code>也没有，则新创建的对象则是一个没有任何属性的对象。</li>
<li><code>{}</code>或<code>new Object()</code>过程中构造函数会被调用；而<code>Object.create()</code>即使传入的对象为构造函数，也不会调用该构造函数。  </li>
</ul>
<p>所以如果<code>let obj = Object.create(Father)</code>，则<code>obj</code>只是指向父类构造函数<code>Father</code>而不能继承<code>Father</code>的任何属性和方法。想要继承<code>Father.prototype</code>上的属性方法需要通过<code>let obj = Object.create(Father.prototype)</code>实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line">    this.a = 1</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.b = 2</span><br><span class="line">var child1 = new Father()</span><br><span class="line">var child2 = Object.create(Father)</span><br><span class="line">var child3 = Object.create(Father.prototype)</span><br><span class="line">console.log(child1.a, child1.b) // 2， 3</span><br><span class="line">console.log(child2.a, child2.b) // undefined, undefined</span><br><span class="line">console.log(child3.a, child3.b) // undefined, 3</span><br></pre></td></tr></table></figure></p>
<p>再回到文章开头的问题：<br><strong>Sure you can create an object that seems empty with {}, but that object still has a <code>__proto__</code> and the usual hasOwnProperty and other object methods. So if you aren’t subclassing another object, then <code>Object.create()</code> would be a new option to create a pure “dictionary” object by passing a null value to the function.</strong></p>
<h1 id="Object-create-实现类式继承"><a href="#Object-create-实现类式继承" class="headerlink" title="Object.create 实现类式继承"></a>Object.create 实现类式继承</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Car (desc) &#123;</span><br><span class="line">    this.desc = desc || &apos;car&apos;</span><br><span class="line">    this.color = &quot;red&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">    getInfo () &#123;</span><br><span class="line">        return &apos;A &apos; + this.color + &apos; &apos; + this.desc + &apos;.&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//instantiate object using the constructor function</span><br><span class="line">let car =  Object.create(Car.prototype)</span><br><span class="line">car.color = &quot;blue&quot;</span><br><span class="line">console.log(car.getInfo())    // &apos;A blue undefined.&apos;</span><br></pre></td></tr></table></figure>
<p>为什么<code>desc</code>打印出来是<code>undefined</code>？因为传入<code>Object.create()</code>的是<code>Car.prototype</code>，<code>car._proto_ === Car.prototype</code>，只引用<code>prototype</code>而不引用<code>constructor</code>。  </p>
<p><strong>So, <code>Object.create()</code> is an excellent choice for creating an object without going through its constructor.</strong>   </p>
<p>所以，不像组合继承<code>Son.prototype = new Father()</code>那样父类的<code>constructor</code>还要被执行一便，使用<code>Son.prototype = Object.create(Father.prototype)</code>实现继承不会重复调用父类的构造函数。而子类的实例是可以沿原型链找到父类的，可以共享父类原型上的属性方法。  </p>
<p>下面的例子演示了如何使用<code>Object.create()</code>来实现类式继承：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Shape() &#123;</span><br><span class="line">    this.x = 0</span><br><span class="line">    this.y = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 父类的方法</span><br><span class="line">Shape.prototype.move = function(x, y) &#123;</span><br><span class="line">    this.x += x</span><br><span class="line">    this.y += y</span><br><span class="line">    console.info(&apos;Shape moved.&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Rectangle() &#123;</span><br><span class="line">    Shape.call(this) // call super constructor.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子类续承父类</span><br><span class="line">Rectangle.prototype = Object.create(Shape.prototype)</span><br><span class="line">Rectangle.prototype.constructor = Rectangle</span><br><span class="line"></span><br><span class="line">var rect = new Rectangle()</span><br><span class="line"></span><br><span class="line">console.log(&apos;Is rect an instance of Rectangle?&apos;, rect instanceof Rectangle) // true</span><br><span class="line">console.log(&apos;Is rect an instance of Shape?&apos;, rect instanceof Shape) // true</span><br><span class="line">rect.move(1, 1) // &apos;Shape moved.&apos;</span><br></pre></td></tr></table></figure></p>
<p>如果你希望能继承到多个对象，则可以使用混入的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyClass() &#123;</span><br><span class="line">    SuperClass.call(this)</span><br><span class="line">    OtherSuperClass.call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype)</span><br><span class="line">// 混合其它</span><br><span class="line">Object.assign(MyClass.prototype, OtherSuperClass.prototype)</span><br><span class="line">// 重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = function() &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>有用的 js 技巧</title>
    <url>/post/a76aaff9.html</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><ol>
<li><code>Array.concat()</code>：会创建一个新的数组，对于大数组来说会消耗大量内存。</li>
<li><code>Array.push.apply(arr1，arr2)</code></li>
</ol>
<h2 id="类数组-arguments-对象、DOM-节点列表转化成数组的几种方式"><a href="#类数组-arguments-对象、DOM-节点列表转化成数组的几种方式" class="headerlink" title="类数组 arguments 对象、DOM 节点列表转化成数组的几种方式"></a>类数组 arguments 对象、DOM 节点列表转化成数组的几种方式</h2><ol>
<li>for 循环后 rebuild</li>
<li><p>ES5 - <code>Array.prototype.slice.call(NodeList)</code> (性能差)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以 arguments 为例</span><br><span class="line">(function fn()&#123;</span><br><span class="line">  var arr = Array.prototype.slice.call(arguments)</span><br><span class="line">  return arr.reduce((prev, curr) =&gt; prev + curr, 0)</span><br><span class="line">&#125;)(1, 2, 3, 4) // 10</span><br></pre></td></tr></table></figure>
<p>可以使用如下方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function acc(...arr) &#123;</span><br><span class="line">  return arr.reduce((prev, curr) =&gt; prev + curr, 0)</span><br><span class="line">&#125;</span><br><span class="line">function fn() &#123;</span><br><span class="line">  return acc.apply(null, arguments)</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2, 3, 4) // 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 - 数组/对象扩展运算符<code>arr = [...NodeList]</code></p>
</li>
<li><code>Array.from()</code><br>ES6 为了增加语义的清晰，语法的简洁性。添加了一个新方法<code>Array.from</code>，用于将 arrayLike 的对象转换成数组。<br><code>Array.from</code>方法用于将两类对象转为真正的数组：<ul>
<li>可遍历（iterable）的对象（包括 Set 和 Map）。</li>
<li>类似数组的对象（array-like object）：所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组。比如：<ul>
<li>arguments 对象</li>
<li>DOM NodeList 对象</li>
<li>包含 length 属性的普通对象 <code>{ a: 1, b: 2, length: 2 }</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Array-and-Boolean"><a href="#Array-and-Boolean" class="headerlink" title="Array and Boolean"></a>Array and Boolean</h2><p>数组中去除<code>falsy values(0, undefined, null, false, etc.)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array</span><br><span class="line">  .map(item =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .filter(Boolean)    // Get rid of bad values</span><br></pre></td></tr></table></figure></p>
<h1 id="0、1互换"><a href="#0、1互换" class="headerlink" title="0、1互换"></a>0、1互换</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">a = ~a + 2</span><br><span class="line">console.log(a) // 1</span><br></pre></td></tr></table></figure>
<h1 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ES5</span><br><span class="line">var max = Math.max.apply(null, arr)</span><br><span class="line">var min = Math.min.apply(null, arr)</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">var max = Math.max(...arr)</span><br><span class="line">var min = Math.min(...arr)</span><br></pre></td></tr></table></figure>
<h1 id="是否可迭代"><a href="#是否可迭代" class="headerlink" title="是否可迭代"></a>是否可迭代</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ((typeof arr[Symbol.iterator]).toUpperCase() === &apos;FUNCTION&apos;) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建空对象"><a href="#创建空对象" class="headerlink" title="创建空对象"></a>创建空对象</h1><p><a href="http://www.luanzhuxian.com/post/f92303d3.html">Object.create()：创建对象的新方式</a>  </p>
<h1 id="Merge-Objects"><a href="#Merge-Objects" class="headerlink" title="Merge Objects"></a>Merge Objects</h1><ol>
<li><code>Object.assgin()</code></li>
<li>扩展运算符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const person = &#123; name: &apos;David Walsh&apos;, gender: &apos;Male&apos; &#125;</span><br><span class="line">const tools = &#123; computer: &apos;Mac&apos;, editor: &apos;Atom&apos; &#125;</span><br><span class="line">const attributes = &#123; handsomeness: &apos;Extreme&apos;, hair: &apos;Brown&apos;, eyes: &apos;Blue&apos; &#125;</span><br><span class="line">const summary = &#123; ...person, ...tools, ...attributes &#125;</span><br><span class="line">/*</span><br><span class="line">Object &#123;</span><br><span class="line">    &quot;computer&quot;: &quot;Mac&quot;,</span><br><span class="line">    &quot;editor&quot;: &quot;Atom&quot;,</span><br><span class="line">    &quot;eyes&quot;: &quot;Blue&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;Male&quot;,</span><br><span class="line">    &quot;hair&quot;: &quot;Brown&quot;,</span><br><span class="line">    &quot;handsomeness&quot;: &quot;Extreme&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;David Walsh&quot;,</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Require-Function-Parameters"><a href="#Require-Function-Parameters" class="headerlink" title="Require Function Parameters"></a>Require Function Parameters</h1><p>函数的必选参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isRequired = () =&gt; &#123; throw new Error(&apos;param is required&apos;) &#125;</span><br><span class="line">const hello = (name = isRequired()) =&gt; &#123; console.log(`hello $&#123;name&#125;`) &#125;</span><br><span class="line"></span><br><span class="line">hello() // This will throw an error because no name is provided</span><br><span class="line">hello(undefined)    // This will also throw an error</span><br><span class="line">hello(null)     // hello null</span><br><span class="line">hello(&apos;David&apos;)  // hello David</span><br></pre></td></tr></table></figure></p>
<h1 id="Get-Query-String-Parameters"><a href="#Get-Query-String-Parameters" class="headerlink" title="Get Query String Parameters"></a>Get Query String Parameters</h1><p>获取 url 参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Assuming &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line">let urlParams = new URLSearchParams(window.location.search)</span><br><span class="line"></span><br><span class="line">console.log(urlParams.has(&apos;post&apos;)) // true</span><br><span class="line">console.log(urlParams.get(&apos;action&apos;)) // &quot;edit&quot;</span><br><span class="line">console.log(urlParams.getAll(&apos;action&apos;)) // [&quot;edit&quot;]</span><br><span class="line">console.log(urlParams.toString()) // &quot;?post=1234&amp;action=edit&quot;</span><br><span class="line">console.log(urlParams.append(&apos;active&apos;, &apos;1&apos;)) // &quot;?post=1234&amp;action=edit&amp;active=1&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML Element Property</title>
    <url>/post/33db1ae8.html</url>
    <content><![CDATA[<h4 id="offsetParent："><a href="#offsetParent：" class="headerlink" title="offsetParent："></a>offsetParent：</h4><p>返回一个元素对象：</p>
<ul>
<li>如果祖先元素中具有定位元素，此属性返回距离它最近的定位元素。</li>
<li>如果祖先元素中没有定位元素，那么返回最近的 table、td、th 或者 body 元素。  </li>
</ul>
<h4 id="offsetTop："><a href="#offsetTop：" class="headerlink" title="offsetTop："></a>offsetTop：</h4><ul>
<li><code>当前元素顶端</code>至<code>父元素顶端</code>距离，鼠标滚轮不会影响其数值。  </li>
<li>不包括 border (当前元素 border 外到父元素 border 内)。   </li>
<li>此属性可以获取<code>元素的上外缘</code>至<code>offsetParent</code>的距离，如果没有 offsetParent，则是至<code>文档内壁</code>的距离。  </li>
</ul>
<h4 id="clientTop："><a href="#clientTop：" class="headerlink" title="clientTop："></a>clientTop：</h4><p>当前元素client区域左上角与整个元素左上角的垂直距离，即上边框的高度。 </p>
<h4 id="scrollTop："><a href="#scrollTop：" class="headerlink" title="scrollTop："></a>scrollTop：</h4><p><code>当前元素顶端</code>到<code>该元素在视口区域内的顶部</code>的距离，也就是该元素内部滚动条的下拉距离。 </p>
<h4 id="Element-getBoundingClientRect-top："><a href="#Element-getBoundingClientRect-top：" class="headerlink" title="Element.getBoundingClientRect().top："></a>Element.getBoundingClientRect().top：</h4><p>当前元素距离可视区域顶部的距离。<br><strong>注意：top 和 bottom 都是相对于可视区域顶部的，left 和 right 都是相对于可视区域左边的。</strong>  </p>
<h4 id="offsetWidth："><a href="#offsetWidth：" class="headerlink" title="offsetWidth："></a>offsetWidth：</h4><p>元素的宽度，元素width + padding + 边框，不包括 margin 和滚动条部分。  </p>
<h4 id="offsetHeight："><a href="#offsetHeight：" class="headerlink" title="offsetHeight："></a>offsetHeight：</h4><p>元素的高度，元素 height + padding + 边框，不包括 margin 和滚动条部分。  </p>
<h4 id="clientWidth："><a href="#clientWidth：" class="headerlink" title="clientWidth："></a>clientWidth：</h4><p>元素的宽度，元素 width + padding，不包括边框、margin 和滚动条部分。  </p>
<h4 id="clientHeight："><a href="#clientHeight：" class="headerlink" title="clientHeight："></a>clientHeight：</h4><p>元素的高度，元素 height + padding，不包括边框、margin 和滚动条部分。  </p>
<h4 id="scrollWidth："><a href="#scrollWidth：" class="headerlink" title="scrollWidth："></a>scrollWidth：</h4><p>元素的宽度。它包括由于出现滚动条而导致溢出不可见的部分。一般等于 clientWidth  </p>
<h4 id="scrollHeight："><a href="#scrollHeight：" class="headerlink" title="scrollHeight："></a>scrollHeight：</h4><p>元素的高度。它包括由于出现滚动条而导致溢出不可见的部分。一般等于 clientHeight  </p>
<h4 id="window-scrollTo："><a href="#window-scrollTo：" class="headerlink" title="window.scrollTo："></a>window.scrollTo：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.scrollTo(x-coord, y-coord)</span><br><span class="line"></span><br><span class="line">window.scrollTo(options)</span><br><span class="line">// options = &#123; top: y-coord, left: x-coord, behavior: smooth(平滑滚动) / instant(瞬间滚动) / auto(默认值，效果等同于instant) &#125;</span><br><span class="line"></span><br><span class="line">// 设置滚动行为改为平滑的滚动</span><br><span class="line">window.scrollTo(&#123; </span><br><span class="line">    top: 1000, </span><br><span class="line">    behavior: &quot;smooth&quot; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/post/1690d21b.html</url>
    <content><![CDATA[<p>主要的编程范式有三种：命令式编程（Imperative programming）、面向对象编程（Object Oriented Programming）和函数式编程（Functional Programming）。  </p>
<p>假设我们有这么个需求，我们登记了一系列人名存在数组中，现在需要对这个结构进行一些修改，需要把字符串数组变成一个对象数组，方便后续的扩展，并且需要把人名做一些转换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;john-reese&apos;, &apos;harold-finch&apos;, &apos;sameen-shaw&apos;] </span><br><span class="line">// 转换成</span><br><span class="line">[&#123;name: &apos;John Reese&apos;&#125;, &#123;name: &apos;Harold Finch&apos;&#125;, &#123;name: &apos;Sameen Shaw&apos;&#125;]</span><br></pre></td></tr></table></figure></p>
<h1 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h1><p>用传统的编程思路，乎是所有人下意识的编程思路，完全的面向过程。会需要依次完成：</p>
<ul>
<li>定义一个临时变量 newArr。</li>
<li>我需要做一个循环。</li>
<li>循环需要做 arr.length 次。</li>
<li>每次把名字的首位取出来大写，然后拼接剩下的部分。</li>
<li>……</li>
<li>最后返回结果。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [&apos;john-reese&apos;, &apos;harold-finch&apos;, &apos;sameen-shaw&apos;]</span><br><span class="line">const newArr = []</span><br><span class="line">for (let i = 0, len = arr.length; i &lt; len ; i++) &#123;</span><br><span class="line">  let name = arr[i]</span><br><span class="line">  let names = name.split(&apos;-&apos;)</span><br><span class="line">  let newName = []</span><br><span class="line">  for (let j = 0, naemLen = names.length; j &lt; naemLen; j++) &#123;</span><br><span class="line">    let nameItem = names[j][0].toUpperCase() + names[j].slice(1)</span><br><span class="line">    newName.push(nameItem)</span><br><span class="line">  &#125;</span><br><span class="line">  newArr.push(&#123; name : newName.join(&apos; &apos;) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">return newArr</span><br></pre></td></tr></table></figure>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程（以下简称 FP）是一种编程风格，就是将函数作为参数传递或作为返回值，但没有函数副作用（函数副作用即会改变程序的状态）。<br>凭借其高复用性、易测试性和与之带来的健壮性和简洁开始逐渐占据前端技术圈，我们发现越来越多的前端框架以 FP 为设计核心准则。  </p>
<p>我们来看一看函数式编程会如何思考这个问题。<br>我只需要一个函数能实现从 String 数组 到 Object 数组 的转换：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/functional-programming_1.png" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convertNames :: [String] -&gt; [Object]</span><br></pre></td></tr></table></figure></p>
<p>这里面涉及到一个 String -&gt; Object 的转换，那我需要有这么个函数实现这种转换：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/functional-programming_2.png" alt="avatar"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">convert2Obj :: [String] -&gt; [Object]</span><br></pre></td></tr></table></figure></p>
<p>至于这种转换，可以轻松想到需要两个函数完成：capitalizeName：把名称转换成指定形式，genObj：把任意类型转换成对象  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/functional-programming_3.png" alt="avatar"><br>如果再细想一下，capitalizeName 其实也是几个方法的组合（split, join, capitalize），剩下的几个函数都是非常容易实现的。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/functional-programming_4.png" alt="avatar"><br>代码实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const capitalize = x =&gt; x[0].toUpperCase() + x.slice(1).toLowerCase()</span><br><span class="line">const genObj = curry((key, x) =&gt; &#123;</span><br><span class="line">  let obj = &#123;&#125;</span><br><span class="line">  obj[key] = x</span><br><span class="line">  return obj</span><br><span class="line">&#125;) </span><br><span class="line">const capitalizeName = compose(join(&apos; &apos;), map(capitalize), split(&apos;-&apos;))</span><br><span class="line">const convert2Obj = compose(genObj(&apos;name&apos;), capitalizeName)</span><br><span class="line">const convertName = map(convert2Obj)</span><br><span class="line"></span><br><span class="line">convertName([&apos;john-reese&apos;, &apos;harold-finch&apos;, &apos;sameen-shaw&apos;])</span><br></pre></td></tr></table></figure></p>
<h1 id="函数式编程的特征："><a href="#函数式编程的特征：" class="headerlink" title="函数式编程的特征："></a>函数式编程的特征：</h1><h2 id="函数为一等公民-First-Class-Functions"><a href="#函数为一等公民-First-Class-Functions" class="headerlink" title="函数为一等公民(First-Class Functions)"></a>函数为一等公民(First-Class Functions)</h2><p>函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<h2 id="声明式编程-Declarative-Programming"><a href="#声明式编程-Declarative-Programming" class="headerlink" title="声明式编程 (Declarative Programming)"></a>声明式编程 (Declarative Programming)</h2><p>函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为 声明式编程 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。</p>
<h2 id="惰性执行（Lazy-Evaluation）"><a href="#惰性执行（Lazy-Evaluation）" class="headerlink" title="惰性执行（Lazy Evaluation）"></a>惰性执行（Lazy Evaluation）</h2><p>即不产生无意义的中间变量。</p>
<h2 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h2><h2 id="避免共享状态"><a href="#避免共享状态" class="headerlink" title="避免共享状态"></a>避免共享状态</h2><h2 id="无状态和数据不可变-Statelessness-and-Immutable-data"><a href="#无状态和数据不可变-Statelessness-and-Immutable-data" class="headerlink" title="无状态和数据不可变 (Statelessness and Immutable data)"></a>无状态和数据不可变 (Statelessness and Immutable data)</h2><ul>
<li>无状态：对于一个函数，输入和输出是一一对应的关系，给定相同的输入，会得到相同的输出，完全不依赖外部状态的变化。  </li>
<li>数据不可变：所有的数据都是不可变的，如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。(不修改全局变量，不修改入参)<br>为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。<br><img src="http://cdn.luanzhuxian.com/blog/functional-programming_5.png" alt="avatar"></li>
</ul>
<h2 id="没有副作用（No-Side-Effects）"><a href="#没有副作用（No-Side-Effects）" class="headerlink" title="没有副作用（No Side Effects）"></a>没有副作用（No Side Effects）</h2><p>在函数中我们最常见的副作用就是随意操纵外部变量。<br>例如：在 JS 中，我们经常可以看到下面这种对 map 的 “错误” 用法，把 map 当作一个循环语句，然后去直接修改数组中的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list = [...]</span><br><span class="line">// 修改 list 中的 type 和 age</span><br><span class="line">list.map(item =&gt; &#123;</span><br><span class="line">  item.type = 1</span><br><span class="line">  item.age++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样函数最主要的输出功能没有了，变成了直接修改了外部变量，这就是它的副作用。而没有副作用的写法应该是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const list = [...]</span><br><span class="line">// 修改 list 中的 type 和 age</span><br><span class="line">const newList = list.map(item =&gt; (&#123;...item, type: 1, age:item.age + 1&#125;))</span><br></pre></td></tr></table></figure></p>
<h1 id="纯函数（Pure-Functions）"><a href="#纯函数（Pure-Functions）" class="headerlink" title="纯函数（Pure Functions）"></a>纯函数（Pure Functions）</h1><p>函数式编程，本质上是数学，它是数学现有理论在编程上的实现。一个数学定理成立通常要满足一些条件，函数式编程也需要满足条件，这个条件就是函数必须是纯函数。  </p>
<p>纯函数是一种其返回值仅由其参数决定，没有任何副作用的函数。<br>对于输入 x 产生一个唯一输出 y=f(x)。这便是纯函数。它符合两个条件：</p>
<ul>
<li>不依赖外部状态（无状态）：此函数在相同的输入值时，总是产生相同的输出，函数的输出和当前运行环境的上下文状态无关，不依赖全局变量，this 指针，IO 操作等。</li>
<li>没有副作用（数据不可变）：此函数运行过程不影响运行环境，也就是无副作用（不修改全局变量、不修改入参、触发事件、发起 http 请求等）。  </li>
</ul>
<p>简单来说，也就是当一个函数不会更改或读取外部状态，输出不受外部环境影响，同时也不影响外部环境时，该函数就是纯函数，也就是它只关注逻辑运算和数学运算，同一个输入总得到同一个输出。<br>javascript 内置函数有不少纯函数如<code>map、slice、concat</code>，也有不少非纯函数如<code>splice、push</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">const impureAddNumber = number =&gt; arr.push(number)</span><br><span class="line">const pureAddNumber = number =&gt; anArray =&gt; anArray.concat([number])</span><br><span class="line"></span><br><span class="line">impureAddNumber(2) // returns 1</span><br><span class="line">arr // [2]</span><br><span class="line">pureAddNumber(3)(arr) // returns [2, 3]</span><br><span class="line">arr // [2]</span><br><span class="line">arr = pureAddNumber(3)(arr)</span><br><span class="line">arr // [2, 3]</span><br></pre></td></tr></table></figure></p>
<p><code>impureAddNumber</code>里<code>push</code>方法是不纯的，而且读取外部的<code>arr</code>。  </p>
<p>以下几个函数都是不纯的，因为他们都依赖外部变量，试想一下，<code>saySth</code>修改了外部变量，<code>changeName</code>修改了入参。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const curUser = &#123;</span><br><span class="line">  name: &apos;Peter&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const saySth = str =&gt; curUser.name + &apos;: &apos; + str // 引用了全局变量</span><br><span class="line">const changeName = (obj, name) =&gt; obj.name = name  // 修改了输入参数</span><br><span class="line">changeName(curUser, &apos;Jay&apos;)  // &#123; name: &apos;Jay&apos; &#125;</span><br><span class="line">saySth(&apos;hello!&apos;)  // Jay: hello!</span><br></pre></td></tr></table></figure></p>
<p>改成纯函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const curUser = &#123;</span><br><span class="line">  name: &apos;Peter&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const saySth = (user, str) =&gt; user.name + &apos;: &apos; + str   // 不依赖外部变量</span><br><span class="line">const changeName = (user, name) =&gt; (&#123;...user, name &#125;)  // 未修改外部变量</span><br><span class="line"></span><br><span class="line">const newUser = changeName(curUser, &apos;Jay&apos;)  // &#123; name: &apos;Jay&apos; &#125;</span><br><span class="line">saySth(curUser, &apos;hello!&apos;)  // Peter: hello!</span><br></pre></td></tr></table></figure></p>
<p>纯函数的意义</p>
<ul>
<li>便于测试和优化</li>
<li>自文档化</li>
<li>更少的 Bug</li>
<li>可缓存性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function memoize(fn) &#123;  </span><br><span class="line">  const cache = &#123;&#125;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    const key = JSON.stringify(arguments) </span><br><span class="line">    let value = cache[key]     </span><br><span class="line">    if (!value) &#123;</span><br><span class="line">      value = [fn.apply(null, arguments)]  // 放在一个数组中，方便应对 undefined，null 等异常情况</span><br><span class="line">      cache[key] = value</span><br><span class="line">    &#125;     </span><br><span class="line">    return value[0]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fibonacci = memoize(n =&gt; n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2))</span><br><span class="line">console.log(fibonacci(4))  // 执行后缓存了 fibonacci(2), fibonacci(3),  fibonacci(4)</span><br><span class="line">console.log(fibonacci(10)) // fibonacci(2), fibonacci(3),  fibonacci(4) 的结果直接从缓存中取出，同时缓存其他的</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数式编程例子"><a href="#函数式编程例子" class="headerlink" title="函数式编程例子"></a>函数式编程例子</h1><h2 id="分别实现数组所有元素相加、相乘、相与"><a href="#分别实现数组所有元素相加、相乘、相与" class="headerlink" title="分别实现数组所有元素相加、相乘、相与"></a>分别实现数组所有元素相加、相乘、相与</h2><p>非 FP 风格<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function plus (array) &#123;</span><br><span class="line">  var res = array[0]</span><br><span class="line">  for (let i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">    res += array[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mul (array) &#123;</span><br><span class="line">  var res = array[0]</span><br><span class="line">  for (let i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">    res *= array[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function and (array) &#123;</span><br><span class="line">  var res = array[0]</span><br><span class="line">  for (let i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">    res = res &amp; array[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plus(array)</span><br><span class="line">mul(array)</span><br><span class="line">and(array)</span><br></pre></td></tr></table></figure></p>
<p>FP 风格<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array = [1, 2, 3]</span><br><span class="line">var ops = &#123;</span><br><span class="line">  &quot;plus&quot;: (x, y) =&gt; x + y,</span><br><span class="line">  &quot;mul&quot; : (x, y) =&gt; x * y,</span><br><span class="line">  &quot;and&quot; : (x, y) =&gt; x &amp; y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function operation(op, [head, ...tail]) &#123;</span><br><span class="line">  return tail.reduce(ops[op], head)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">operation(&quot;plus&quot;, array)</span><br><span class="line">operation(&quot;mul&quot;,  array)</span><br><span class="line">operation(&quot;and&quot;,  array)</span><br></pre></td></tr></table></figure></p>
<p>函数式编程凭借其传递和返回函数的能力，带来了许多概念：</p>
<ul>
<li>柯里化</li>
<li>高阶函数  </li>
</ul>
<h2 id="柯里化（Currying）"><a href="#柯里化（Currying）" class="headerlink" title="柯里化（Currying）"></a>柯里化（Currying）</h2><p>如果说函数式编程中有两种操作是必不可少的那无疑就是柯里化（Currying）和函数组合（Compose），柯里化其实就是流水线上的加工站，函数组合就是我们的流水线，它由多个加工站组成。现在很好理解为什么柯里化配合函数组合有奇效了，在流水线上的加工站必须都是单元函数，柯里化处理的结果刚好就是单输入的。  </p>
<p>柯里化是函数式编程中的一种过程，将一个低阶函数转换为高阶函数的过程。<br>可以将接受具有多个参数的函数转化为一个的嵌套函数队列，然后返回一个新的函数以及期望下一个的内联参数。它不断返回一个新函数直到所有参数都用完为止。这些参数会通过闭包的形式保存，不会被销毁。当柯里化链中最后的函数返回并执行时，再一次性把所有传入的参数进行求值。柯里化函数的嵌套函数的数量取决于它接受的参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(a, b, c) =&gt; f(a)(b)(c)</span><br><span class="line">              f(a, b)(c)</span><br><span class="line">              f(a)(b, c)</span><br></pre></td></tr></table></figure></p>
<p>一个有 n 个参数的函数，可以使用柯里化将它变成一个一元函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const binaryFunction = (a, b) =&gt; a + b</span><br><span class="line">const curryUnaryFunction = a =&gt; b =&gt; a + b</span><br><span class="line">curryUnaryFunction(1) // returns a function: b =&gt; 1 + b</span><br><span class="line">curryUnaryFunction(1)(2) // returns the number 3</span><br></pre></td></tr></table></figure></p>
<h3 id="函数柯里化有用吗？"><a href="#函数柯里化有用吗？" class="headerlink" title="函数柯里化有用吗？"></a>函数柯里化有用吗？</h3><p>柯里化函数非常适合提高代码的可重用性和函数式结构。  </p>
<h4 id="1、编写轻松重用和配置的小代码块，就像我们使用-npm-一样："><a href="#1、编写轻松重用和配置的小代码块，就像我们使用-npm-一样：" class="headerlink" title="1、编写轻松重用和配置的小代码块，就像我们使用 npm 一样："></a>1、编写轻松重用和配置的小代码块，就像我们使用 npm 一样：</h4><p>举个例子，比如你想给顾客给个10%的折扣：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function discount(price, discount) &#123;</span><br><span class="line">  return price * discount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以预见，从长远来看，会发现自己每天都在重复计算 10% 的折扣：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const price = discount(1500, 0.10) // $150</span><br><span class="line">const price = discount(2000, 0.10) // $200</span><br><span class="line">const price = discount(50, 0.10) // $5</span><br><span class="line">const price = discount(5000, 0.10) // $500</span><br><span class="line">const price = discount(300, 0.10) // $30</span><br></pre></td></tr></table></figure></p>
<p>我们可以将 discount 函数柯里化，这样我们就不用总是每次增加这 0.01 的折扣。并且可以给客户提供 20% 的折扣。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function discount(discount) &#123;</span><br><span class="line">  return (price) =&gt; &#123;</span><br><span class="line">      return price * discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const tenPercentDiscount = discount(0.1)</span><br><span class="line">const twentyPercentDiscount = discount(0.2)</span><br><span class="line"></span><br><span class="line">twentyPercentDiscount(500) // 100</span><br><span class="line">twentyPercentDiscount(5000) // 1000</span><br><span class="line">twentyPercentDiscount(1000000) // 200000</span><br></pre></td></tr></table></figure></p>
<h4 id="2、避免频繁调用具有相同参数的函数"><a href="#2、避免频繁调用具有相同参数的函数" class="headerlink" title="2、避免频繁调用具有相同参数的函数"></a>2、避免频繁调用具有相同参数的函数</h4><p>举个例子，我们有一个计算圆柱体积的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function volume(l, w, h) &#123;</span><br><span class="line">  return l * w * h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>碰巧仓库所有的气缸高度为 100 米，你将会看到你将重复调用此函数，h 为 100 米<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volume(200, 30, 100) // 2003000</span><br><span class="line">volume(32, 45, 100) //144000</span><br><span class="line">volume(2322, 232, 100) // 53870400</span><br></pre></td></tr></table></figure></p>
<p>要解决以上问题，你可以将 volume 函数柯里化：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function volume(h) &#123;</span><br><span class="line">  return (w) =&gt; &#123;</span><br><span class="line">      return (l) =&gt; &#123;</span><br><span class="line">          return l * w * h</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以定义一个专门指定圆柱体高度的的函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hCylinderHeight = volume(100)</span><br><span class="line">hCylinderHeight(200)(30) // 600, 000</span><br><span class="line">hCylinderHeight(2322)(232) // 53, 870, 400</span><br></pre></td></tr></table></figure></p>
<h3 id="add-柯里化"><a href="#add-柯里化" class="headerlink" title="add 柯里化"></a>add 柯里化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add () &#123;</span><br><span class="line">  //args，利用闭包特性，不断保存arguments</span><br><span class="line">  var args = [].slice.call(arguments)</span><br><span class="line">  var _add = function () &#123;</span><br><span class="line">    if (arguments.length === 0) &#123;</span><br><span class="line">      //参数为空，对args执行加法</span><br><span class="line">      return args.reduce((a, b) =&gt; a + b)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //否则，保存参数到args，返回一个函数</span><br><span class="line">      Array.prototype.push.apply(args, arguments)</span><br><span class="line">      return _add</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return _add</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1, 2, 3)(1)(2)(3)(4, 5, 6)(7, 8)()) // 42</span><br></pre></td></tr></table></figure>
<p>可以看出来，柯里化其实是有特点的，需要一个闭包保存参数，一个函数来进行递归。这种模式是可以通过一个包装函数，它接受任何函数并返回一个柯里化版本的函数。  </p>
<h3 id="通用柯里化函数"><a href="#通用柯里化函数" class="headerlink" title="通用柯里化函数"></a>通用柯里化函数</h3><p>版本一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry (fn, ...args) &#123;</span><br><span class="line">  return (..._arg) =&gt; &#123;</span><br><span class="line">      return fn(...args, ..._arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function volume (l, h, w) &#123;</span><br><span class="line">  return l * h * w</span><br><span class="line">&#125;</span><br><span class="line">const hCy = curry(volume, 100)</span><br><span class="line">hCy(200, 900) // 18000000</span><br><span class="line">hCy(70, 60) // 420000</span><br></pre></td></tr></table></figure></p>
<p>版本二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry (func) &#123;</span><br><span class="line">  // args保存参数，注意，第一个参数应该是要柯里化的函数，所以args里面去掉第一个</span><br><span class="line">  var args = [].slice.call(arguments, 1)</span><br><span class="line">  var _func = function () &#123;</span><br><span class="line">    //参数长度为0，执行func函数，完成该函数的功能</span><br><span class="line">    if (arguments.length === 0) &#123;</span><br><span class="line">      return func.apply(this, args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //否则，存储参数到闭包中，返回本函数</span><br><span class="line">      Array.prototype.push.apply(args, arguments)</span><br><span class="line">      return _func</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return _func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add () &#123;</span><br><span class="line">  return Array.prototype.reduce.call(arguments, (a, b) =&gt; a + b)</span><br><span class="line">&#125;</span><br><span class="line">console.log(curry(add, 1, 2, 3)(1)(2)(3, 4, 5, 5)(5, 6, 6, 7, 8, 8)(1)(1)(1)()) // 69</span><br></pre></td></tr></table></figure></p>
<p>版本三：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curry (func) &#123;</span><br><span class="line">  // 函数的 length 属性能得到形参个数，而无法得知实参个数。</span><br><span class="line">  var argsTotalLength = func.length</span><br><span class="line">  return function curried () &#123;</span><br><span class="line">    var argsList = [].slice.call(arguments)</span><br><span class="line">    if (argsList.length &lt; argsTotalLength) &#123;</span><br><span class="line">      return function () &#123;</span><br><span class="line">        var argsNew = [].slice.call(arguments)</span><br><span class="line">        return curried.apply(this, argsList.concat(argsNew)) // 将新旧的参数拼接起来</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return func.apply(this, argsList)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6版</span><br><span class="line">function curry (func) &#123;</span><br><span class="line">  const argsTotalLength = func.length</span><br><span class="line">  const curried = (...argsList) =&gt; argsList.length &lt; argsTotalLength ?</span><br><span class="line">    (...argsNew) =&gt; curried(...argsList, ...argsNew) :</span><br><span class="line">    func(...argsList)</span><br><span class="line">  return curried</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo = function (a, b, c) &#123;</span><br><span class="line">  return console.log([a, b, c])</span><br><span class="line">&#125;</span><br><span class="line">var curried = curry(foo)</span><br><span class="line">curried(1)(2)(3) // =&gt; [1, 2, 3]</span><br><span class="line">curried(1, 2)(3) // =&gt; [1, 2, 3]</span><br><span class="line">curried(1, 2, 3) // =&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>这表明函数柯里化是一种预加载函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。从某种意义上来讲，这是一种对参数的缓存，是一种非常高效的编写函数的方法。  </p>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合的目的是将多个函数组合成一个函数。compose 会让函数从最后一个参数顺序执行到第一个参数，compose 的每个参数都是函数。<br>简单实现和用法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const compose = (...fns) =&gt; (...args) =&gt; fns.reduceRight((val, fn) =&gt; fn.apply(null, [].concat(val)), args)</span><br><span class="line">const f = x =&gt; x + 1</span><br><span class="line">const g = x =&gt; x * 2</span><br><span class="line">const t = (x, y) =&gt; x + y</span><br><span class="line"></span><br><span class="line">let fgt = compose(f, g, t)</span><br><span class="line">fgt(1, 2)// 3 -&gt; 6 -&gt; 7</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compose = function (f, g) &#123;</span><br><span class="line">  return function (x) &#123;</span><br><span class="line">    return f(g(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">var compose = (f, g) =&gt; (x) =&gt; f(g(x))</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">var compose = (...args) =&gt; x =&gt; args.reduceRight((value, func) =&gt; func(value), x)</span><br><span class="line"></span><br><span class="line">var toUpperCase = (x) =&gt; x.toUpperCase()</span><br><span class="line">var exclaim = (x) =&gt; x + &apos;!&apos;</span><br><span class="line">var shout = compose(exclaim, toUpperCase)</span><br><span class="line"></span><br><span class="line">shout(&quot;send in the clowns&quot;) //=&gt; &quot;SEND IN THE CLOWNS!&quot;</span><br></pre></td></tr></table></figure>
<p>与组合函数相比，完整流程函数不可拆解，出厂的时候已经设计好了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var shout = (x) =&gt; exclaim(toUpperCase(x))</span><br></pre></td></tr></table></figure></p>
<p>组合函数实现反转数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var head = x =&gt; x[0]</span><br><span class="line">var reverse = x =&gt; x.reduce((arr, x) =&gt; [x].concat(arr), [])</span><br><span class="line">var last = compose(head, reverse)</span><br><span class="line">last([&apos;jumpkick&apos;, &apos;roundhouse&apos;, &apos;uppercut&apos;]) // =&gt; &apos;uppercut&apos;</span><br></pre></td></tr></table></figure></p>
<p>代码从右往左执行，非常清晰明了，一目了然。我们定义的 compose 像 N 面胶一样，可以将任意多个纯函数结合到一起。这种灵活的组合可以让我们像拼积木一样来组合函数式的代码。  </p>
<p>结合律：<br>compose 其实是满足结合律的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compose(f, compose(g, t)) = compose(compose(f, g), t)  = f(g(t(x)))</span><br></pre></td></tr></table></figure></p>
<p>只要其顺序一致，最后的结果是一致的，因此，我们可以写个更高级的 compose，支持多个函数组合：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compose(f, g, t) =&gt; x =&gt; f(g(t(x))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var associative = compose(f, compose(g, h)) == compose(compose(f, g), h)  // true</span><br><span class="line"></span><br><span class="line">compose(toUpperCase, compose(head, reverse))</span><br><span class="line">// 或</span><br><span class="line">compose(compose(toUpperCase, head), reverse)</span><br></pre></td></tr></table></figure>
<p>结合律的好处是任何一个函数分组都可以被拆解开来，然后再以他们自己的组合打包在一起，组合成新的函数。  </p>
<p>下面用到了上面 compose 、head、reverse 函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var loudLastUpper = compose(exclaim, toUpperCase, head, reverse)</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">var last = compose(head, reverse)</span><br><span class="line">var loudLastUpper = compose(exclaim, toUpperCase, last)</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">var last = compose(head, reverse)</span><br><span class="line">var angry = compose(exclaim, toUpperCase)</span><br><span class="line">var loudLastUpper = compose(angry, last)</span><br><span class="line"></span><br><span class="line">// 更多变种...</span><br></pre></td></tr></table></figure></p>
<p>考虑一个小功能：将数组最后一个元素大写，假设 log, head，reverse，toUpperCase 函数存在（我们通过 curry 可以很容易写出来）<br>命令式的写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log(toUpperCase(head(reverse(arr))))</span><br></pre></td></tr></table></figure></p>
<p>面向对象的写法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr.reverse()</span><br><span class="line">  .head()</span><br><span class="line">  .toUpperCase()</span><br><span class="line">  .log()</span><br></pre></td></tr></table></figure></p>
<p>链式调用看起来顺眼多了，然而问题在于，原型链上可供我们链式调用的函数是有限的，而需求是无限的 ，这限制了我们的逻辑表现力。<br>再看看，现在通过组合，我们如何实现之前的功能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const upperLastItem = compose(log, toUpperCase, head, reverse)</span><br></pre></td></tr></table></figure></p>
<p>通过参数我们可以很清晰的看出发生了 uppderLastItem 做了什么，它完成了一套流水线，所有经过这条流水线的参数都会经历：reverse -&gt; head -&gt; toUpperCase -&gt; log 这些函数的加工，最后生成结果。<br><img src="http://cdn.luanzhuxian.com/blog/functional-programming_6.png" alt="avatar"><br>最完美的是，这些函数都是非常简单的纯函数，你可以随意组合，随意拿去用，不用有任何的顾忌。</p>
<h2 id="高阶函数（Higher-Order-Functions）"><a href="#高阶函数（Higher-Order-Functions）" class="headerlink" title="高阶函数（Higher-Order Functions）"></a>高阶函数（Higher-Order Functions）</h2><h3 id="函数作为返回值输出"><a href="#函数作为返回值输出" class="headerlink" title="函数作为返回值输出"></a>函数作为返回值输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isType(type) &#123;</span><br><span class="line">  return function(obj) &#123;</span><br><span class="line">    return Object.prototype.toString.call(obj) === `[object $&#123;type&#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isArray = isType(&apos;Array&apos;)</span><br><span class="line">const isString = isType(&apos;String&apos;)</span><br><span class="line">console.log(isArray([1, 2, [3,4]]) // true</span><br><span class="line">console.log(isString(&#123;&#125;)           // false</span><br></pre></td></tr></table></figure>
<p>实现 bind<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind = function (context) &#123;</span><br><span class="line">  let self = this,</span><br><span class="line">      args = Array.prototype.slice.call(arguments)</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">      return self.apply(context, args.slice(1));   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function flattenDepth (array, depth = 1) &#123;</span><br><span class="line">  let result = []</span><br><span class="line">  array.forEach(item =&gt; &#123;</span><br><span class="line">    let d = depth</span><br><span class="line">    if (Array.isArray(item) &amp;&amp; d &gt; 0) &#123;</span><br><span class="line">      result.push(...(flattenDepth(item, --d)))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(flattenDepth([1, [2, [3, [4]], 5]])) // [1, 2, [3, [4]], 5]</span><br><span class="line">console.log(flattenDepth([1, [2, [3, [4]], 5]], 2)) // [1, 2, 3, [4], 5]</span><br><span class="line">console.log(flattenDepth([1, [2, [3, [4]], 5]], 3)) // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>这里指定了 depth 作为扁平化的深度。  </p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>虽然函数早已返回而且已经在内存中执行垃圾回收。但是它的变量还是以某种方式保持存活。</p>
<h3 id="保存当前-this-的引用"><a href="#保存当前-this-的引用" class="headerlink" title="保存当前 this 的引用"></a>保存当前 this 的引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  constructor (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    let that = this</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(that.name)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conts bar = new Bar(&apos;bar&apos;)</span><br><span class="line">bar.getName() //  &apos;bar&apos;</span><br></pre></td></tr></table></figure>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>当持续触发事件时，debounce 会合并事件且不会去触发事件，当一段时间内没有再次触发这个事件时，才真正去触发事件。  </p>
<p>非立即执行版<br><img src="http://cdn.luanzhuxian.com/blog/debounce_1.png" alt="avatar"><br>非立即执行版是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func, wait) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>立即执行版<br><img src="http://cdn.luanzhuxian.com/blog/debounce_2.png" alt="avatar"><br>立即执行版是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const debounce = (func, wait) =&gt; &#123;</span><br><span class="line">  let timer</span><br><span class="line">  return function ()&#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line">    if (timer) cleatTimeout(timer)</span><br><span class="line">    let callNow = !timer</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      timer = null</span><br><span class="line">    &#125;,wait)</span><br><span class="line"></span><br><span class="line">    if(callNow) func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结合版<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @desc 函数防抖</span><br><span class="line">* @param func 函数</span><br><span class="line">* @param wait 延迟执行毫秒数</span><br><span class="line">* @param immediate true 表立即执行，false 表非立即执行</span><br><span class="line">*/</span><br><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line">  var timer</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line"></span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    if (immediate) &#123;</span><br><span class="line">      const callNow = !timer</span><br><span class="line">      timer = setTimeout(function()&#123;</span><br><span class="line">        timer = null</span><br><span class="line">      &#125;, wait)</span><br><span class="line">      if (callNow) func.apply(context, args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      timer = setTimeout(function()&#123;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>underscore 源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125; func        回调函数</span><br><span class="line"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> */</span><br><span class="line">_.debounce = function(func, wait, immediate) &#123;</span><br><span class="line">    var timeout, args, context, timestamp, result</span><br><span class="line"></span><br><span class="line">    var later = function() &#123;</span><br><span class="line">      // 现在和上一次时间戳比较</span><br><span class="line">      var last = _.now() - timestamp</span><br><span class="line">      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器</span><br><span class="line">      if (last &lt; wait &amp;&amp; last &gt;= 0) &#123;</span><br><span class="line">        timeout = setTimeout(later, wait - last)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 否则的话就是时间到了执行回调函数</span><br><span class="line">        timeout = null</span><br><span class="line">        if (!immediate) &#123;</span><br><span class="line">          result = func.apply(context, args)</span><br><span class="line">          if (!timeout) context = args = null</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">      context = this</span><br><span class="line">      args = arguments</span><br><span class="line">      // 获得时间戳</span><br><span class="line">      timestamp = _.now()</span><br><span class="line">      // 如果定时器不存在且立即执行函数</span><br><span class="line">      var callNow = immediate &amp;&amp; !timeout</span><br><span class="line">      // 如果定时器不存在就创建一个</span><br><span class="line">      if (!timeout) timeout = setTimeout(later, wait)</span><br><span class="line">      if (callNow) &#123;</span><br><span class="line">        // 如果需要立即执行函数的话 通过 apply 执行</span><br><span class="line">        result = func.apply(context, args)</span><br><span class="line">        context = args = null</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>throttle（节流），当持续触发事件时，保证隔间时间触发一次事件。<br>持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。  </p>
<p>时间戳版<br><img src="http://cdn.luanzhuxian.com/blog/throttle_1.png" alt="avatar"><br>在持续触发事件的过程中，函数会立即执行，并且每间隔时间执行一次。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const throttle = (func, wait) =&gt; &#123;</span><br><span class="line">  let pre = 0</span><br><span class="line">  return function()&#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line">    let now = Date.now()</span><br><span class="line">    if (now - pre &gt;= wait)&#123;</span><br><span class="line">       pre = Date.now()</span><br><span class="line">       func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定时器版<br><img src="http://cdn.luanzhuxian.com/blog/throttle_2.png" alt="avatar"><br>函数不会立即执行，并且每间隔时间执行一次，在停止触发事件后，函数会执行一次。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, wait) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function() &#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        timer = null</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>underscore 源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span><br><span class="line">*</span><br><span class="line">* @param  &#123;function&#125;   func      回调函数</span><br><span class="line">* @param  &#123;number&#125;     wait      表示时间窗口的间隔</span><br><span class="line">* @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span><br><span class="line">*                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span><br><span class="line">*                                两者不能共存，否则函数不能执行</span><br><span class="line">* @return &#123;function&#125;             返回客户调用函数   </span><br><span class="line">*/</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">  var context, args, result</span><br><span class="line">  var timeout = null</span><br><span class="line">  // 之前的时间戳</span><br><span class="line">  var previous = 0</span><br><span class="line">  // 如果 options 没传则设为空对象</span><br><span class="line">  if (!options) options = &#123;&#125;</span><br><span class="line">  // 定时器回调函数</span><br><span class="line">  var later = function() &#123;</span><br><span class="line">    // 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">    // 用于下面函数的第一个 if 判断</span><br><span class="line">    previous = options.leading === false ? 0 : _.now()</span><br><span class="line">    // 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">    timeout = null</span><br><span class="line">    result = func.apply(context, args)</span><br><span class="line">    if (!timeout) context = args = null</span><br><span class="line">  &#125;;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    // 获得当前时间戳</span><br><span class="line">    var now = _.now()</span><br><span class="line">    // 首次进入前者肯定为 true</span><br><span class="line">  // 如果需要第一次不执行函数</span><br><span class="line">  // 就将上次时间戳设为当前的</span><br><span class="line">    // 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">    if (!previous &amp;&amp; options.leading === false) previous = now</span><br><span class="line">    // 计算剩余时间</span><br><span class="line">    var remaining = wait - (now - previous)</span><br><span class="line">    context = this</span><br><span class="line">    args = arguments</span><br><span class="line">    // 如果当前调用已经大于上次调用时间 + wait</span><br><span class="line">    // 或者用户手动调了时间</span><br><span class="line">  // 如果设置了 trailing，只会进入这个条件</span><br><span class="line">  // 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">  // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span><br><span class="line">  // 其实还是会进入的，因为定时器的延时</span><br><span class="line">  // 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">  // 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">    if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">      // 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">      if (timeout) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = null</span><br><span class="line">      &#125;</span><br><span class="line">      previous = now</span><br><span class="line">      result = func.apply(context, args)</span><br><span class="line">      if (!timeout) context = args = null</span><br><span class="line">    &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">      // 判断是否设置了定时器和 trailing</span><br><span class="line">    // 没有的话就开启一个定时器</span><br><span class="line">      // 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">      timeout = setTimeout(later, remaining)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="节流搭配防抖"><a href="#节流搭配防抖" class="headerlink" title="节流搭配防抖"></a>节流搭配防抖</h3><p>间隔时间内，可以重新生成定时器；但只要delay的时间到了，必须要给用户一个响应。避免防抖事件无休止触发导致无法响应。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const throttle = (func, wait) =&gt; &#123;</span><br><span class="line">  let pre = 0</span><br><span class="line">  let timer = null</span><br><span class="line">  return function()&#123;</span><br><span class="line">    const context = this</span><br><span class="line">    const args = arguments</span><br><span class="line">    let now = Date.now()</span><br><span class="line">    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">    if (now - pre &lt; wait)&#123;</span><br><span class="line">      // 如果小于阈值，则设立一个新的定时器</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          pre = Date.now()</span><br><span class="line">          func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 否则，就不等了，无论如何要反馈给用户一次响应</span><br><span class="line">      pre = Date.now()</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;scroll&apos;, throttle(() =&gt; do something, 1000))</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以在日常工作中将函数式编程作为一种辅助手段，在条件允许的前提下，借鉴函数式编程中的思路，例如：</p>
<ul>
<li>多使用纯函数减少副作用的影响。</li>
<li>使用柯里化增加函数适用率。</li>
<li>使用 Pointfree 编程风格，减少无意义的中间变量，让代码更且可读性。</li>
<li>……</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的执行栈、执行上下文和作用域</title>
    <url>/post/767a45e1.html</url>
    <content><![CDATA[<h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。<br>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;  </span><br><span class="line">  console.log(&apos;Inside first function&apos;);  </span><br><span class="line">  second();  </span><br><span class="line">  console.log(&apos;Again inside first function&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;  </span><br><span class="line">  console.log(&apos;Inside second function&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();  </span><br><span class="line">console.log(&apos;Inside Global Execution Context&apos;);</span><br><span class="line"></span><br><span class="line">// Inside first function</span><br><span class="line">// Inside second function</span><br><span class="line">// Again inside first function</span><br><span class="line">// Inside Global Execution Context</span><br></pre></td></tr></table></figure></p>
<h1 id="执行上下文（execution-context）"><a href="#执行上下文（execution-context）" class="headerlink" title="执行上下文（execution context）"></a>执行上下文（execution context）</h1><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。帮助 JavaScript 引擎管理整个解析和运行代码的复杂过程。<br>执行上下文是在代码运行的时候确定的，是可以改变的。  </p>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>分为全局执行上下文和函数执行上下文。</p>
<h3 id="1-全局执行上下文"><a href="#1-全局执行上下文" class="headerlink" title="1. 全局执行上下文"></a>1. 全局执行上下文</h3><p>Javascript 引擎首次开始解析代码时创建。只有一个。<br>最初，这个全局上下文由一个全局对象和一个 this 变量组成。浏览器中的全局对象就是 window 对象，Node 环境中是 global 对象，this 指向这个全局对象。<br>即使没有任何代码，全局执行上下文中仍然有 window 和 this。这就是最基本的全局执行上下文：<br><img src="/images/dali.png" alt="avatar"><br>让我们看看添加了代码会怎么样：<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_2.png" alt="avatar"><br><img src="http://cdn.luanzhuxian.com/blog/execution-context_3.png" alt="avatar"><br>能看出上面两张图的区别吗？关键在于每个执行上下文有两个独立的阶段，一个是创建阶段，一个是执行阶段，每个阶段都有其各自职责。  </p>
<p>在全局执行上下文的创建阶段，Javascript 引擎会：</p>
<ol>
<li>创建一个全局对象；</li>
<li>创建 this 对象；</li>
<li>给变量和函数分配内存；</li>
<li>给变量赋默认值 undefined，把所有函数声明放进内存。  </li>
</ol>
<p>直到执行阶段，Javascript 引擎才会一行一行地运行你的代码并执行它们。  </p>
<h3 id="2-函数执行上下文"><a href="#2-函数执行上下文" class="headerlink" title="2. 函数执行上下文"></a>2. 函数执行上下文</h3><p><strong>只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</strong>。存在无数个。  </p>
<p>在函数执行上下文的创建阶段，Javascript 引擎会：</p>
<ol>
<li>创建一个 arguments 对象；</li>
<li>创建 this 对象；</li>
<li>给变量和函数分配内存；</li>
<li>给变量赋默认值 undefined，把所有函数声明放进内存。  </li>
</ol>
<p>让我们回过头看看之前的代码，但这次我们不仅仅定义 getUser，还要调用一次，看看实际效果是什么。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_4.gif" alt="avatar"><br>当调用了 getUser，就创建了新的执行上下文。在 getUser 执行上下文的创建阶段的创建阶段，Javascript 引擎创建了 this 对象和 arguments 对象。getUser 没有任何变量，所以 Javascript 引擎不需要再次分配内存或进行提升。  </p>
<p>你可能注意到了，当 getUser 函数执行完毕，它就从视图中消失了。事实上，Javascript 引擎创建了一个叫 执行栈（调用栈）的东西。每当函数被调用，就创建一个新的执行上下文并把它加入到调用栈；每当一个函数运行完毕，就被从调用栈中弹出来。因为 Javascript 是单线程的，每一个新的执行上下文都嵌套在另一个中，形成了调用栈。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_5.gif" alt="avatar"></p>
<p>我们来改写之前的代码，让函数拥有局部变量。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_6.gif" alt="avatar"><br>这里有几处重要细节需要注意。<br>首先，传入函数的所有参数都作为局部变量存在于该函数的执行上下文中。在例子中，handle 同时存在与全局执行上下文和 getURL 执行上下文中，因为我们把它传入了 getURL 函数做为参数。<br>其次，在函数中声明的变量存在于函数的执行上下文中。所以当我们创建 twitterURL，它就会存于 getURL 执行上下文中。这看起来显而易见，但却是<code>作用域</code>的基础。  </p>
<h3 id="3-Eval-函数执行上下文"><a href="#3-Eval-函数执行上下文" class="headerlink" title="3. Eval 函数执行上下文"></a>3. Eval 函数执行上下文</h3><p>指的是运行在 eval 函数中的代码，很少用而且不建议使用。<br><br></p>
<h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：创建阶段、执行阶段。</p>
<h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><blockquote bgcolor="#FF4500">JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</blockquote>

<p><br>先看看执行上下文包含的内容。An execution context has the following fields:<br>Environments: LexicalEnvironment and VariableEnvironment are what keep track of variables during runtime. Two references to environments. Both are usually the same.  </p>
<ul>
<li>LexicalEnvironment (lookup and change existing): resolve identifiers.（保存通过<code>let</code>、<code>const</code>、<code>with()</code>、<code>try-catch</code>创建的变量）</li>
<li>VariableEnvironment (add new): hold bindings made by variable declarations and function declarations.（保存通过<code>var</code>声明或<code>function(){}</code>声明的变量）</li>
<li>ThisBinding: the current value of this.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,     // 确定this</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,   // 词法环境</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,  // 变量环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-确定-this-的值（This-Binding）"><a href="#1-确定-this-的值（This-Binding）" class="headerlink" title="1. 确定 this 的值（This Binding）"></a>1. 确定 this 的值（This Binding）</h4><ul>
<li>全局执行上下文中，this 的值指向全局对象。</li>
<li>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定、new 绑定、箭头函数。  </li>
</ul>
<h4 id="2-创建词法环境（Lexical-Environment）"><a href="#2-创建词法环境（Lexical-Environment）" class="headerlink" title="2. 创建词法环境（Lexical Environment）"></a>2. 创建词法环境（Lexical Environment）</h4><blockquote bgcolor="#FF4500" style="margin-bottom: 30px"><strong>Lexical environments</strong> hold variables and parameters. The currently active environment is managed via a stack of execution contexts (which grows and shrinks in sync with the call stack). Nested scopes are handled by chaining environments: each environment points to its outer environment (whose scope surrounds its scope). In order to enable lexical scoping, functions remember the scope (=environment) they were defined in. When a function is invoked, a new environment is created for it’s arguments and local variables. That environment’s outer environment is the function’s scope. </blockquote>    

<p>在规范中作用域更官方的叫法是词法环境，词法环境是 JavaScript 作用域的内部实现机制。<br>词法环境有三种类型：</p>
<ul>
<li>全局环境（Global Environment）：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</li>
<li>函数环境（Function Environment）：用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code>对象。其外部环境可以是全局环境，也可以是包含内部函数的外部函数环境。  </li>
<li>模块环境（Module Environment）：每个模块有自己的词法环境，存储了包括<code>imports</code>在内的所有的<code>top-level declarations</code>。其外部环境引用为全局环境。  </li>
</ul>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_11.jpg" alt="avatar"></p>
<p><strong>Data Structures：A (lexical) environment is the following data structure</strong><br>每种词法环境由两部分组成：一个<code>Environment Record</code>，还有一个指向外层<code>Lexical Environment</code>的可空引用。</p>
<ul>
<li><strong>环境记录（Environment Record）：</strong>An environment record maps identifiers to value. that maps variable names to variable values. This is where JavaScript stores variables. One key-value entry in the environment record is called a binding. 存储变量、函数声明的实际位置。它包括3个子类：<ul>
<li><strong>Declarative Environment Record：</strong>store the effects of variable declarations, and function declarations.</li>
<li><strong>Object Environment Record：</strong>are used by the with statement and for the global environment. They turn an object into an environment. For with, that is the argument of the statement. For the global environment, that is the global object.</li>
<li><strong>Global Environment Record</strong></li>
</ul>
</li>
<li><strong>对外部环境的引用：</strong>A reference to the outer environment (null in the global environment) - the environment representing the outer scope of the scope represented by the current environment. 可以访问其外部词法环境。  </li>
</ul>
<p>其中<code>Declarative Environment Record</code>又有两个子类：<code>Function Environment Records</code>和<code>Module Environment Records</code>。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_12.jpg" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlobalExectionContext = &#123;     // 全局执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;    	  // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;   		// 环境记录</span><br><span class="line">      Type: &quot;Object&quot;,      		// 全局环境</span><br><span class="line">      outer: &lt;null&gt;  	   		  // 对外部环境的引用</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;      // 函数执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;  	       // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;  		   // 环境记录</span><br><span class="line">      Type: &quot;Declarative&quot;,  	   // 函数环境</span><br><span class="line">      outer: &lt;Global or outer function environment reference&gt;  // 对外部环境的引用</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-创建变量环境（Variable-Environment）"><a href="#3-创建变量环境（Variable-Environment）" class="headerlink" title="3. 创建变量环境（Variable Environment）"></a>3. 创建变量环境（Variable Environment）</h4><p>变量环境也是一个词法环境，variable environment is a certain type of lexical environment，因此它具有上面定义的词法环境的所有属性。<br>在 ES6 中，<code>词法环境</code>和<code>变量环境</code>的区别在于前者用于存储<code>函数声明和变量（let const）</code>绑定，而后者仅用于存储<code>变量（var）</code>绑定。</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = 20</span><br><span class="line">const b = 30</span><br><span class="line">var c</span><br><span class="line"></span><br><span class="line">function multiply(e, f) &#123;  </span><br><span class="line"> var g = 20</span><br><span class="line"> return e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(20, 30)</span><br></pre></td></tr></table></figure></p>
<p>执行上下文如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 全局执行上下文</span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  // 词法环境</span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 变量环境</span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      c: undefined</span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数执行上下文，函数被调用的时候才会被创建</span><br><span class="line">FunctionExectionContext = &#123;  </span><br><span class="line"></span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>此阶段，完成对所有变量的分配，最后执行代码。<br>如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。  </p>
<h3 id="LexicalEnvironment-和-VariableEnvironment-的区别"><a href="#LexicalEnvironment-和-VariableEnvironment-的区别" class="headerlink" title="LexicalEnvironment 和 VariableEnvironment 的区别"></a>LexicalEnvironment 和 VariableEnvironment 的区别</h3><p>Both are usually the same. The following explain situations where they diverge.  </p>
<p><strong>Handling temporary scopes via LexicalEnvironment and VariableEnvironment：</strong>  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_13.png" alt="avatar"><br>LexicalEnvironment and VariableEnvironment are always the same, except in one case: When there is a dominant outer scope and one temporarily wants to enter an inner scope. In the inner scope, a few new bindings should be accessible, but all new bindings made inside of it should be added to the outer scope. This is done as follows:</p>
<ul>
<li>LexicalEnvironment temporarily points to a new environment that has been put in front of the old LexicalEnvironment. The new environment holds the temporary bindings of the inner scope.</li>
<li>VariableEnvironment does not change its value and is thus still the same as the old LexicalEnvironment, denoting the outer scope. New bindings are added here and will also be found when doing a lookup via LexicalEnvironment, because the latter comes before the former in the environment chain.</li>
<li>After leaving the temporary scope, LexicalEnvironment’s old value is restored and it is again the same as VariableEnvironment.  </li>
</ul>
<p>These differences matter for with statements and catch clauses, which create temporary scopes. In both cases, the dominant scope is the surrounding function.</p>
<ul>
<li>with statement: the object that is the argument of the statement becomes a temporary environment.</li>
<li>catch clause: the exception that is the argument of this clause is made available via a temporary environment.  </li>
</ul>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function do_something() &#123;</span><br><span class="line">    let b = 2</span><br><span class="line">    var a = 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        var c = 3</span><br><span class="line">        let d = 4</span><br><span class="line">        console.log(b)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">do_something()</span><br></pre></td></tr></table></figure></p>
<p>当调用该方法时，创建了一个<code>ExecutionContext</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">    LexicalEnvironment:</span><br><span class="line">        b: &lt; uninitialized &gt;,</span><br><span class="line">        outer: VariableEnvironment</span><br><span class="line">    VariableEnvironment:</span><br><span class="line">        a: undefined,</span><br><span class="line">        c: undefined, // 变量提升</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>当今图<code>while循环</code>时创建了一个新的<code>LexicalEnvironment</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">    LexicalEnvironment:</span><br><span class="line">        d: &lt; uninitialized &gt;,</span><br><span class="line">        outer: &lt;LexicalEnvironment&gt;</span><br><span class="line">                b: 2</span><br><span class="line">                outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    VariableEnvironment:</span><br><span class="line">        a: 1,</span><br><span class="line">        c: undefined, // 变量提升</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>Now when we look up variables, we can always fall back on whatever is contained in outer.<br>当<code>while block</code>结束，我们恢复 <code>LexicalEnvironment</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">      LexicalEnvironment:</span><br><span class="line">          b: 2,</span><br><span class="line">          outer: GlobalLexicalEnvironment</span><br><span class="line">      VariableEnvironment:</span><br><span class="line">          a: 1,</span><br><span class="line">          c: 3,</span><br><span class="line">          outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>无法访问到 d 了。所以当<code>while</code>循环结束后，它的<code>execution context</code>被销毁。<br><br></p>
<h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p>
<h1 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h1><p>作用域指的是代码中特定变量的有效范围，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript采用静态作用域。代码写在哪里作用域就在哪里确定，函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。作用域确定了就不会再变化。  </p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>这就带来一个问题，要是当前执行上下文里没有要找的变量呢？Javascript 会就此罢手吗？下面的例子里有答案。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name=&apos;Tyler&apos;</span><br><span class="line">function logName() &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">logName()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_9.gif" alt="avatar"><br>如果 Javascript 引擎在函数执行上下文找不到匹配的局部变量，它会到最接近的父级上下文中查找。这条查找链会一直延伸到全局执行上下文。如果此时仍然找不到该变量，Javascript 引擎就会抛出一个引用错误。  </p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>之前我们了解到函数中创建的变量仅局部有效，一旦函数执行上下文从调用栈弹出，这些变量就访问不到了。<br>如果你在一个函数中嵌入了另一个函数，情况就变了。这种函数套函数的情况下，即使父级函数的执行上下文从调用栈弹出了，子级函数仍然能够访问父级函数的作用域。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count=0</span><br><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function inner(y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var add5 = makeAdder(5)</span><br><span class="line">count += add5(2) // 7</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_10.gif" alt="avatar"><br>注意，makeAdder 执行上下文从调用栈弹出后，创建了一个 Closure Scope（闭包作用域）。Closure Scope 中的变量环境和 makeAdder 执行上下文中的变量环境相同。这是因为我们在函数中嵌入了另一个函数。<br>在本例中，inner 函数嵌在 makeAdder 中，所以 inner 在 makeAdder 变量环境的基础上创建了一个闭包。因为闭包作用域的存在，即使 makeAdder 已经从调用栈弹出了，inner 仍然能够访问到 x 变量（通过作用域链）。</p>
<h1 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h1><p>函数的每次调用都有与之紧密相关的作用域和上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。 换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字的值， 它是拥有（控制）当前所执行代码的对象的引用。  </p>
<p>作用域只是一个“地盘”，一个区域，是在函数声明的时候就确定的一套变量访问规则，而执行上下文是函数执行时才产生的一系列变量的集合体。<br>在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中。<br><strong>作用域中没有变量，变量是通过作用域对应的执行上下文环境中的变量对象来实现的。也就是说作用域定义了执行上下文中的变量的访问规则，执行上下文是在这个作用域规则的前提下执行代码的。</strong>  </p>
<p>所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。有闭包存在时，一个作用域存在两个上下文环境也是有的。  </p>
<p>同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。  </p>
<p>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。  </p>
<h3 id="变量的查找规则："><a href="#变量的查找规则：" class="headerlink" title="变量的查找规则："></a>变量的查找规则：</h3><p>先从当前的执行上下文中找保存的作用域（对象），在当前作用域里面的 Environment Record（对应的执行上下文）中查找对应的属性, 如果有直接返回, 否则通过作用域链向上查找，顺着<code>__outer__</code>在上一级作用域的里面的 Environment Record 中查找对应的属性，直到全局作用域, 如果还找不到就抛出找不到的异常。  </p>
<p>这里有一个小测试。下面代码中，打印出来的 bar 将会是什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var bar = &apos;Declared in foo&apos;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(bar)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_7.gif" alt="avatar"><br>当我们调用了 foo，就在调用栈中新增了一个执行上下文。在其创建阶段，产生了 this、arguments，bar 被设为 undefined。<br>然后到了执行阶段，把字符串’Declare in foo’赋予 bar。到这里执行阶段就结束了，foo 执行上下文从调用栈弹出。<br>foo 弹出后，代码就运行到了打印 bar 到控制台的部分。此刻会报错：<code>Uncaught ReferenceError: bar is not defined</code>。这告诉我们，在函数中创建的变量，它的作用域是局部的。<strong>因为一旦函数的执行上下文从调用栈弹出，该函数中声明的变量就访问不到了。</strong>  </p>
<p>再看一个例子。代码执行完毕后控制台会打印出什么？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function first() &#123;</span><br><span class="line">  var name = &apos;Jordyn&apos;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;</span><br><span class="line">  var name = &apos;Jake&apos;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name)</span><br><span class="line"></span><br><span class="line">var name = &apos;Tyler&apos;</span><br><span class="line">first()</span><br><span class="line">second()</span><br><span class="line">console.log(name)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/execution-context_8.gif" alt="avatar"></p>
<p>控制台会依次打印出 undefined、Jordyn、Jake、Tyler。<br>因为每个新的执行上下文都有它自己的变量环境。就算另有其他执行上下文包含变量 name，Javascript 引擎仍会先从当前执行上下文里找起。  </p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 实现水平垂直居中的</title>
    <url>/post/d877f8a3.html</url>
    <content><![CDATA[<p>仅居中元素定宽高适用</p>
<ul>
<li>absolute + 负margin</li>
<li>absolute + margin auto</li>
<li>absolute + calc</li>
</ul>
<p>居中元素不定宽高</p>
<ul>
<li>absolute + transform</li>
<li>lineheight</li>
<li>writing-mode</li>
<li>table</li>
<li>css-table</li>
<li>flex</li>
<li>grid</li>
</ul>
<p>公共代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box size&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.wrapper &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">  background: green;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box.size &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="absolute-负-margin"><a href="#absolute-负-margin" class="headerlink" title="absolute + 负 margin"></a>absolute + 负 margin</h1><p>绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的边缘居中，但期望的效果是子元素的中心居中，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: absolute;;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  margin-left: -50px;</span><br><span class="line">  margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缺点是居中元素的宽高必须固定。  </p>
<h1 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin auto"></a>absolute + margin auto</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: absolute;;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点是居中元素的宽高必须固定。  </p>
<h1 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h1><p>css3 计算属性，减去宽高的一半。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: absolute;;</span><br><span class="line">  top: calc(50% - 50px);</span><br><span class="line">  left: calc(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缺点是居中元素的宽高必须固定。  </p>
<h1 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h1><p>css3 transform 的 translate 属性可以设置百分比，其是相对于自身的宽和高。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  position: absolute;;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定。  </p>
<h1 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h1><p>利用行内元素居中属性也可以做到水平垂直居中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  line-height: 300px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  line-height: initial;</span><br><span class="line">  text-align: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定。</p>
<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>tabel 单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td class=&quot;wrapper&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;box&quot;&gt;123&lt;/div&gt;</span><br><span class="line">      &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">.wrapper &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定，但 wrapper 需要设置宽度。缺点是代码冗余，而且也不是 table 的正确用法。  </p>
<h1 id="css-table"><a href="#css-table" class="headerlink" title="css-table"></a>css-table</h1><p>可以把普通元素，变为 table 元素的现实效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.wrapper &#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  text-align: center;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定，但 wrapper 需要设置宽度。</p>
<h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><p>可以把普通元素，变为 table 元素的现实效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定。</p>
<h1 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h1><p>可以把普通元素，变为 table 元素的现实效果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">  justify-self: center;</span><br><span class="line">  align-self: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>居中元素的宽高不用固定。兼容性不如flex。  </p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则</title>
    <url>/post/90871307.html</url>
    <content><![CDATA[<p>身份证号码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第二代身份证号码正则</span><br><span class="line">let isTrue = /^[1-9]\d&#123;5&#125;(18|19|20)\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d&#123;3&#125;[0-9Xx]$/</span><br><span class="line">// 第一代身份证正则表达式(15位)</span><br><span class="line">let isTrue=/^[1-9]\d&#123;7&#125;((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d&#123;3&#125;$/</span><br></pre></td></tr></table></figure></p>
<p>手机号号码：<br>时间截止为：2018年1月11日<br>移动号段：134 135 136 137 138 139 147 148 150 151 152 157 158 159 172 178 182 183 184 187 188 198<br>联通号段：130 131 132 145 146 155 156 166 171 175 176 185 186<br>电信号段：133 149 153 173 174 177 180 181 189 199<br>虚拟运营商：170<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue = /^(13[0-9]|14[5-9]|15[012356789]|166|17[0-8]|18[0-9]|19[8-9])[0-9]&#123;8&#125;$/</span><br></pre></td></tr></table></figure></p>
<p>固定电话：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue=(\(\d&#123;3,4&#125;\)|\d&#123;3,4&#125;-|\s)?\d&#123;8&#125;</span><br></pre></td></tr></table></figure></p>
<p>邮箱：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue =/^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]&#123;2,8&#125;)$/</span><br></pre></td></tr></table></figure></p>
<p>用户名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用户名正则，4到16位（字母，数字，下划线，减号）</span><br><span class="line">let isTrue = /^[a-zA-Z0-9_-]&#123;4,16&#125;$/</span><br></pre></td></tr></table></figure></p>
<p>密码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span><br><span class="line">let isTrue =^[a-zA-Z]\w&#123;5,17&#125;$</span><br><span class="line"></span><br><span class="line">// 最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</span><br><span class="line">let isTrue = /^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/</span><br></pre></td></tr></table></figure></p>
<p>特殊字符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue= /[&quot;&apos;&lt;&gt;%;)(&amp;+]+-!！@#$~/</span><br></pre></td></tr></table></figure></p>
<p>域名：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue=[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br></pre></td></tr></table></figure></p>
<p>邮政编码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let isTrue=[1-9]&#123;1&#125;(\d+)&#123;5&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Git rebase 变基</title>
    <url>/post/7e43902c.html</url>
    <content><![CDATA[<h1 id="合并和变基"><a href="#合并和变基" class="headerlink" title="合并和变基"></a>合并和变基</h1><p>在<code>Git</code>中整合来自不同分支的修改主要有两种方法：<code>merge</code>以及<code>rebase</code>。 </p>
<p>当两个不同分支，各自提交了更新，就会形成分叉： </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/merge-vs-reabse-1.png" alt="rebase"></p>
<p>整合分支最容易的方法是<code>merge</code>命令：把两个分支的最新快照<code>C3</code>和<code>C4</code>，以及二者最近的共同祖先<code>C2</code>进行三方合并，合并的结果是生成一个新的快照。 </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/merge-vs-reabse-2.png" alt="rebase"></p>
<p>还有一种方法叫做变基<code>rebase</code>：你可以提取在<code>C4</code>中引入的补丁和修改，然后在<code>C3</code>的基础上应用一次，将修改都移至<code>C3</code>上。  </p>
<p>我们先切换到<code>experiment</code>分支，再变基：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout experiment</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure></p>
<p>变基原理是，首先找到这两个分支的最近共同祖先<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底<code>C3</code>, 最后将存为临时文件的修改依序应用。<br>即将<code>C4</code>变基到<code>C3</code>，以<code>C3</code>为基础重新生成<code>C4</code>（注：此<code>C4</code>和<code>experiment</code>上的<code>C4</code>不一样，<code>commit id</code>不同）。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/merge-vs-reabse-3.png" alt="rebase"></p>
<p>之后切回<code>master</code>进行合并。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/merge-vs-reabse-4.png" alt="rebase"></p>
<p>这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。下面具体举例说明。  </p>
<h1 id="模拟日常开发-合并"><a href="#模拟日常开发-合并" class="headerlink" title="模拟日常开发 - 合并"></a>模拟日常开发 - 合并</h1><p>两个分支<code>master</code>和<code>dev</code>分别有了提交，现在要将<code>dev</code>合并到<code>master</code>上。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/start.png" alt="rebase"></p>
<p><strong>直接 git merge：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure></p>
<p>那么<code>git</code>会这么做：<br>1、找出<code>master</code>分支和<code>dev</code>分支的最近共同祖先<code>commit(357cb79)</code>。<br>2、将<code>master</code>最新一次<code>commit(e88ccad)</code>和<code>dev</code>最新一次<code>commit(05352ed)</code>合并后生成一个新的<code>commit(33d1a54)</code>，有冲突的话需要解决冲突。<br>3、将<code>master</code>和<code>dev</code>上，自<code>357cb79</code>之后的所有提交按照提交时间的先后顺序进行依次应用到<code>master</code>分支上。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/merge.png" alt="rebase">  </p>
<p><strong>git rebase 后再 git merge：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">$ git rebase master</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure></p>
<p>1、<code>rebase</code>之前需要经<code>master</code>分支拉到最新。<br>2、切换分支到需要<code>rebase</code>的分支，这里是<code>dev</code>分支。<br>3、执行<code>git rebase master</code>，有冲突就解决冲突，解决后直接<code>git add .</code>再<code>git rebase --continue</code>即可。可以发现并没有多出一次<code>commit</code>，且<code>master</code>上新增提交的<code>commit id</code>值已经变了。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/after-rebase-before-merge.png" alt="rebase"></p>
<p>4、切换到<code>master</code>分支，执行<code>git merge dev</code>，可以看到<code>HEAD</code>被置为<code>a73089d</code>。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/after-rebase-and-merge.png" alt="rebase"></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/after-rebase-and-merge-and-push.png" alt="rebase"></p>
<p>采用<code>rebase</code>的方式进行分支合并，<code>master</code>并没有多出一个新的<code>commit</code>，<code>dev</code>分支上的<code>commit</code>在<code>rebase</code>之后其<code>hash</code>值发生了变化，不再是<code>dev</code>分支上提交的时候的<code>hash</code>值了，但是提交的内容被全部复制保留了，并且整个<code>master</code>分支的<code>commit</code>记录呈线性记录。  </p>
<p><strong>总结：</strong><br><code>git merge</code>操作合并分支，会让两个分支的每次提交都按照提交时间（并不是<code>push</code>时间）排序，并且经过对比，会将两个分支的新增的<code>commit</code>合并成一个新的<code>commit</code>，最终的<code>master</code>分支树会分叉。  </p>
<p><code>git rebase</code>操作实际上是，将<code>dev</code>分支基于<code>master</code>之后的所有的<code>commit</code>打散成一个一个的<code>patch</code>，并重新生成新的<code>commit id</code>，再次基于<code>master</code>最新的<code>commit</code>上进行提交，并不依据两个分支上实际的每次提交的时间点排序，<code>rebase</code>完成后，切到<code>master</code>进行合并<code>dev</code>也不会生成一个新的<code>commit</code>，可以保持整个分支树的完美线性。  </p>
<p>无论是通过变基，还是通过合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。  </p>
<h1 id="模拟日常开发-代码提交"><a href="#模拟日常开发-代码提交" class="headerlink" title="模拟日常开发 - 代码提交"></a>模拟日常开发 - 代码提交</h1><p>平时提交代码，<code>commit</code>前没有<code>pull</code>其他人的提交，相当于远程仓库和本地的分支分叉了，因为<code>pull</code>相当于<code>fetch + merge</code>，所以此时拉取后会形成分支，此时对刚<code>pull</code>下来的分叉的<code>commit</code>进行<code>rebase</code>，会基于此<code>commit</code>，将之后的两个分叉的所有提交，重新生成一条新的提交线。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/pull-rebase-1.png" alt="rebase"></p>
<p>基于他人的提交变基，会将两边的新提交重新生成，生成一条直线。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/pull-rebase-2.png" alt="rebase"></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/pull-rebase-3.png" alt="rebase"></p>
<h1 id="模拟日常开发-合并多个-commit-为一个完整-commit"><a href="#模拟日常开发-合并多个-commit-为一个完整-commit" class="headerlink" title="模拟日常开发 - 合并多个 commit 为一个完整 commit"></a>模拟日常开发 - 合并多个 commit 为一个完整 commit</h1><p>当我们在本地仓库中提交了多次，在我们把本地提交<code>push</code>到公共仓库中前，为了让提交记录更简洁明了，我们希望把如下分支<code>B、C、D</code>三个提交记录合并为一个完整的提交，然后再<code>push</code>到公共仓库。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_1.png" alt="rebase"></p>
<p>现在我们在测试分支上添加了四次提交，我们的目标是把最后三个提交合并为一个提交：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_2.png" alt="rebase"></p>
<p>这里我们使用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i [startpoint] [endpoint]</span><br></pre></td></tr></table></figure></p>
<p>其中<code>-i</code>的意思是<code>--interactive</code>，即弹出交互式的界面让用户编辑完成合并操作，<code>[startpoint] [endpoint]</code>则指定了一个编辑区间，如果不指定 <code>[endpoint]</code>，则该区间的终点默认是当前分支<code>HEAD</code>所指向的<code>commit</code>（注：该区间指定的是一个前开后闭的区间）。  </p>
<p>在查看到了<code>log</code>日志后，我们运行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i 36224db</span><br><span class="line">或：</span><br><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure></p>
<p>然后我们会看到如下界面：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_3.png" alt="rebase"></p>
<p>上面注释的部分列出的是我们本次<code>rebase</code>操作包含的所有提交，下面注释部分是<code>git</code>为我们提供的命令说明。每一个<code>commit id</code>前面的<code>pick</code>表示指令类型，<code>git</code>为我们提供了以下几个命令：</p>
<ul>
<li>pick：保留该 commit</li>
<li>reword：保留该 commit，但我需要修改该 commit 的注释</li>
<li>edit：保留该 commit, 但我要停下来修改该提交(不仅仅修改注释)</li>
<li>squash：将该 commit 和前一个 commit 合并</li>
<li>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息</li>
<li>exec：执行 shell 命令</li>
<li>drop：我要丢弃该 commit  </li>
</ul>
<p>我们将<code>commit</code>内容编辑如下：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_4.png" alt="rebase"></p>
<p>然后是注释修改界面：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_5.png" alt="rebase"></p>
<p>编辑完保存即可完成<code>commit</code>的合并了。</p>
<h1 id="模拟日常开发-将某一段-commit-粘贴到另一个分支上"><a href="#模拟日常开发-将某一段-commit-粘贴到另一个分支上" class="headerlink" title="模拟日常开发 - 将某一段 commit 粘贴到另一个分支上"></a>模拟日常开发 - 将某一段 commit 粘贴到另一个分支上</h1><p>当我们项目中存在多个分支，有时候我们需要将某一个分支中的一段提交同时应用到其他分支中，就像下图：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_6.png" alt="rebase"></p>
<p>我们希望将<code>develop</code>分支中的<code>C~E</code>部分复制到<code>master</code>分支中，这时我们就可以通过<code>rebase</code>命令来实现。<br>在实际模拟中，我们创建了<code>master</code>和<code>develop</code>两个分支。  </p>
<p><code>master</code>分支：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_7.png" alt="rebase"></p>
<p><code>develop</code>分支：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_8.png" alt="rebase"></p>
<p>输入命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase [startpoint] [endpoint] --onto [branchName]</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>[startpoint] [endpoint]</code>仍然指定了一个前开后闭的编辑区间，<code>--onto</code>的意思是要将该指定的提交复制到哪个分支上。<br>所以，在找到<code>C(90bc0045b)</code>和<code>E(5de0da9f2)</code>的<code>commit id</code>后，我们输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase 90bc0045b^ 5de0da9f2 --onto master</span><br></pre></td></tr></table></figure>
<p>注：因为<code>[startpoint] [endpoint]</code>指定的是一个前开后闭的区间，为了让这个区间包含<code>C</code>，我们将区间起始点向后退了一步。    </p>
<p>运行完成后查看当前分支的日志：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_9.png" alt="rebase"></p>
<p>可以看到，<code>C~E</code>部分的提交内容已经复制到了<code>G</code>的后面了。<br>我们看一下当前分支的状态：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_10.png" alt="rebase"></p>
<p>当前<code>HEAD</code>处于游离状态，实际上，此时所有分支的状态应该是这样：  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_11.png" alt="rebase"></p>
<p>所以，<code>git</code>只是将<code>C~E</code>部分的提交内容复制一份粘贴到了<code>master</code>所指向的提交后面，我们需要做的就是将<code>master</code>所指向的<code>commit</code>设置为当前<code>HEAD</code>所指向的<code>commit</code>就可以了，即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git reset --hard  0c72e64</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-rebase/git-rebase_12.png" alt="rebase"></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>最后需要注意的是，不要通过<code>rebase</code>对任何已经提交到公共仓库中的<code>commit</code>进行变基修改，否则可能会丢弃了一些别人的所基于的提交。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 撤销与回滚</title>
    <url>/post/22c76f84.html</url>
    <content><![CDATA[<p>git 工作区（Working Directory）、暂存区（Stage）和历史记录区（History）的关系</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/1.jpg" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/2.png" alt="Git 撤销与回滚">  </p>
<p><br></p>
<h1 id="撤销工作区："><a href="#撤销工作区：" class="headerlink" title="撤销工作区："></a>撤销工作区：</h1><p>未添加到暂存区的撤销，还没有<code>git add</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use &apos;git checkout -- &lt;file&gt;...&apos; to discard changes in working directory</span><br></pre></td></tr></table></figure></p>
<p>一次性撤销多个文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;folder&gt;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h1 id="撤销暂存区："><a href="#撤销暂存区：" class="headerlink" title="撤销暂存区："></a>撤销暂存区：</h1><p><code>git add</code>添加到暂存区的，还没有<code>git commit</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage</span><br></pre></td></tr></table></figure></p>
<p>一次性将所有暂存区文件撤销：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure></p>
<p>举例：<br>新增<code>index.js</code>，并<code>git add</code>添加到暂存区：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with &apos;origin/dev&apos;.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &apos;git reset HEAD &lt;file&gt;...&apos; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   index.js</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &apos;git add &lt;file&gt;...&apos; to update what will be committed)</span><br><span class="line">(use &apos;git checkout -- &lt;file&gt;...&apos; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   index.js</span><br></pre></td></tr></table></figure></p>
<p>用<code>reset</code>撤销清空暂存区：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD index.js</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       index.js</span><br></pre></td></tr></table></figure></p>
<p>再查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with &apos;origin/dev&apos;.</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   index.js</span><br></pre></td></tr></table></figure></p>
<p>再用<code>git checkout</code>清空工作区，之后再查看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -- index.js</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with &apos;origin/dev&apos;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/3.png" alt="Git 撤销与回滚">  </p>
<p><br></p>
<h1 id="撤销历史区："><a href="#撤销历史区：" class="headerlink" title="撤销历史区："></a>撤销历史区：</h1><p>如果<code>commit</code>提交后想撤销，这就需要<code>revert</code>命令。<code>git revert</code>命令是撤销某次操作，此次操作之前和之后的<code>commit</code>和<code>history</code>都会保留，并且把这次撤销作为一次最新的提交。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert commit_id</span><br><span class="line">git revert HEAD 删除最后一次提交</span><br></pre></td></tr></table></figure></p>
<p>先提交修改然后再用<code>git log</code>查看提交记录。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/4.png" alt="Git 撤销与回滚">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 707ffbee6b5b2f7eb7ff42e0a12992aaab43140c (HEAD -&gt; dev, origin/dev)</span><br><span class="line">Author: lzx &lt;luanzhuxian@hotmail.com&gt;</span><br><span class="line">Date:   Tue Oct 27 09:19:54 2020 +0800</span><br><span class="line"></span><br><span class="line">    third commit on dev</span><br></pre></td></tr></table></figure>
<p>然后使用<code>git revert</code>后面跟上<code>git</code>提交的<code>commit_id</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert 707ffbee6b5b2f7eb7ff42e0a12992aaab43140c</span><br><span class="line"></span><br><span class="line">Revert &quot;third commit on dev&quot;</span><br><span class="line"></span><br><span class="line">This reverts commit 707ffbee6b5b2f7eb7ff42e0a12992aaab43140c.</span><br><span class="line"></span><br><span class="line"># Please enter the commit message for your changes. Lines starting</span><br><span class="line"># with &apos;#&apos; will be ignored, and an empty message aborts the commit.</span><br><span class="line">#</span><br><span class="line"># On branch dev</span><br><span class="line"># Your branch is up to date with &apos;origin/dev&apos;.</span><br><span class="line">#</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#       modified:   index.js</span><br></pre></td></tr></table></figure></p>
<p>修改后输入<code>esc</code>退出编辑模式，输入<code>:wq</code>保存编辑并退出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git revert 707ffbee6b5b2f7eb7ff42e0a12992aaab43140c</span><br><span class="line">[dev a137703] Revert &quot;third commit on dev&quot;</span><br><span class="line">1 file changed, 1 insertion(+), 3 deletions(-)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/5.png" alt="Git 撤销与回滚">  </p>
<p>之后再推送到远端更新远程仓库代码，修改的文件就撤销了。  </p>
<p>用 source tree 操作：</p>
<p>回滚提交：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/6.png" alt="Git 撤销与回滚">  </p>
<p>回滚生成新的提交：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/7.png" alt="Git 撤销与回滚">  </p>
<p>提交到远程仓库：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/8.png" alt="Git 撤销与回滚">  </p>
<p><br></p>
<h1 id="Git-Reset-三种模式："><a href="#Git-Reset-三种模式：" class="headerlink" title="Git Reset 三种模式："></a>Git Reset 三种模式：</h1><p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/9.png" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/10.png" alt="Git 撤销与回滚">  </p>
<p><strong>reset –soft commit_id：</strong><br>保留本地<code>working directory工作区</code>，并把重置<code>HEAD</code>所带来的新的差异放进本地<code>stage暂存区</code>。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/11.png" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/12.png" alt="Git 撤销与回滚">  </p>
<p><strong>reset –mixed commit_id：</strong><br>保留本地<code>working directory工作区</code>，并清空本地<code>stage</code>暂存区。<br>也就是说，工作目录的修改、暂存区的内容以及由<code>reset</code>所导致的新的文件差异，都会被放进工作目录。简而言之，就是把所有差异都混合<code>（mixed）</code>放在工作目录中。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/13.png" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/14.png" alt="Git 撤销与回滚">  </p>
<p><strong>reset –hard  commit_id：</strong><br>强制将本地<code>stage</code>暂存区和本地<code>working directory</code>工作区都同步到你指定的提交。<br>会在重置<code>HEAD</code>和<code>branch</code>的同时，重置<code>stage</code>区和<code>working directory</code>里的内容。你的暂存区和工作目录里的内容会被完全重置为和<code>HEAD</code>的新位置相同的内容。没有<code>commit</code>的修改会被全部擦掉。<br>可以回退到某次提交 A，A 之后的提交都会回滚，覆盖是不可逆的，谨慎使用。</p>
<p>重置前：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/15.png" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/16.png" alt="Git 撤销与回滚">  </p>
<p>重置后：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/17.png" alt="Git 撤销与回滚">  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/18.png" alt="Git 撤销与回滚">  </p>
<p>之后强行推送更新远程仓库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin dev -f</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:luanzhuxian/git-examples.git</span><br><span class="line">+ def670f...707ffbe dev -&gt; dev (forced update)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/19.png" alt="Git 撤销与回滚">  </p>
<p><code>reset</code>这个指令虽然可以用来撤销<code>commit</code>，但它的实质行为并不是撤销，而是移动<code>HEAD</code>，重置<code>HEAD</code>以及它所指向的<code>branch</code>的位置的。<br>而<code>reset --hard</code>之所以起到了撤销<code>commit</code>的效果，是因为它把<code>HEAD</code>和它所指向的<code>branch</code>一起移动到了当前<code>commit</code>的父<code>commit</code>上，从而起到了撤销的效果。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/git-reset-revert/20.webp" alt="Git 撤销与回滚">  </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的 this</title>
    <url>/post/5fc1eac8.html</url>
    <content><![CDATA[<h1 id="为什么要用-this"><a href="#为什么要用-this" class="headerlink" title="为什么要用 this"></a>为什么要用 this</h1><p>试想下面代码如果不使用 this 应该怎么写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var name = this.name</span><br><span class="line">  console.log(`Hello I am $&#123;name&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var me = &#123;</span><br><span class="line">  name: &apos;a&apos;,</span><br><span class="line">  speak: speak</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var you = &#123;</span><br><span class="line">  name: &apos;b&apos;,</span><br><span class="line">  speak: speak</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">me.speak()  //Hello I am a</span><br><span class="line">you.speak()  //Hello I am b</span><br></pre></td></tr></table></figure></p>
<p>this 可以在同一个执行环境中使用不同的上下文对象。它其实提供了一种更加优雅的方式来隐式传递一个对象引用，因此可以使 API 设计的更加简洁且易于复用。</p>
<h1 id="this-指向谁"><a href="#this-指向谁" class="headerlink" title="this 指向谁"></a>this 指向谁</h1><p>人们很容易把 this 理解成指向函数自身，其实 this 的指向在函数定义阶段是无法确定的，只有函数执行时才能确定 this 到底指向谁，实际上 this 的最终指向是调用它的那个对象。  </p>
<p><blockquote bgcolor="#FF4500">当一个函数被调用时，会创建一个活动记录（执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息，this 也是其中的一个属性。</blockquote><br>this 是运行时绑定的，所以取决于函数的执行上下文。确定 this 指向就是确定函数的执行上下文，也就是谁调用的它，有以下几种判断方式：</p>
<h2 id="独立函数调用（默认绑定）"><a href="#独立函数调用（默认绑定）" class="headerlink" title="独立函数调用（默认绑定）"></a>独立函数调用（默认绑定）</h2><p>这种直接调用的方式 this 指向全局对象，如果是在浏览器就指向 window。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 2</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  // 2</span><br></pre></td></tr></table></figure></p>
<p>for 循环中的<code>foo(i)</code>调用它的对象是 window，等价于<code>window.foo(i)</code>，因此函数 foo 里面的<code>this.count++</code>的 this 指向的是 window。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(num) &#123;</span><br><span class="line">  console.log(&quot;foo: &quot; + num)</span><br><span class="line">  this.count++  //记录foo被调用次数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = 0</span><br><span class="line">for (let i=0; i&lt;10; i++) &#123;</span><br><span class="line">  if (i &gt; 5) &#123;</span><br><span class="line">      foo(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo.count) // 0</span><br></pre></td></tr></table></figure></p>
<h2 id="对象上下文（隐式绑定）"><a href="#对象上下文（隐式绑定）" class="headerlink" title="对象上下文（隐式绑定）"></a>对象上下文（隐式绑定）</h2><p>foo 虽然被定义在全局作用域，但是调用的时候是通过 obj 上下文引用的，可以理解为在 foo 调用的那一刻它被 obj 对象拥有。所以 this 指向 obj。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() // 2</span><br></pre></td></tr></table></figure></p>
<p>这里有两个问题：</p>
<ol>
<li><p>链式调用：链式调用的情况下只有最后一层才会影响调用位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj1.obj2.obj3.fn() //这里的fn中的this指向obj3</span><br></pre></td></tr></table></figure>
</li>
<li><p>引式丢失</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = obj.foo</span><br><span class="line">var a = &quot;xxxxx&quot;</span><br><span class="line">bar() // xxxxx</span><br></pre></td></tr></table></figure>
<p>回调函数其实就是隐式丢失</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &quot;xxxxx&quot;</span><br><span class="line">setTimeout(obj.foo, 100) // xxxxx</span><br></pre></td></tr></table></figure>
<p>我们看到，回调函数虽然是通过 obj 引用的，但是 this 也不是 obj 了。其实内置的 setTimeout() 函数实现和下面的伪代码类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setTimeout(fn, delay) &#123;</span><br><span class="line">  //等待delay毫秒</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码隐藏这一个操作就是<code>fn = obj.foo</code>，这和上面例子中的<code>bar = obj.foo</code>异曲同工。</p>
</li>
</ol>
<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>显式绑定的说法是和隐式绑定相对的，指的是通过 call、apply、bind 显式地更改 this 指向。这三个方法第一个参数是 this 要指向的对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fruit() &#123;</span><br><span class="line">    console.log(this.name, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var apple = &#123;</span><br><span class="line">    name: &apos;苹果&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var banana = &#123;</span><br><span class="line">    name: &apos;香蕉&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fruit.call(banana, banana, apple)  // 香蕉 &#123; &apos;0&apos;: &#123; name: &apos;香蕉&apos; &#125;, &apos;1&apos;: &#123; name: &apos;苹果&apos; &#125; &#125;</span><br><span class="line">fruit.apply(apple, [banana, apple]) // 苹果 &#123; &apos;0&apos;: &#123; name: &apos;香蕉&apos; &#125;, &apos;1&apos;: &#123; name: &apos;苹果&apos; &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这三个方法中的 bind 方法比较特殊，它可以延迟方法的执行，这可以让我们写出更加灵活的代码。它的原理也很容易模拟：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  return this.a + something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fn 的 this 指向 obj</span><br><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return fn.apply(obj, arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123; a:2 &#125;</span><br><span class="line">var bar = bind(foo, obj)</span><br><span class="line">var b = bar(3) // 2 3</span><br><span class="line">console.log(b) // 5</span><br></pre></td></tr></table></figure></p>
<h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><p>js 中 new 与传统的面向类的语言机制不同，js 中的构造函数其实和普通函数没有任何区别。其实当我们使用 new 来调用函数的时候，发生了下列事情：</p>
<ul>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行原型链接</li>
<li>这个新对象会被绑定到调用的this</li>
<li>如果函数没有对象类型的返回值，这个对象会被返回  </li>
</ul>
<p>其中，第三步绑定了 this，所以构造函数和原型中的 this 永远指向 new 出来的实例。</p>
<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>箭头函数自身不绑定 this，箭头函数并非使用 function 关键字进行定义，也不会使用上面的 this 标准规范，而是<font color="red">继承外层作用域、函数调用中的 this 绑定</font>。由于箭头中的 this 的<font color="red">作用域继承自执行上下文</font>，因此 this 的值将在<font color="red">调用堆栈中查找</font>。  </p>
<ul>
<li>没有<code>this、super、arguments、new.target</code>绑定，由外围最近一层非箭头函数决定。  </li>
<li>不能通过new关键字调用<br>箭头函数没有<code>[[Construct]]</code>，所以不能用作构造函数</li>
<li>没有原型<br>因为不能通过 new 关键字调用，没有构造原型的需求，所以箭头函数不存在 prototype 属性</li>
<li><p>不可以改变 this 的绑定<br>执行<code>fruit.call(apple)</code>时，箭头函数 this 已被绑定，无法再次被修改：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fruit() &#123;</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var apple = &#123;</span><br><span class="line">  name: &apos;苹果&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var banana = &#123;</span><br><span class="line">  name: &apos;香蕉&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fruitCall = fruit.call(apple)</span><br><span class="line"></span><br><span class="line">fruitCall.call(banana) // 苹果</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数不适合用于对象方法和构造函数：箭头函数不适合作为对象方法，箭头函数的this不会指向此对象，而是外部非箭头函数作用域的this，箭头函数也不适合使用创建构造函数。当需要动态上下文，应该使用常规函数替代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 常规函数</span><br><span class="line">const car = &#123;</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line">  manufacturer: &apos;Ford&apos;,</span><br><span class="line">  fullName: function() &#123;</span><br><span class="line">    return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName() // Ford Fiesta</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const manufacturer = &apos;BMW&apos;</span><br><span class="line">const car = &#123;</span><br><span class="line">  model: &apos;Fiesta&apos;,</span><br><span class="line">  manufacturer: &apos;Ford&apos;,</span><br><span class="line">  fullName: () =&gt; &#123;</span><br><span class="line">    return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">car.fullName() // undefined &apos;BMW&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 常规函数</span><br><span class="line">const link = document.querySelector(&apos;#link&apos;)</span><br><span class="line">link.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  // this === link</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">const link = document.querySelector(&apos;#link&apos;)</span><br><span class="line">link.addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">  // this === window</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以这样绑定：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const link = document.querySelector(&apos;#link&apos;)</span><br><span class="line">link.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">  // this === link</span><br><span class="line">&#125;.bind(this))</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其实以前虽然没有箭头函数，我们也经常做和箭头函数一样效果的事情，比如说：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var self = this</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    console.log( self )</span><br><span class="line">  &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="getter-与-setter-中的-this"><a href="#getter-与-setter-中的-this" class="headerlink" title="getter 与 setter 中的 this"></a>getter 与 setter 中的 this</h2><p>getter 或 setter 函数都会把 this 绑定到设置或获取属性的对象上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  return this.a + this.b + this.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3,</span><br><span class="line">  get average() &#123;</span><br><span class="line">    return (this.a + this.b + this.c) / 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(o, &apos;sum&apos;, &#123; get: sum, enumerable: true, configurable: true&#125; )</span><br><span class="line">console.log(o.average, o.sum) // 2, 6</span><br></pre></td></tr></table></figure></p>
<h1 id="严格模式下的差异"><a href="#严格模式下的差异" class="headerlink" title="严格模式下的差异"></a>严格模式下的差异</h1><p>以上所说的都是在非严格模式下成立，严格模式下的 this 指向是有差异的。</p>
<ul>
<li>独立函数调用：this 指向 undefined</li>
<li>对象上的方法：this 永远指向该对象</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  b: 1,</span><br><span class="line">  length: 2,</span><br><span class="line">  test () &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    console.log(this.b)</span><br><span class="line">    console.log(this.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = a.test</span><br><span class="line">b() // window, undefined, 0</span><br><span class="line">a.test()  // &#123;b: 1, length: 2, test: ƒ&#125;, 1, 2</span><br><span class="line"></span><br><span class="line">// ES5中，顶层对象的属性等价于全局变量</span><br><span class="line">// ES6中，var、function声明的全局变量，依然是顶层对象的属性；let、const、class声明的全局变量不属于顶层对象的属性，也就是说ES6开始，全局变量和顶层对象的属性开始分离。</span><br><span class="line">var b = a.test</span><br><span class="line">b() // window, ƒ test () &#123;&#125;, 0</span><br><span class="line"></span><br><span class="line">let c = &#123;</span><br><span class="line">  b: 3,</span><br><span class="line">  length: 4,</span><br><span class="line">  test () &#123;</span><br><span class="line">    b()     // 直接调用 this 永远指向 window</span><br><span class="line">    a.test()</span><br><span class="line">    a.test.apply(arguments)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let d = c.test</span><br><span class="line">d()      // window, undefined, 0,</span><br><span class="line">            &#123; b: 1, length: 2, test: ƒ &#125;, 1, 2,</span><br><span class="line">            Arguments, undefined, 0</span><br><span class="line"></span><br><span class="line">c.test() // window, undefined, 0,</span><br><span class="line">            &#123; b: 1, length: 2, test: ƒ &#125;, 1, 2,</span><br><span class="line">            Arguments, undefined, 0</span><br><span class="line"></span><br><span class="line">c.test(1) // window, undefined, 0,</span><br><span class="line">             &#123; b: 1, length: 2, test: ƒ &#125;, 1, 2,</span><br><span class="line">             Arguments, undefined, 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function x() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const y = &#123;</span><br><span class="line">  name: &apos;y&apos;,</span><br><span class="line">  run () &#123;</span><br><span class="line">    x()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const z = &#123;</span><br><span class="line">  name: &apos;z&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y.run() //  window</span><br><span class="line"></span><br><span class="line">x.apply(z)  //  &#123;name: &quot;z&quot;&#125;</span><br><span class="line"></span><br><span class="line">z.run = x</span><br><span class="line">z.run()     //  &#123;name: &quot;z&quot;, run: ƒ&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 继承</title>
    <url>/post/623ca2f5.html</url>
    <content><![CDATA[<center>需要知道的知识点</center>

<h3 id="1-new-一个函数-和-Object-create-都发生了什么"><a href="#1-new-一个函数-和-Object-create-都发生了什么" class="headerlink" title="1. new 一个函数 和 Object.create 都发生了什么"></a>1. new 一个函数 和 Object.create 都发生了什么</h3><p>new 一个构造函数时相当于：</p>
<ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// new Father()</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;</span><br><span class="line">obj._proto_ = Father.prototype</span><br><span class="line">Father.call(obj)</span><br><span class="line">return obj</span><br></pre></td></tr></table></figure>
<p>Object.create() 创建一个新对象，其中第一个参数是对象的原型。本质上来说是对一个对象进行了浅拷贝：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.create = function (obj) &#123;</span><br><span class="line">  var F = function () &#123;&#125;</span><br><span class="line">  F.prototype = obj</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Object-create-：创建对象的新方式"><a href="#2-Object-create-：创建对象的新方式" class="headerlink" title="2. Object.create()：创建对象的新方式"></a>2. <a href="http://www.luanzhuxian.com/post/f92303d3.html">Object.create()：创建对象的新方式</a></h3><p><br></p>
<center>正文</center>

<h1 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">  this.name = &apos;father&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son() &#123;</span><br><span class="line">  this.name = &apos;son&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getName = function () &#123;</span><br><span class="line">  return this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = new Father()</span><br><span class="line"></span><br><span class="line">var son = new Son()</span><br><span class="line">console.log(son.getName()) // son</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>Son 的所有实例都指向<code>new Father()</code>返回的对象，即<code>son._proto_ === Son.prototype -&gt; Son.prototype._proto_ === Father.prototype</code>，原型链中引用类型的属性会被所有实例共享的，即所有实例对象使用的是同一份数据，会相互影响。</li>
<li>无法向父级构造函数传参。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">  this.arr = [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = new Father()</span><br><span class="line"></span><br><span class="line">var son1 = new Son()</span><br><span class="line">var son2 = new Son()</span><br><span class="line">son1.arr.push(4)</span><br><span class="line">console.log(son1.arr)  // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr)  // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<h1 id="二、构造函数继承"><a href="#二、构造函数继承" class="headerlink" title="二、构造函数继承"></a>二、构造函数继承</h1><p>在子级构造函数中调用父级构造函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father() &#123;</span><br><span class="line">    this.arr = [1,2,3]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function Son() &#123;</span><br><span class="line">  Father.call(this)</span><br><span class="line"></span><br><span class="line">  // 上面代码等同于下面这段代码：</span><br><span class="line">  (function() &#123;</span><br><span class="line">    this.arr = [1,2,3]</span><br><span class="line">  &#125;).call(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var son1 = new Son()</span><br><span class="line">var son2 = new Son()</span><br><span class="line">son1.arr.push(4)</span><br><span class="line">console.log(son1.arr)  // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr)  // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>缺点：<code>Father.call(this)</code>为每个实例复制一份私有属性，只能继承私有属性，无法继承父类原型上的属性方法。</p>
<h1 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h1><p>原型链 + 构造函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.arr = [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age) &#123;</span><br><span class="line">  Father.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = new Father()</span><br><span class="line">Son.prototype.constructor = Son</span><br><span class="line">Son.prototype.getAge = function () &#123;</span><br><span class="line">  console.log(this.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var son1 = new Son(&quot;a&quot;, 18)</span><br><span class="line">son1.getName()        // a</span><br><span class="line">son1.getAge()         // 18</span><br><span class="line"></span><br><span class="line">var son2 = new Son(&quot;b&quot;, 20)</span><br><span class="line">son2.getName()        // b</span><br><span class="line">son2.getAge()         // 20</span><br><span class="line"></span><br><span class="line">son1.arr.push(4)</span><br><span class="line">console.log(son1.arr) // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr) // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>缺点：父构造函数调用了两次，一次在创建子原型对象，另一次在子构造函数内部，复制两次私有属性。</p>
<h1 id="四、组合继承优化"><a href="#四、组合继承优化" class="headerlink" title="四、组合继承优化"></a>四、组合继承优化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.arr = [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age) &#123;</span><br><span class="line">  Father.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Father.prototype</span><br><span class="line">Son.prototype.constructor = Son</span><br><span class="line">Son.prototype.getAge = function () &#123;</span><br><span class="line">  console.log(this.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var son1 = new Son(&quot;a&quot;, 18)</span><br><span class="line">son1.getName()        // a</span><br><span class="line">son1.getAge()         // 18</span><br><span class="line"></span><br><span class="line">var son2 = new Son(&quot;b&quot;, 20)</span><br><span class="line">son2.getName()        // b</span><br><span class="line">son2.getAge()         // 20</span><br><span class="line"></span><br><span class="line">son1.arr.push(4)</span><br><span class="line">console.log(son1.arr) // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr) // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">console.log(Son.prototype.constructor) // Son</span><br><span class="line">console.log(Father.prototype.constructor) // Son</span><br></pre></td></tr></table></figure>
<p>缺点：父和子的<code>prototype</code>指向了同一个对象，修改子类构造器时，父类的构造器也同时被修改指向子构造函数，出现了紊乱。  </p>
<h1 id="四、寄生式继承"><a href="#四、寄生式继承" class="headerlink" title="四、寄生式继承"></a>四、寄生式继承</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//增强对象</span><br><span class="line">function create(obj, prop) &#123;</span><br><span class="line">  var object = Object.create(obj, prop)</span><br><span class="line">  object.getName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  return object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var father = &#123;</span><br><span class="line">  name: &quot;father&quot;,</span><br><span class="line">  arr: [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var son1 = create(father, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &quot;a&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var son2 = create(father, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">son1.getName()            // a</span><br><span class="line">son2.getName()            // b</span><br><span class="line">son1.arr.push(4)</span><br><span class="line">console.log(son1.arr)     // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr)     // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>引用类型的属性会被所有实例共享。</li>
<li>无法继承父类原型上的属性方法。  </li>
</ul>
<h1 id="五、寄生组合式继承"><a href="#五、寄生组合式继承" class="headerlink" title="五、寄生组合式继承"></a>五、寄生组合式继承</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Father(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.arr = [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.getName = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Son(name, age) &#123;</span><br><span class="line">  Father.call(this, name)</span><br><span class="line">  this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = Object.create(Father.prototype)</span><br><span class="line">Son.prototype.constructor = Son</span><br><span class="line"></span><br><span class="line">Son.prototype.getAge = function () &#123;</span><br><span class="line">  console.log(this.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var son1 = new Son(&quot;a&quot;, 18)</span><br><span class="line">son1.getName()            // a</span><br><span class="line">son1.getAge()             // 18</span><br><span class="line"></span><br><span class="line">var son2 = new Son(&quot;b&quot;, 20)</span><br><span class="line">son2.getName()            // b</span><br><span class="line">son2.getAge()             // 20</span><br><span class="line"></span><br><span class="line">son1.arr.push(4)          </span><br><span class="line">console.log(son1.arr)     // [1, 2, 3, 4]</span><br><span class="line">console.log(son2.arr)     // [1, 2, 3]</span><br><span class="line">console.log(Son.prototype.constructor) // Son</span><br><span class="line">console.log(Father.prototype.constructor) // Father</span><br></pre></td></tr></table></figure>
<p>根据文章开头得知，Object.create 时相当于 new 了一个空函数而不是 new Father()，所以不会重复调用父类的构造函数。而这个空函数又起到了连接创建的新对象（实例）和 Father.prototype 的作用，并把这个新对象返回，作为子类的<code>prototype</code>，所以最后子类的实例是可以沿原型链找到父类的，可以共享父类原型上的属性方法。也不会出现子类和父类共享一个原型对象的问题。</p>
<h1 id="六、ES6-extends-的实现"><a href="#六、ES6-extends-的实现" class="headerlink" title="六、ES6 extends 的实现"></a>六、ES6 extends 的实现</h1><p>es6<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">  name</span><br><span class="line">  constructor (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">  name,</span><br><span class="line">  age</span><br><span class="line">  constructor (name, age) &#123;</span><br><span class="line">    super(name)</span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    super.getName()</span><br><span class="line">  &#125;</span><br><span class="line">  getAge () &#123;</span><br><span class="line">    console.log(this.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转es5<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var __extends = (this &amp;&amp; this.__extends) || (function () &#123;</span><br><span class="line">    var extendStatics = function (d, b) &#123;</span><br><span class="line">        extendStatics = Object.setPrototypeOf ||</span><br><span class="line">            (&#123; __proto__: [] &#125; instanceof Array &amp;&amp; function (d, b) &#123; d.__proto__ = b; &#125;) ||</span><br><span class="line">            function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; &#125;;</span><br><span class="line">        return extendStatics(d, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    return function (d, b) &#123;</span><br><span class="line">        extendStatics(d, b);</span><br><span class="line">        function __() &#123; this.constructor = d; &#125;</span><br><span class="line">        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">var Father = (function () &#123;</span><br><span class="line">  function Father(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  Father.prototype.getName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return Father;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">var Son = (function (_super) &#123;</span><br><span class="line">  __extends(Son, _super);</span><br><span class="line">  function Son(name, age) &#123;</span><br><span class="line">    var _this = _super.call(this, name) || this;</span><br><span class="line">    _this.age = age;</span><br><span class="line">    return _this;</span><br><span class="line">  &#125;</span><br><span class="line">  Son.prototype.getName = function () &#123;</span><br><span class="line">    _super.prototype.getName.call(this);</span><br><span class="line">  &#125;;</span><br><span class="line">  Son.prototype.getAge = function () &#123;</span><br><span class="line">    console.log(this.age)</span><br><span class="line">  &#125;;</span><br><span class="line">  return Son;</span><br><span class="line">&#125;(Father));</span><br></pre></td></tr></table></figure></p>
<p>其中下面这部分就相当于<code>Son.prototype = Object.create(Father.prototype)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function __() &#123; this.constructor = d; &#125;</span><br><span class="line">d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 一些数组处理的应用</title>
    <url>/post/6e2a8c6e.html</url>
    <content><![CDATA[<h1 id="使用-filter、map-和其它-ES6-新增的高阶遍历函数"><a href="#使用-filter、map-和其它-ES6-新增的高阶遍历函数" class="headerlink" title="使用 filter、map 和其它 ES6 新增的高阶遍历函数"></a>使用 filter、map 和其它 ES6 新增的高阶遍历函数</h1><h2 id="将数组中的-falsy-值去除"><a href="#将数组中的-falsy-值去除" class="headerlink" title="将数组中的 falsy 值去除"></a>将数组中的 falsy 值去除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrContainsEmptyVal = [3, 4, 5, 2, 3, undefined, null, 0, &quot;&quot;]</span><br><span class="line">const compact = arr =&gt; arr.filter(Boolean)</span><br><span class="line">compact(arrContainsEmptyVal)</span><br></pre></td></tr></table></figure>
<h2 id="将数组中的-VIP-用户余额加-10"><a href="#将数组中的-VIP-用户余额加-10" class="headerlink" title="将数组中的 VIP 用户余额加 10"></a>将数组中的 VIP 用户余额加 10</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const users = [</span><br><span class="line">  &#123; username: &quot;Kelly&quot;, isVIP: true, balance: 20 &#125;,</span><br><span class="line">  &#123; username: &quot;Tom&quot;, isVIP: false, balance: 19 &#125;,</span><br><span class="line">  &#123; username: &quot;Stephanie&quot;, isVIP: true, balance: 30 &#125;</span><br><span class="line">]</span><br><span class="line">users.map(</span><br><span class="line">  user =&gt; (user.isVIP ? &#123; ...user, balance: user.balance + 10 &#125; : user)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="判断字符串中是否含有元音字母"><a href="#判断字符串中是否含有元音字母" class="headerlink" title="判断字符串中是否含有元音字母"></a>判断字符串中是否含有元音字母</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const randomStr = &quot;hdjrwqpi&quot;</span><br><span class="line">const isVowel = char =&gt; [&quot;a&quot;, &quot;e&quot;, &quot;o&quot;, &quot;i&quot;, &quot;u&quot;].includes(char)</span><br><span class="line">const containsVowel = str =&gt; [...str].some(isVowel)</span><br><span class="line"></span><br><span class="line">containsVowel(randomStr);</span><br></pre></td></tr></table></figure>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const uniq = arr =&gt; [...new Set(arr)]</span><br></pre></td></tr></table></figure>
<h1 id="reduce、reduceRight"><a href="#reduce、reduceRight" class="headerlink" title="reduce、reduceRight"></a>reduce、reduceRight</h1><p>reduce方法返回值是回调函数最后一次执行返回的累积结果。  </p>
<h2 id="不借助原生高阶函数，定义-reduce"><a href="#不借助原生高阶函数，定义-reduce" class="headerlink" title="不借助原生高阶函数，定义 reduce"></a>不借助原生高阶函数，定义 reduce</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reduce = (f, acc, arr) =&gt; &#123;</span><br><span class="line">  if (arr.length === 0) return acc</span><br><span class="line">  const [head, ...tail] = arr</span><br><span class="line">  return reduce(f, f(acc, head), tail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce((acc, currentValue) =&gt; acc + currentValue, 0, [1, 2, 3]) // =&gt; 6</span><br></pre></td></tr></table></figure>
<h2 id="使用-reduce-做到同时有-map-和-filter-的作用"><a href="#使用-reduce-做到同时有-map-和-filter-的作用" class="headerlink" title="使用 reduce 做到同时有 map 和 filter 的作用"></a>使用 reduce 做到同时有 map 和 filter 的作用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numbers = [10, 20, 30, 40]</span><br><span class="line">const doubledOver50 = numbers.reduce((finalList, num) =&gt; &#123;</span><br><span class="line">  num = num * 2 // double each number</span><br><span class="line">  if (num &gt; 50) &#123; // filter number &gt; 50</span><br><span class="line">    finalList.push(num)</span><br><span class="line">  &#125;</span><br><span class="line">  return finalList</span><br><span class="line">&#125;, [])</span><br><span class="line">doubledOver50 // [60, 80]</span><br></pre></td></tr></table></figure>
<h2 id="使用-reduce-代替-map"><a href="#使用-reduce-代替-map" class="headerlink" title="使用 reduce 代替 map"></a>使用 reduce 代替 map</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function map(arr, exec) &#123;</span><br><span class="line">    const res = arr.reduce((res, item, index) =&gt; &#123;</span><br><span class="line">        const newItem = exec(item, index)</span><br><span class="line">        res.push(newItem)</span><br><span class="line">        return res</span><br><span class="line">    &#125;, [])</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">const map = (f, arr) =&gt; arr.reduce((acc, val) =&gt; (acc.push(f(val)), acc), []);</span><br><span class="line"></span><br><span class="line">[1, 2, 3].map((item) =&gt; item * 2) // [2, 4, 6]</span><br><span class="line">map([1, 2, 3], item =&gt; item * 2) // [2, 4, 6]</span><br></pre></td></tr></table></figure>
<h2 id="使用-reduce-代替-filter"><a href="#使用-reduce-代替-filter" class="headerlink" title="使用 reduce 代替 filter"></a>使用 reduce 代替 filter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function filter(arr, exec) &#123;</span><br><span class="line">  var res = arr.reduce((res, item, index) =&gt; &#123;</span><br><span class="line">      if (exec(item, index)) &#123;</span><br><span class="line">          res.push(item)</span><br><span class="line">      &#125;</span><br><span class="line">      return res</span><br><span class="line">  &#125;, [])</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">const filter = (f, arr) =&gt;</span><br><span class="line">  arr.reduce((acc, val) =&gt; (f(val) &amp;&amp; acc.push(val), acc), []);</span><br><span class="line"></span><br><span class="line">[1, 2, 3].filter((item, index) =&gt; index &lt; 2) // [1, 2]</span><br><span class="line">filter([1, 2, 3], (item, index) =&gt; index &lt; 2) // [1, 2]</span><br></pre></td></tr></table></figure>
<h2 id="Transduce"><a href="#Transduce" class="headerlink" title="Transduce"></a>Transduce</h2><p>重新定义的 filter 和 map 有共有的逻辑。我们把这部分共有的逻辑叫做 reducer。有了共有的逻辑后，我们可以进一步地抽象，把 reducer 抽离出来，然后传入 filter 和 map：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const filter = f =&gt; reducer =&gt; (acc, value) =&gt; &#123;</span><br><span class="line">  if (f(value)) return reducer(acc, value)</span><br><span class="line">  return acc</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const map = f =&gt; reducer =&gt; (acc, value) =&gt; reducer(acc, f(value))</span><br><span class="line"></span><br><span class="line">const pushReducer = (acc, value) =&gt; (acc.push(value), acc)</span><br><span class="line"></span><br><span class="line">const pipe = (...fns) =&gt; (...args) =&gt; fns.reduce((fx, fy) =&gt; fy(fx), ...args)</span><br><span class="line"></span><br><span class="line">bigNum.reduce(</span><br><span class="line">  pipe(</span><br><span class="line">    filter(isEven),</span><br><span class="line">    map(triple)</span><br><span class="line">  )(pushReducer),</span><br><span class="line">  []</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="将多层数组转换成一层数组"><a href="#将多层数组转换成一层数组" class="headerlink" title="将多层数组转换成一层数组"></a>将多层数组转换成一层数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const nestedArr = [1, 2, [3, 4, [5, 6]]]</span><br><span class="line">const flatten = arr =&gt;</span><br><span class="line">  arr.reduce(</span><br><span class="line">    (flat, next) =&gt; flat.concat(Array.isArray(next) </span><br><span class="line">    ? flatten(next) </span><br><span class="line">    : next),</span><br><span class="line">    []</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="将下面数组转成对象，key-value-对应里层数组的两个值"><a href="#将下面数组转成对象，key-value-对应里层数组的两个值" class="headerlink" title="将下面数组转成对象，key/value 对应里层数组的两个值"></a>将下面数组转成对象，key/value 对应里层数组的两个值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const objLikeArr = [[&quot;name&quot;, &quot;Jim&quot;], [&quot;age&quot;, 18], [&quot;single&quot;, true]]</span><br><span class="line">const fromPairs = arr =&gt;</span><br><span class="line">  arr.reduce((res, subArr) =&gt; ((res[subArr[0]] = subArr[1]), res), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">fromPairs(objLikeArr) // &#123;name: &quot;Jim&quot;, age: 18, single: true&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取出对象中的深层属性"><a href="#取出对象中的深层属性" class="headerlink" title="取出对象中的深层属性"></a>取出对象中的深层属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const deepAttr = &#123; a: &#123; b: &#123; c: 15 &#125; &#125; &#125;</span><br><span class="line">const pluckDeep = path =&gt; obj =&gt;</span><br><span class="line">  path.split(&quot;.&quot;).reduce((val, attr) =&gt; val[attr], obj)</span><br><span class="line"></span><br><span class="line">pluckDeep(&quot;a.b.c&quot;)(deepAttr)  // 15</span><br></pre></td></tr></table></figure>
<h2 id="将用户中的男性和女性分别放到不同的数组里："><a href="#将用户中的男性和女性分别放到不同的数组里：" class="headerlink" title="将用户中的男性和女性分别放到不同的数组里："></a>将用户中的男性和女性分别放到不同的数组里：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const users = [</span><br><span class="line">  &#123; name: &quot;Adam&quot;, age: 30, sex: &quot;male&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Helen&quot;, age: 27, sex: &quot;female&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Amy&quot;, age: 25, sex: &quot;female&quot; &#125;,</span><br><span class="line">  &#123; name: &quot;Anthony&quot;, age: 23, sex: &quot;male&quot; &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const partition = (arr, isValid) =&gt;</span><br><span class="line">  arr.reduce(</span><br><span class="line">    ([pass, fail], elem) =&gt;</span><br><span class="line">      isValid(elem) ? [[...pass, elem], fail] : [pass, [...fail, elem]],</span><br><span class="line">    [[], []],</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">const isMale = person =&gt; person.sex === &quot;male&quot;</span><br><span class="line"></span><br><span class="line">const [maleUser, femaleUser] = partition(users, isMale)</span><br></pre></td></tr></table></figure>
<h2 id="使用-redece-来判断括号是否匹配"><a href="#使用-redece-来判断括号是否匹配" class="headerlink" title="使用 redece 来判断括号是否匹配"></a>使用 redece 来判断括号是否匹配</h2><p>这个例子说明 reduce 这个函数功能的强大。给你一串字符串，你想要知道这串字符串的括号是否是匹配。<br>常规的做法是使用栈来匹配，但是这里我们使用 reduce 就可以做到，我们只需要一个变量 counter ，这个变量的初始值是 0 , 当遇到<code>(</code>的时候，<code>counter++</code>当遇到<code>)</code>的时候，<code>counter--</code>。 如果括号是匹配的，那么这个 counter 最终的值是 0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Returns 0 if balanced.</span><br><span class="line">const isParensBalanced = (str) =&gt; &#123;</span><br><span class="line">  return str.split(&apos;&apos;).reduce((counter, char) =&gt; &#123;</span><br><span class="line">    if (counter &lt; 0) &#123; // matched &quot;)&quot; before &quot;(&quot;</span><br><span class="line">      return counter</span><br><span class="line">    &#125; else if (char === &apos;(&apos;) &#123;</span><br><span class="line">      return ++counter</span><br><span class="line">    &#125; else if (char === &apos;)&apos;) &#123;</span><br><span class="line">      return --counter</span><br><span class="line">    &#125; else &#123; // matched some other charreturn counter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 0) // starting value of the counter</span><br><span class="line">&#125;</span><br><span class="line">isParensBalanced(&apos;(())&apos;) // 0 &lt;-- balanced</span><br><span class="line">isParensBalanced(&apos;(asdfds)&apos;) //0 &lt;-- balanced</span><br><span class="line">isParensBalanced(&apos;(()&apos;) // 1 &lt;-- not balanced</span><br><span class="line">isParensBalanced(&apos;)(&apos;) // -1 &lt;-- not balanced</span><br></pre></td></tr></table></figure></p>
<h2 id="计算数组中元素出现的次数-将数组转为对象"><a href="#计算数组中元素出现的次数-将数组转为对象" class="headerlink" title="计算数组中元素出现的次数(将数组转为对象)"></a>计算数组中元素出现的次数(将数组转为对象)</h2><p>如果你想计算数组中元素出现的次数或者想把数组转为对象，那么你可以使用 reduce 来做到。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cars = [&apos;BMW&apos;,&apos;Benz&apos;, &apos;Benz&apos;, &apos;Tesla&apos;, &apos;BMW&apos;, &apos;Toyota&apos;]</span><br><span class="line">const carsObj = cars.reduce((obj, name) =&gt; &#123;</span><br><span class="line">  obj[name] = obj[name] ? ++obj[name] : 1</span><br><span class="line">  return obj</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line">carsObj // &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="用递归代替迭代"><a href="#用递归代替迭代" class="headerlink" title="用递归代替迭代"></a>用递归代替迭代</h1><h2 id="将两个数组每个元素一一对应相加"><a href="#将两个数组每个元素一一对应相加" class="headerlink" title="将两个数组每个元素一一对应相加"></a>将两个数组每个元素一一对应相加</h2><p>注意，第二个数组比第一个多出两个，不要把第二个数组遍历完。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const num1 = [3, 4, 5, 6, 7]</span><br><span class="line">const num2 = [43, 23, 5, 67, 87, 3, 6]</span><br><span class="line"></span><br><span class="line">const zipWith = f =&gt; xs =&gt; ys =&gt; &#123;</span><br><span class="line">  if (xs.length === 0 || ys.length === 0) return []</span><br><span class="line">  const [xHead, ...xTail] = xs</span><br><span class="line">  const [yHead, ...yTail] = ys</span><br><span class="line">  return [f(xHead)(yHead), ...zipWith(f)(xTail)(yTail)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const add = x =&gt; y =&gt; x + y</span><br><span class="line"></span><br><span class="line">zipWith(add)(num1)(num2)</span><br></pre></td></tr></table></figure></p>
<h2 id="将-Stark-家族成员提取出来"><a href="#将-Stark-家族成员提取出来" class="headerlink" title="将 Stark 家族成员提取出来"></a>将 Stark 家族成员提取出来</h2><p>注意，目标数据在数组前面，使用 filter 方法遍历整个数组是浪费。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const houses = [</span><br><span class="line">  &quot;Eddard Stark&quot;,</span><br><span class="line">  &quot;Catelyn Stark&quot;,</span><br><span class="line">  &quot;Rickard Stark&quot;,</span><br><span class="line">  &quot;Brandon Stark&quot;,</span><br><span class="line">  &quot;Rob Stark&quot;,</span><br><span class="line">  &quot;Sansa Stark&quot;,</span><br><span class="line">  &quot;Arya Stark&quot;,</span><br><span class="line">  &quot;Bran Stark&quot;,</span><br><span class="line">  &quot;Rickon Stark&quot;,</span><br><span class="line">  &quot;Lyanna Stark&quot;,</span><br><span class="line">  &quot;Tywin Lannister&quot;,</span><br><span class="line">  &quot;Cersei Lannister&quot;,</span><br><span class="line">  &quot;Jaime Lannister&quot;,</span><br><span class="line">  &quot;Tyrion Lannister&quot;,</span><br><span class="line">  &quot;Joffrey Baratheon&quot;</span><br><span class="line">]</span><br><span class="line">const takeWhile = f =&gt; ([head, ...tail]) =&gt;</span><br><span class="line">  f(head) ? (tail.length ? [head, ...takeWhile(f)(tail)] : [head]) : (tail.length ? [...takeWhile(f)(tail)] : [])</span><br><span class="line"></span><br><span class="line">const isStark = name =&gt; name.toLowerCase().includes(&quot;stark&quot;)</span><br><span class="line"></span><br><span class="line">takeWhile(isStark)(houses)</span><br></pre></td></tr></table></figure></p>
<h2 id="找出数组中的奇数，然后取出前4个"><a href="#找出数组中的奇数，然后取出前4个" class="headerlink" title="找出数组中的奇数，然后取出前4个"></a>找出数组中的奇数，然后取出前4个</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const numList = [1, 3, 11, 4, 2, 5, 6, 7]</span><br><span class="line">const takeFirst = (limit, f, arr) =&gt; &#123;</span><br><span class="line">  if (limit === 0 || arr.length === 0) return []</span><br><span class="line">  const [head, ...tail] = arr</span><br><span class="line">  return f(head)</span><br><span class="line">    ? [head, ...takeFirst(limit - 1, f, tail)]</span><br><span class="line">    : takeFirst(limit, f, tail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const isOdd = n =&gt; n % 2 === 1</span><br><span class="line"></span><br><span class="line">takeFirst(4, isOdd, numList)</span><br></pre></td></tr></table></figure>
<h1 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h1><h2 id="for-…-of-遍历自定义的-Iterable"><a href="#for-…-of-遍历自定义的-Iterable" class="headerlink" title="for … of 遍历自定义的 Iterable"></a>for … of 遍历自定义的 Iterable</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const starks = [</span><br><span class="line">  &quot;Eddard Stark&quot;,</span><br><span class="line">  &quot;Catelyn Stark&quot;,</span><br><span class="line">  &quot;Rickard Stark&quot;,</span><br><span class="line">  &quot;Brandon Stark&quot;,</span><br><span class="line">  &quot;Rob Stark&quot;,</span><br><span class="line">  &quot;Sansa Stark&quot;,</span><br><span class="line">  &quot;Arya Stark&quot;,</span><br><span class="line">  &quot;Bran Stark&quot;,</span><br><span class="line">  &quot;Rickon Stark&quot;,</span><br><span class="line">  &quot;Lyanna Stark&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">function* repeatedArr(arr) &#123;</span><br><span class="line">  let i = 0</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    yield arr[i++ % arr.length]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const infiniteNameList = repeatedArr(starks)</span><br><span class="line"></span><br><span class="line">const wait = ms =&gt;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, ms)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  for (const name of infiniteNameList) &#123;</span><br><span class="line">    await wait(1000)</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 的应用</title>
    <url>/post/b8aeaa25.html</url>
    <content><![CDATA[<h1 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h1><h2 id="移除不想要的属性"><a href="#移除不想要的属性" class="headerlink" title="移除不想要的属性"></a>移除不想要的属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 移除 _internal 和 tooBig 这两个属性</span><br><span class="line">let &#123;</span><br><span class="line">  _internal,</span><br><span class="line">  tooBig,</span><br><span class="line">  ...cleanObject</span><br><span class="line">&#125; = &#123;</span><br><span class="line">  _internal: &quot;secret&quot;,</span><br><span class="line">  tooBig: &#123;&#125;,</span><br><span class="line">  el1: &apos;1&apos;,</span><br><span class="line">  el2: &apos;2&apos;,</span><br><span class="line">  el3: &apos;3&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(cleanObject) // &#123; el1: &apos;1&apos;, el2: &apos;2&apos;, el3: &apos;3&apos; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  name: &apos;peter&apos;,</span><br><span class="line">  gender: &apos;male&apos;,</span><br><span class="line">  other: &#123;</span><br><span class="line">    age: &apos;28&apos;,</span><br><span class="line">    height: &apos;180&apos;,</span><br><span class="line">    weight: &apos;160&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; other: &#123; age, ...rest2 &#125;, ...rest1 &#125; = obj</span><br><span class="line">const person = &#123;</span><br><span class="line">  ...rest1,</span><br><span class="line">  ...rest2,</span><br><span class="line">  age: Number(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(rest1)  //  &#123; name: &apos;peter&apos;, gender: &apos;male&apos; &#125;</span><br><span class="line">console.log(rest2)  //  &#123; height: &apos;180&apos;, weight: &apos;160&apos; &#125;</span><br><span class="line">console.log(person)  //  &#123; name: &apos;peter&apos;, gender: &apos;male&apos;, height: &apos;180&apos;, weight: &apos;160&apos;, age: 28 &#125;</span><br></pre></td></tr></table></figure>
<h2 id="在函数参数中使用嵌套对象解构"><a href="#在函数参数中使用嵌套对象解构" class="headerlink" title="在函数参数中使用嵌套对象解构"></a>在函数参数中使用嵌套对象解构</h2><p>在这个例子中 engine 是一个嵌套在 car 里面的对象，如果我们只需要 engine 里面的属性 vin 我们可以这样做。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  model: &apos;bmw 2018&apos;,</span><br><span class="line">  engine: &#123;</span><br><span class="line">    v6: true,</span><br><span class="line">    turbo: true,</span><br><span class="line">    vin: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const modelAndVIN = (&#123; model, engine: &#123; vin &#125; &#125;) =&gt; &#123;</span><br><span class="line">  console.log(`model: $&#123;model&#125; vin: $&#123;vin&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modelAndVIN(car) // model: bmw 2018  vin: 12345</span><br></pre></td></tr></table></figure></p>
<h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>扩展运算符…<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let object1 = &#123; a:1, b:2,c:3 &#125;</span><br><span class="line">let object2 = &#123; b:30, c:40, d:50 &#125;</span><br><span class="line">let merged = &#123; …object1, …object2 &#125; //spread and re-add into merged</span><br></pre></td></tr></table></figure></p>
<h2 id="根据条件添加对象属性"><a href="#根据条件添加对象属性" class="headerlink" title="根据条件添加对象属性"></a>根据条件添加对象属性</h2><p>你不再需要根据条件创建两个不同的对象，以使其具有特定属性。扩展操作符将是一个完美的选择<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getUser = (emailIncluded) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    surname: &apos;Doe&apos;,</span><br><span class="line">    ...(emailIncluded ? &#123; email : &apos;john@doe.com&apos; &#125; : null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = getUser(true)</span><br><span class="line">console.log(user); // 输出 &#123; name: &quot;John&quot;, surname: &quot;Doe&quot;, email: &quot;john@doe.com&quot; &#125;</span><br><span class="line"></span><br><span class="line">const userWithoutEmail = getUser(false)</span><br><span class="line">console.log(userWithoutEmail) // 输出 &#123; name: &quot;John&quot;, surname: &quot;Doe&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="解构原始数据"><a href="#解构原始数据" class="headerlink" title="解构原始数据"></a>解构原始数据</h2><p>你曾经有处理过拥有非常多属性的对象吗？我相信你一定有过。可能最常见的情况是我们有一个用户对象，它包含了所有的数据和细节。这里，我们可以调用新的 ES 解构方法来处理这个大麻烦。让我们看看下面的例子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const rawUser = &#123;</span><br><span class="line">  name: &apos;John&apos;,</span><br><span class="line">  surname: &apos;Doe&apos;,</span><br><span class="line">  email: &apos;john@doe.com&apos;,</span><br><span class="line">  displayName: &apos;SuperCoolJohn&apos;,</span><br><span class="line">  joined: &apos;2016-05-05&apos;,</span><br><span class="line">  image: &apos;path-to-the-image&apos;,</span><br><span class="line">  followers: 45</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#123;&#125;, userDetails = &#123;&#125;;</span><br><span class="line">(&#123; name: user.name, surname: user.surname, ...userDetails &#125; = rawUser);</span><br><span class="line"></span><br><span class="line">console.log(user) // 输出 &#123; name: &quot;John&quot;, surname: &quot;Doe&quot; &#125;</span><br><span class="line">console.log(userDetails) // 输出 &#123; email: &quot;john@doe.com&quot;, displayName: &quot;SuperCoolJohn&quot;, joined: &quot;2016-05-05&quot;, image: &quot;path-to-the-image&quot;, followers: 45 &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并对象数组"><a href="#合并对象数组" class="headerlink" title="合并对象数组"></a>合并对象数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将对象数组合并成一个对象</span><br><span class="line">const cities = [</span><br><span class="line">  &#123; name: &apos;Paris&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Lyon&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Marseille&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Rome&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Milan&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Palermo&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Genoa&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Berlin&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Hamburg&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;New York&apos;, visited: &apos;yes&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const result = cities.reduce((accumulator, item) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...accumulator,</span><br><span class="line">    [item.name]: item.visited</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">console.log(result)</span><br><span class="line">/* 输出</span><br><span class="line">&#123;</span><br><span class="line">  Berlin: &quot;no&quot;</span><br><span class="line">  Genoa: &quot;yes&quot;</span><br><span class="line">  Hamburg: &quot;yes&quot;</span><br><span class="line">  Lyon: &quot;no&quot;</span><br><span class="line">  Marseille: &quot;yes&quot;</span><br><span class="line">  Milan: &quot;no&quot;</span><br><span class="line">  New York: &quot;yes&quot;</span><br><span class="line">  Palermo: &quot;yes&quot;</span><br><span class="line">  Paris: &quot;no&quot;</span><br><span class="line">  Rome: &quot;yes&quot;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="数组映射"><a href="#数组映射" class="headerlink" title="数组映射"></a>数组映射</h2><p>不使用 Array.map<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cities = [</span><br><span class="line">  &#123; name: &apos;Paris&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Lyon&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Marseille&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Rome&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Milan&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Palermo&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Genoa&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Berlin&apos;, visited: &apos;no&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;Hamburg&apos;, visited: &apos;yes&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;New York&apos;, visited: &apos;yes&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const cityNames = Array.from(cities, (&#123; name &#125;) =&gt; name)</span><br><span class="line">console.log(cityNames)  // 输出 [&quot;Paris&quot;, &quot;Lyon&quot;, &quot;Marseille&quot;, &quot;Rome&quot;, &quot;Milan&quot;, &quot;Palermo&quot;, &quot;Genoa&quot;, &quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;New York&quot;]</span><br></pre></td></tr></table></figure></p>
<h1 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h1><h2 id="交换2个值"><a href="#交换2个值" class="headerlink" title="交换2个值"></a>交换2个值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const [post, comments] = Promise.all([</span><br><span class="line">  fetch(&apos;/post&apos;),</span><br><span class="line">  fetch(&apos;/comments&apos;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="Set-使用-Array-的方法"><a href="#Set-使用-Array-的方法" class="headerlink" title="Set 使用 Array 的方法"></a>Set 使用 Array 的方法</h2><p>可以通过 (…) 扩展运算符将 Set 转换成 Array 这样我们就可以在 Set 使用所有 Array 的方法了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mySet = newSet([1,2, 3, 4, 5])</span><br><span class="line">const filtered = [...mySet].filter((x) =&gt; x &gt; 3) // [4, 5]</span><br></pre></td></tr></table></figure></p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="使用-set-来对数组去重"><a href="#使用-set-来对数组去重" class="headerlink" title="使用 set 来对数组去重"></a>使用 set 来对数组去重</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr = [1, 1, 2, 2, 3, 3]</span><br><span class="line">let deduped = [...new Set(arr)] // [1, 2, 3]</span><br><span class="line">let deduped = Array.from(new Set(arr))</span><br></pre></td></tr></table></figure>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="使用对象初始化-Map-实例"><a href="#使用对象初始化-Map-实例" class="headerlink" title="使用对象初始化 Map 实例"></a>使用对象初始化 Map 实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj = &#123; a: 1, b: 1, c: 1 &#125;</span><br><span class="line">map = new Map(Object.entries(obj))</span><br><span class="line">console.log(map.get(&apos;a&apos;)) // 1</span><br><span class="line">console.log(map.get(&apos;b&apos;))</span><br><span class="line">console.log(map.get(&apos;c&apos;))</span><br></pre></td></tr></table></figure>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>如果这样做的话：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string = `First</span><br><span class="line">                Second`</span><br></pre></td></tr></table></figure></p>
<p>那么它会创建出像下面的字符串：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">First</span><br><span class="line">                Second</span><br></pre></td></tr></table></figure></p>
<p>有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string = `</span><br><span class="line">First</span><br><span class="line">Second`.trim()</span><br></pre></td></tr></table></figure></p>
<h1 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h1><h2 id="Object-is-确定两个值是不是同一个"><a href="#Object-is-确定两个值是不是同一个" class="headerlink" title="Object.is() 确定两个值是不是同一个"></a>Object.is() 确定两个值是不是同一个</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(a, b)</span><br></pre></td></tr></table></figure>
<h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const hey = &apos;hey&apos;</span><br><span class="line">const arrayized = [...hey] // [&apos;h&apos;, &apos;e&apos;, &apos;y&apos;]</span><br></pre></td></tr></table></figure></p>
<h2 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h2><p>在之前的语法规范中，你只能通过<code>fn.apply(null, arr)</code>的方式来实现，但是这种方式不是很友好和易读。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [1, 3, 0, -1, 20, 100]</span><br><span class="line">Math.max.apply(null, arr) // 100</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5]</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">// 不定参</span><br><span class="line">fn(1, 2, 3, 4, 5) // Arguments(5) [0: 1, 1: 2, 2: 3, 3: 4, 4: 5]</span><br><span class="line">// 相当于：</span><br><span class="line">fn.apply(null, array)</span><br><span class="line">// 相当于：</span><br><span class="line">fn.call(null, 1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure>
<p>现在，剩余参数（rest element）在和数组解构（array destructuring）搭配使用来实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5]</span><br><span class="line">function fn(foo, bar, ...rest) &#123;</span><br><span class="line">  console.log(foo, bar, rest)</span><br><span class="line">  console.log(...arguments)</span><br><span class="line">&#125;</span><br><span class="line">fn(...array)  // 1, 2, [3, 4, 5]</span><br><span class="line">// 相当于：</span><br><span class="line">fn(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure></p>
<p>箭头函数没有 arguments</p>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>一个解释generator如何工作的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function *calculator(input) &#123;</span><br><span class="line">  var doubleThat = 2 * (yield (input / 2))</span><br><span class="line">  var another = yield (doubleThat)</span><br><span class="line">  return (input * doubleThat * another)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先初始化它：<code></code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const calc = calculator(10)</span><br></pre></td></tr></table></figure></p>
<p>然后我们在generator中开始进行iterator迭代：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc.next()</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">&#123;</span><br><span class="line">  done: false,</span><br><span class="line">  value: 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体过程如下：代码运行了函数，并把<code>input=10</code>传入到生成器构造函数中，该函数一直运行直到抵达 yield，并返回 yield 输出的内容: <code>input / 2 = 5</code>，因此，我们得到的值为5，并告知迭代器还没有 done (函数只是暂停了)。  </p>
<p>在第二个迭代处，我们输入7：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done: false</span><br><span class="line">  value: 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7被作为 doubleThat 的值，注意：你可能会把<code>input/2</code>作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2。<br>然后，我们得到第二个 yield 的值，它返回 doubleThat，因此返回值为14。  </p>
<p>之后，也是最后一个迭代器，我们输入100：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc.next(100)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">&#123;</span><br><span class="line">  done: true</span><br><span class="line">  value: 14000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当迭代器完成时(没有更多的 yield 关键字)，我们返回 input doubleThat another，这相当于<code>10 * 14 * 100</code>。</p>
<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p><a href="http://www.luanzhuxian.com/post/8aa98d9.html">Iterator</a>  </p>
<h1 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><h2 id="不使用-Apply-去调用函数"><a href="#不使用-Apply-去调用函数" class="headerlink" title="不使用 Apply 去调用函数"></a>不使用 Apply 去调用函数</h2><p>这一点我们叫它<code>Function.prototype.apply</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function doSomething (x, y, z) &#123;&#125;</span><br><span class="line">const args = [0, 1, 2]</span><br><span class="line">// 调用函数，传递参数</span><br><span class="line">doSomething.apply(null, args)</span><br></pre></td></tr></table></figure></p>
<p>通过扩展运算符我们可以避免使用<code>apply</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doSomething(...args)</span><br></pre></td></tr></table></figure></p>
<p>使代码更简洁</p>
<h2 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// es5</span><br><span class="line">Array.prototype.push.apply(arr1, arr2)</span><br><span class="line">arr1.concat(arr2)</span><br><span class="line"></span><br><span class="line">// es6</span><br><span class="line">arr1.push(...arr2)</span><br><span class="line">arr1.unshift(...arr2)</span><br><span class="line">arr = [...arr1, ...arr2]</span><br></pre></td></tr></table></figure>
<h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h2><p>浅拷贝，只复制指针，相当于<code>slice</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 = [1, 2, 3]</span><br><span class="line">let arr2 = [...arr1]</span><br></pre></td></tr></table></figure></p>
<h2 id="arguments-或-nodelist-转为数组"><a href="#arguments-或-nodelist-转为数组" class="headerlink" title="arguments 或 nodelist 转为数组"></a>arguments 或 nodelist 转为数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// es5</span><br><span class="line">Array.prototype.slice.call(NodeList)</span><br><span class="line"></span><br><span class="line">// es6</span><br><span class="line">Array.from(NodeList)</span><br><span class="line">[...document.querySelectorAll(&apos;div&apos;)]</span><br><span class="line"></span><br><span class="line">function (...args) &#123;</span><br><span class="line">  // args 等同于 let args = [...arguments]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Math-函数"><a href="#使用-Math-函数" class="headerlink" title="使用 Math 函数"></a>使用 Math 函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let numbers = [9, 4, 7, 1]</span><br><span class="line">Math.min(...numbers) // 1</span><br></pre></td></tr></table></figure>
<h1 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike[, mapFunction[, thisArg]])</span><br></pre></td></tr></table></figure>
<ul>
<li>arrayLike：必传参数，想要转换成数组的伪数组对象或可迭代对象。</li>
<li>mapFunction：可选参数，mapFunction(item，index){…} 是在集合中的每个项目上调用的函数。返回的值将插入到新集合中。</li>
<li>thisArg：可选参数，执行回调函数 mapFunction 时 this 对象。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将类数组的每一项乘以2</span><br><span class="line">const someNumbers = &#123; &apos;0&apos;: 10, &apos;1&apos;: 15, length: 2 &#125;</span><br><span class="line">Array.from(someNumbers, value =&gt; value * 2) // =&gt; [20, 30]</span><br></pre></td></tr></table></figure>
<p>应用：</p>
<ol>
<li>将类数组转换成数组</li>
<li><p>克隆数组（浅拷贝）<br>实现深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function recursiveClone(val) &#123;</span><br><span class="line">    return Array.isArray(val) ? Array.from(val, recursiveClone) : val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [[0, 1, 2], [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]]</span><br><span class="line">const numbersClone = recursiveClone(numbers)</span><br><span class="line"></span><br><span class="line">numbersClone // =&gt; [[0, 1, 2], [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]]</span><br><span class="line">numbers[0] === numbersClone[0] // =&gt; false</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充数组<br>使用相同的值来初始化数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const length = 3</span><br><span class="line">const init   = 0</span><br><span class="line"></span><br><span class="line">// ES5</span><br><span class="line">const result = Array(length).fill(init)</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">const result = Array.from(&#123; length &#125;, () =&gt; init)</span><br><span class="line"></span><br><span class="line">result // =&gt; [0, 0, 0]</span><br></pre></td></tr></table></figure>
<p>使用对象填充数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const length = 3</span><br><span class="line">const resultA = Array.from(&#123; length &#125;, () =&gt; (&#123;&#125;))</span><br><span class="line">const resultB = Array(length).fill(&#123;&#125;)</span><br><span class="line">const resultC = Array(length).map(() =&gt; init)</span><br><span class="line"></span><br><span class="line">resultA // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">resultB // =&gt; [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">resultC // =&gt; [undefined, undefined, undefined]</span><br><span class="line"></span><br><span class="line">resultA[0] === resultA[1] // =&gt; false</span><br><span class="line">resultB[0] === resultB[1] // =&gt; true</span><br></pre></td></tr></table></figure>
<p>这是因为 Array(length) 创建了一个有3个空项的数组。Array.from 的 () =&gt; ({}) 会返回一个新的对象。fill() 方法创建的 resultB 使用相同的空对象实例进行初始化。不会跳过空项。map() 方法会跳过空项。</p>
</li>
<li><p>生成数字范围</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 生成一个数组，从0到 end - 1</span><br><span class="line">function range(end) &#123;</span><br><span class="line">    return Array.from(&#123; length: end &#125;, (_, index) =&gt; index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range(4) // =&gt; [0, 1, 2, 3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组去重</p>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 杂记</title>
    <url>/post/48cd49dd.html</url>
    <content><![CDATA[<h1 id="vue-监听数组长度变化"><a href="#vue-监听数组长度变化" class="headerlink" title="vue 监听数组长度变化"></a>vue 监听数组长度变化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;body&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    list: []</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    length () &#123;</span><br><span class="line">      return this.list.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    list: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler (newValue, oldValue) &#123;</span><br><span class="line">        console.log(newValue.length)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="vue-监听对象变化"><a href="#vue-监听对象变化" class="headerlink" title="vue 监听对象变化"></a>vue 监听对象变化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;body&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    isEmpty () &#123;</span><br><span class="line">      return Object.keys(this.items).length === 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    items: &#123;</span><br><span class="line">      deep: true,</span><br><span class="line">      handler (newValue, oldValue) &#123;</span><br><span class="line">        this.isEmpty = Object.keys(newValue).length === 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>renderError<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    throw new Error(&apos;oops&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line">    return h(&apos;pre&apos;, &#123;</span><br><span class="line">      style: &#123; color: &apos;red&apos; &#125;</span><br><span class="line">    &#125;, err.stack)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>errorCaptured<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;error-boundary&apos;, &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&apos;,</span><br><span class="line">  errorCapture: (err, vm, info) =&gt; &#123;</span><br><span class="line">    console.log(&apos;We have an error&apos;)</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>errorHandler &amp; warnHandler<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.config.errHandler = function (err, vm, info) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    `Error: $&#123;err.toString()&#125;</span><br><span class="line">    info: $&#123;info&#125;`</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.config.warnHandler = function (msg, vm, trace) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    `Warn: $&#123;msg&#125;</span><br><span class="line">    Trace: $&#123;trace&#125;`</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>window.onerror<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onerror = function (msg, source, line, column, error) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="减少重复"><a href="#减少重复" class="headerlink" title="减少重复"></a>减少重复</h1><p>重复代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    internalValue: deepClone(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  value () &#123;</span><br><span class="line">    this.internalValue = deepClone(this.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>computed</code>减少重复：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  internalValue () &#123;</span><br><span class="line">    return this.value || this.value === 0</span><br><span class="line">      ? [].concat(this.value)</span><br><span class="line">      : []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重复代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  this.fetchUserList()</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  searchText () &#123;</span><br><span class="line">    this.fetchUserList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>immediate watcher</code>减少重复：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  searchText: &#123;</span><br><span class="line">    handler: &apos;fetchUserList&apos;,</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中的算法</title>
    <url>/post/d13db1cc.html</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>要真正掌握算法，就必须了解它们与数据结构的关系。数据结构和算法就像阴阳、水杯和水一样密不可分。没有杯子，水就不能被容纳。没有数据结构，我们就没有对象来应用逻辑。没有水，杯子是空的。没有算法，对象就不能被转换或消费。  </p>
<p>在 JavaScript 中，算法只是一个函数，它将某个确定的数据结构输入转换为某个确定的数据结构输出。函数内部的逻辑决定了怎么转换。首先，输入和输出应该清楚地提前定义。这需要我们充分理解手上的问题，因为对问题的全面分析可以很自然地提出解决方案，而不需要编写任何代码。  </p>
<p>一旦完全理解了问题，就可以开始对解决方案进行思考，需要那些变量？有几种循环？有那些 JavaScript 内置方法可以提供帮助？需要考虑那些边缘情况？复杂或者重复的逻辑会导致代码十分的难以阅读和理解，可以考虑能否提出抽象成多个函数？一个算法通常上需要可扩展的。随着输入 size 的增加，函数将如何执行? 是否应该有某种缓存机制吗? 通常上，需要牺牲内存优化（空间）来换取性能提升（时间）。  </p>
<p>在设计算法的结构和逻辑时，时间复杂度和空间复杂度的优化和权衡是一个重要的步骤。  </p>
<p>一个最优的算法通常上会利用语言里固有的标准对象实现。<br>可以说，在计算机科学中最重要的是数组。在 JavaScript 中，没有其他对象比数组拥有更多的实用方法。  </p>
<p>与数组 Array 密切相关的是使用循环遍历它们。在 JavaScript 中，有 5 种最常用的遍历方法，使用最多的是 for 循环，for 循环可以用任何顺序遍历数组的索引。如果无法确定迭代的次数，我们可以使用 while 和 do while 循环，直到满足某个条件。  </p>
<p>对于任何 Object, 我们可以使用 for in 和 for of 循环遍历它的 keys 和 values。为了同时获取 key 和 value 我们可以使用 entries()。  </p>
<p>我们也可以在任何时候使用 break 语句终止循环，或者使用 continue 语句跳出本次循环进入下一次循环。  </p>
<p>所有的递归函数都有相同的模式。它们由创建一个调用自身的递归部分和一个不调用自身的基本部分组成。任何时候一个函数调用它自身都会创建一个新的执行上下文并推入执行栈顶直。这种情况会一直持续到直到满足了基本情况为止。然后执行栈会一个接一个的将栈顶元素推出。因此，对递归的滥用可能导致堆栈溢出的错误。  </p>
<h1 id="常见算法题"><a href="#常见算法题" class="headerlink" title="常见算法题"></a>常见算法题</h1><h2 id="1-字符串反转"><a href="#1-字符串反转" class="headerlink" title="1. 字符串反转"></a>1. 字符串反转</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;String Reversal&quot;, () =&gt; &#123;</span><br><span class="line"> it(&quot;Should reverse string&quot;, () =&gt; &#123;</span><br><span class="line">   assert.equal(reverse(&quot;Hello World!&quot;), &quot;!dlroW olleH&quot;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>思考：<br>这道题的关键点是我们可以使用数组自带的 reverse 方法。首先我们使用 split 方法将字符串转为数组，然后使用 reverse 反转字符串，最后使用 join 方法转为字符串。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reverse = string =&gt; string.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br></pre></td></tr></table></figure></p>
<p>另外也可以使用数组的 reduce 方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const _reverse = string =&gt; string.split(&apos;&apos;).reduce((res, char) =&gt; char + res)</span><br></pre></td></tr></table></figure></p>
<h2 id="2-回文"><a href="#2-回文" class="headerlink" title="2. 回文"></a>2. 回文</h2><p>回文是一个单词或短语，它的读法是前后一致的。写一个函数来检查。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Palindrome&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should return true&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(isPalindrome(&quot;Cigar? Toss it in a can. It is so tragic&quot;), true)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(&quot;Should return false&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(isPalindrome(&quot;sit ad est love&quot;), false)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>函数只需要简单地判断输入的单词或短语反转之后是否和原输入相同，完全可以参考第一题的解决方案。我们可以使用数组的 every 方法检查第 i 个字符和第 <code>array.length - i</code> 个字符是否匹配。但是这个方法会使每个字符检查 2 次，这是没必要的。那么，我们可以使用 reduce 方法。和第 1 题一样，时间复杂度和空间复杂度是相同的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isPalindrome = string =&gt; &#123;</span><br><span class="line">  const validCharacters = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)</span><br><span class="line">  const stringCharacters = string // 过滤掉特殊符号</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .split(&quot;&quot;)</span><br><span class="line">        .reduce(</span><br><span class="line">          (characters, character) =&gt;</span><br><span class="line">            validCharacters.indexOf(character) &gt; -1</span><br><span class="line">              ? characters.concat(character)</span><br><span class="line">              : characters,</span><br><span class="line">          []</span><br><span class="line">        )</span><br><span class="line">  return stringCharacters.join(&quot;&quot;) === stringCharacters.reverse().join(&quot;&quot;) // 转变数据结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简略版<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isPalindrome (str) &#123;</span><br><span class="line">    let rev = str.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    return str === rev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>最长回文：</strong>一般方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function longestPalindrome (string) &#123;</span><br><span class="line">    let len = string.length</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = i; j &lt; len; j++) &#123;</span><br><span class="line">            let str = string.substring(i, j)</span><br><span class="line">            if (isPalindrome(str) &amp;&amp; str.length &gt; result.length) &#123;</span><br><span class="line">                result = str</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>最长回文：</strong>动态规划<br>上述一般方法包含很多重复计算，需要改进。我们发现对于<code>&#39;asdsa&#39;</code>，如果已知<code>&#39;sds&#39;</code>是回文，那么<code>&#39;asdsa&#39;</code>也是回文。<br>举例来说，我们用<code>P(i, j)</code>表示子串<code>Si~Sj</code>是否回文，如果是回文则<code>P(i, j)</code>为 true，否则为 false。那么上文就等同为<code>P(i, j) = (P(i + 1, j - 1) &amp;&amp; Si === Sj)</code>。<br>那么我们可以得到一个动态规划解法，首先初始化一字母和二字母的回文，再递增找到三字母的回文，以此类推…<br><code>P(i, j) = true</code>，<code>P(i, i + 1) = (Si === Si+1)</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function longestPalindrome  (string) &#123;</span><br><span class="line">    let len = string.length</span><br><span class="line">    let i, j, L       // L是i和j之间的间隔数（因为间隔数从小到大渐增，所以大的间隔数总能包含小的间隔数）</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    let matrix = Array(len).fill(0).map(x =&gt; Array(len).fill(0))  // 生成 len * len 矩阵</span><br><span class="line"></span><br><span class="line">    if (len &lt;= 1)&#123;</span><br><span class="line">        return string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化只有一个字符是回文的情况</span><br><span class="line">    for (i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        matrix[i][i] = 1</span><br><span class="line">        result = string[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // L从2开始，找出二字回文的情况，依次递增</span><br><span class="line">    // 例如 &apos;abcdcba&apos;.length = L，若首尾的 a 各为 i、j位，则 L = j - i + 1，所以 j = i + L - 1</span><br><span class="line">    for ( L = 2; L &lt;= len; L++) &#123;</span><br><span class="line">        // 从0开始，</span><br><span class="line">        for ( i = 0; i &lt;= len - L; i++) &#123;</span><br><span class="line">            // 根据当前的 i 和 L 得到 j</span><br><span class="line">            j = i + L - 1</span><br><span class="line">            if (L === 2 &amp;&amp; string[i] === string[j]) &#123;</span><br><span class="line">                matrix[i][j] = 1</span><br><span class="line">                result = string.slice(i, i + L)</span><br><span class="line">            &#125; else if (string[i] === string[j] &amp;&amp; matrix[i + 1][j - 1] === 1) &#123;</span><br><span class="line">                matrix[i][j] = 1</span><br><span class="line">                result = string.slice(i, i + L)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-整数反转"><a href="#3-整数反转" class="headerlink" title="3. 整数反转"></a>3. 整数反转</h2><p>给定一个整数，反转数字的顺序。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Integer Reversal&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should reverse integer&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(reverse(1234), 4321)</span><br><span class="line">    assert.equal(reverse(-1200), -21)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>把 number 类型使用 toString 方法换成字符串，然后就可以按照字符串反转的步骤来做。反转完成之后，使用 parseInt 方法转回 number 类型，然后使用 Math.sign 加入符号，只需一行代码便可完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const revserInteger = integer =&gt; parseInt(</span><br><span class="line">      number.toString()</span><br><span class="line">        .split(&apos;&apos;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&apos;&apos;)</span><br><span class="line">      ) * Math.sign(integer)</span><br></pre></td></tr></table></figure></p>
<h2 id="4-出现次数最多的字符"><a href="#4-出现次数最多的字符" class="headerlink" title="4. 出现次数最多的字符"></a>4. 出现次数最多的字符</h2><p>给定一个字符串，返回出现次数最多的字符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Max Character&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should return max character&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(max(&quot;Hello World!&quot;), &quot;l&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>可以创建一个对象，然后遍历字符串，字符串的每个字符作为对象的 key，value 是对应该字符出现的次数。然后我们可以遍历这个对象，找出 value 最大的 key。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const maxCharacter = (str) =&gt; &#123;</span><br><span class="line">  const obj = &#123;&#125;</span><br><span class="line">  let max = 0</span><br><span class="line">  let character = &apos;&apos;</span><br><span class="line">  for (let index in str) &#123;</span><br><span class="line">    obj[str[index]] = obj[str[index]] + 1 || 1</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i in obj) &#123;</span><br><span class="line">    if (obj[i] &gt; max) &#123;</span><br><span class="line">      max = obj[i]</span><br><span class="line">      character = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return character</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-字符串中连续出现次数最多的子串"><a href="#5-字符串中连续出现次数最多的子串" class="headerlink" title="5. 字符串中连续出现次数最多的子串"></a>5. 字符串中连续出现次数最多的子串</h2><p>方法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function maxStr (str) &#123;</span><br><span class="line">    let index = 0   // 指针</span><br><span class="line">    let counter = 0</span><br><span class="line">    let max = 0</span><br><span class="line">    let character</span><br><span class="line"></span><br><span class="line">    while (index &lt; str.length) &#123;</span><br><span class="line">        const current = str.charAt(index)</span><br><span class="line">        const next = str.charAt(index + 1)</span><br><span class="line">        if (!counter) &#123;</span><br><span class="line">            counter += 1</span><br><span class="line">        &#125;</span><br><span class="line">        if (current === next) &#123;</span><br><span class="line">            counter += 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (counter &gt; max) &#123;</span><br><span class="line">                max = counter</span><br><span class="line">                character = current</span><br><span class="line">            &#125;</span><br><span class="line">            counter = 0</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return character.repeat(max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function maxStr (str) &#123;</span><br><span class="line">    let index = 0   // 指针</span><br><span class="line">    let result = &apos;&apos;</span><br><span class="line">    let sub = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    while (index &lt; str.length) &#123;</span><br><span class="line">        const current = str.charAt(index)</span><br><span class="line">        const next = str.charAt(index + 1)</span><br><span class="line">        sub += current</span><br><span class="line">        if (current !== next) &#123;</span><br><span class="line">            if (sub.length &gt; result.length) &#123;</span><br><span class="line">                result = sub</span><br><span class="line">            &#125;</span><br><span class="line">            sub = &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-找出-string-中元音字母出现的个数"><a href="#6-找出-string-中元音字母出现的个数" class="headerlink" title="6. 找出 string 中元音字母出现的个数"></a>6. 找出 string 中元音字母出现的个数</h2><p>给定一个单词或者短语，统计出元音字母出现的次数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Vowels&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should count vowels&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(vowels(&quot;hello world&quot;), 3)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>最简单的解决办法是利用正则表达式提取所有的元音，然后统计。如果不允许使用正则表达式，我们可以简单的迭代每个字符并检查是否属于元音字母，首先应该把输入的参数转为小写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const vowels = str =&gt; &#123;</span><br><span class="line">   const choices = [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]</span><br><span class="line">   let count = 0</span><br><span class="line">   for (let character in str) &#123;</span><br><span class="line">     if (choices.includes(str[character])) &#123;</span><br><span class="line">       count ++</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return count</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> const vowelsRegs = str =&gt; &#123;</span><br><span class="line">   const match = str.match(/[aeiou]/gi)</span><br><span class="line">   return match ? match.length : 0</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-数组分隔"><a href="#7-数组分隔" class="headerlink" title="7. 数组分隔"></a>7. 数组分隔</h2><p>给定数组和大小，将数组项拆分为具有给定大小的数组列表。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Array Chunking&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should implement array chunking&quot;, () =&gt; &#123;</span><br><span class="line">    assert.deepEqual(chunk([1, 2, 3, 4], 2), [[1, 2], [3, 4]])</span><br><span class="line">    assert.deepEqual(chunk([1, 2, 3, 4], 3), [[1, 2, 3], [4]])</span><br><span class="line">    assert.deepEqual(chunk([1, 2, 3, 4], 5), [[1, 2, 3, 4]])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>一个好的解决方案是使用内置的 slice 方法。这样就能生成更干净的代码。可通过 while 循环或 for 循环来实现，它们按给定大小的步骤递增。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chunk = (array, size) =&gt; &#123;</span><br><span class="line">  const chunks = []</span><br><span class="line">  let index = 0</span><br><span class="line">   while (index &lt; array.length) &#123;</span><br><span class="line">     chunks.push(array.slice(index, index + size))</span><br><span class="line">     index += size</span><br><span class="line">   &#125;</span><br><span class="line">   return chunks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-words-反转"><a href="#8-words-反转" class="headerlink" title="8. words 反转"></a>8. words 反转</h2><p>给定一个短语，按照顺序反转每一个单词。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Reverse Words&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should reverse words&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(reverseWords(&quot;I love JavaScript!&quot;), &quot;I evol !tpircSavaJ&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>可以使用 split 方法创建单个单词数组。然后对于每一个单词，可以复用之前反转 string 的逻辑。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const reverseWords = string =&gt; string</span><br><span class="line">                                .split(&apos; &apos;)</span><br><span class="line">                                .map(word =&gt; word</span><br><span class="line">                                              .split(&apos;&apos;)</span><br><span class="line">                                              .reverse()</span><br><span class="line">                                              .join(&apos;&apos;)</span><br><span class="line">                                    ).join(&apos; &apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="9-首字母大写"><a href="#9-首字母大写" class="headerlink" title="9. 首字母大写"></a>9. 首字母大写</h2><p>给定一个短语，每个首字母变为大写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Capitalization&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should capitalize phrase&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(capitalize(&quot;hello world&quot;), &quot;Hello World&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>一种简洁的方法是将输入字符串拆分为单词数组。然后，我们可以循环遍历这个数组并将第一个字符大写，然后再将这些单词重新连接在一起。出于不变的相同原因，我们需要在内存中保存一个包含适当大写字母的临时数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const capitalize = str =&gt; &#123;</span><br><span class="line">  return str.split(&apos; &apos;).map(word =&gt; word[0].toUpperCase() + word.slice(1)).join(&apos; &apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-凯撒密码"><a href="#10-凯撒密码" class="headerlink" title="10. 凯撒密码"></a>10. 凯撒密码</h2><p>给定一个短语，通过在字母表中上下移动一个给定的整数来替换每个字符。如果有必要，这种转换应该回到字母表的开头或结尾。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Caesar Cipher&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should shift to the right&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, 100), &quot;E hkra FwrwOynelp!&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(&quot;Should shift to the left&quot;, () =&gt; &#123;</span><br><span class="line">    assert.equal(caesarCipher(&quot;I love JavaScript!&quot;, -100), &quot;M pszi NezeWgvmtx!&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>首先我们需要一个包含所有字母的数组，这意味着我们需要把给定的字符串转为小写，然后遍历整个字符串，给每个字符增加或减少给定的整数位置，最后判断大小写即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const caesarCipher = (str, number) =&gt; &#123;</span><br><span class="line">  const alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot;.split(&quot;&quot;)</span><br><span class="line">    const string = str.toLowerCase()</span><br><span class="line">    const remainder = number % 26</span><br><span class="line">    let outPut = &apos;&apos;</span><br><span class="line">    for (let i = 0; i &lt; string.length; i++) &#123;</span><br><span class="line">      const letter = string[i]</span><br><span class="line">      if (!alphabet.includes(letter)) &#123;</span><br><span class="line">        outPut += letter</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        let index = alphabet.indexOf(letter) + remainder</span><br><span class="line">        if (index &gt; 25) &#123;</span><br><span class="line">          index -= 26</span><br><span class="line">        &#125;</span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">          index += 26</span><br><span class="line">        &#125;</span><br><span class="line">        outPut += str[i] === str[i].toUpperCase() ? alphabet[index].toUpperCase() : alphabet[index]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return outPut</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-找出从-0-开始到给定整数的所有质数"><a href="#11-找出从-0-开始到给定整数的所有质数" class="headerlink" title="11. 找出从 0 开始到给定整数的所有质数"></a>11. 找出从 0 开始到给定整数的所有质数</h2><p>给定一个短语，通过在字母表中上下移动一个给定的整数来替换每个字符。如果有必要，这种转换应该回到字母表的开头或结尾。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">describe(&quot;Sieve of Eratosthenes&quot;, () =&gt; &#123;</span><br><span class="line">  it(&quot;Should return all prime numbers&quot;, () =&gt; &#123;</span><br><span class="line">    assert.deepEqual(primes(10), [2, 3, 5, 7])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>思考：<br>最简单的方法是我们循环从 0 开始到给定整数的每个整数，并创建一个方法检查它是否是质数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isPrime = n =&gt; &#123;</span><br><span class="line">  if (n &gt; 1 &amp;&amp; n &lt;= 3) &#123;</span><br><span class="line">    return true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for(let i = 2; i &lt;= Math.sqrt(n); i++)&#123;</span><br><span class="line">      if (n % i == 0) &#123;</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const prime = number =&gt; &#123;</span><br><span class="line">  const primes = []</span><br><span class="line">  for (let i = 2; i &lt; number; i++) &#123;</span><br><span class="line">    if (isPrime(i)) &#123;</span><br><span class="line">      primes.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return primes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="12-爬楼梯"><a href="#12-爬楼梯" class="headerlink" title="12. 爬楼梯"></a>12. 爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>爬楼梯其实属于动态规划一类。举例来说：倒着思考，当已经到达三层的时候，是怎样爬上来的？<br><code>f(3) = f(2) + f(1)</code>，即从第二阶走一步上来或者从第一阶走两步上来。<br>通过递推归纳：<code>f(n) = f(n-2) + f(n-1)</code>，从第 n-2 阶台阶走一步上来或者从第 n-1 阶台阶走两步上来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fibonacci(n) &#123;</span><br><span class="line">    var a = [0, 1, 2]</span><br><span class="line">    for (var i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = a[i-1] + a[i-2]</span><br><span class="line">    &#125;</span><br><span class="line">    return a[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="13-快速排序"><a href="#13-快速排序" class="headerlink" title="13. 快速排序"></a>13. 快速排序</h2><p>方法一：  </p>
<ol>
<li>在数据集之中，选择一个元素作为基准（pivot）。</li>
<li>所有小于基准的元素，都移到基准的左边；所有大于基准的元素，都移到基准的右边。</li>
<li>对基准左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort (arr) &#123;</span><br><span class="line"></span><br><span class="line">　　if (arr.length &lt;= 1) &#123; </span><br><span class="line">      return arr </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const pivotIndex = Math.floor(arr.length / 2)</span><br><span class="line">    const pivot = arr.splice(pivotIndex, 1)[0]</span><br><span class="line">    const left = []</span><br><span class="line">    const right = []</span><br><span class="line"></span><br><span class="line">　　for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">　　　　if (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i])</span><br><span class="line">　　　　&#125; else &#123;</span><br><span class="line">　　　　　　right.push(arr[i])</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　return quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方法二：</p>
<ol>
<li>首先，从数组中选择中间一项作为主元。</li>
<li>创建两个指针，左边一个指向数组第一项，右边一个指向数组最后一项。移动左指针直到找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交换它们，重复这个过程，直到左指针超过右指针。这个过程将使得比主元小的值都排在主元之前，比主元大的值都排在主元之后。这一部叫做划分操作。</li>
<li>接着，算法对划分后的小数组重复之前的两个步骤，直至数组已完全排序。  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function swap (array, index1, index2) &#123;</span><br><span class="line">  [array[index1], array[index2]] = [array[index2], array[index1]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 划分操作</span><br><span class="line">function partition (array, left, right) &#123;</span><br><span class="line">  const pivot = array[Math.floor((right + left) / 2)]</span><br><span class="line">  let i = left</span><br><span class="line">  let j = right</span><br><span class="line"></span><br><span class="line">  // 只要 left 和 right 没有交错，就执行划分 </span><br><span class="line">  while (i &lt; j) &#123;</span><br><span class="line">    while (array[i] &lt; pivot) &#123;  // 找到一个比主元大的元素</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    while (array[j] &gt; pivot) &#123;  // 找到一个比主元小的元素</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &lt;= j) &#123;</span><br><span class="line">      swap(array, i, j)</span><br><span class="line">      i++</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function quick (array, left, right) &#123;</span><br><span class="line">  let index</span><br><span class="line">  if (array.length &gt; 1) &#123;</span><br><span class="line">    index = partition(array, left, right)</span><br><span class="line"></span><br><span class="line">    // 存在较小子数组，对较小子数组快排</span><br><span class="line">    if (left &lt; index - 1) &#123;</span><br><span class="line">      quick(array, left, index - 1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存在较大子数组，对较大子数组快排</span><br><span class="line">    if (index &lt; right) &#123;</span><br><span class="line">      quick(array, index, right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function quickSort (array) &#123;</span><br><span class="line">  // 第一次快排整个数组</span><br><span class="line">  quick(array, 0, array.length - 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-Camel-和-Pascal-相互转换"><a href="#14-Camel-和-Pascal-相互转换" class="headerlink" title="14. Camel 和 Pascal 相互转换"></a>14. Camel 和 Pascal 相互转换</h2><p>糟糕的方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObject = input =&gt; Object.prototype.toString.call(input) === &apos;[object Object]&apos;</span><br><span class="line"></span><br><span class="line">const isArray = input =&gt; Object.prototype.toString.call(input) === &apos;[object Array]&apos;</span><br><span class="line"></span><br><span class="line">const convertKey = (&#123;key, type&#125;) =&gt; &#123;</span><br><span class="line">    let init = key.charAt(0)</span><br><span class="line">    init = (type === &apos;up&apos;) ? init.toUpperCase() : init.toLowerCase()</span><br><span class="line">    return init + key.substring(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const processArray = (arr, fn) =&gt; arr.reduce((acc, item) =&gt; &#123;</span><br><span class="line">    const _item = isObject(item) ? fn(item) : item</span><br><span class="line">    acc.push(_item)</span><br><span class="line">    return acc</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">const convert = (input, type, fn) =&gt; &#123;</span><br><span class="line">    if (!isObject(input)) &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const result = &#123;&#125;</span><br><span class="line">    const keys = Object.keys(input)</span><br><span class="line"></span><br><span class="line">    for (const key of keys) &#123;</span><br><span class="line">        const newKey = convertKey(&#123; key, type &#125;)</span><br><span class="line">        const val = input[key]</span><br><span class="line"></span><br><span class="line">        if (isArray(val)) &#123;</span><br><span class="line">            result[newKey] = processArray(val, fn)</span><br><span class="line">        &#125; else if (isObject(val)) &#123;</span><br><span class="line">            result[newKey] = fn(val)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result[newKey] = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const camelToPascal = (input) =&gt; convert(input, &apos;up&apos;, camelToPascal)</span><br><span class="line">const pascalToCamel = (input) =&gt; convert(input, &apos;low&apos;, pascalToCamel)</span><br><span class="line"></span><br><span class="line">const camelCasedData = &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: &quot;female&quot;,</span><br><span class="line">    experiences: [</span><br><span class="line">        &#123; from: &quot;2009-09&quot;, to: &quot;2013-06&quot;, exp: &quot;School&quot; &#125;,</span><br><span class="line">        &#123; from: &quot;2013-09&quot;, to: &quot;2020-02&quot;, exp: &quot;Job&quot; &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const pascalCasedData = camelToPascal(camelCasedData)</span><br><span class="line">console.log(pascalCasedData)</span><br><span class="line">const camelCasedData2 = pascalToCamel(pascalCasedData)</span><br><span class="line">console.log(camelCasedData2)</span><br></pre></td></tr></table></figure></p>
<p>用类实现，便于保存状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const isObject = input =&gt; Object.prototype.toString.call(input) === &apos;[object Object]&apos;</span><br><span class="line"></span><br><span class="line">class Convertor &#123;</span><br><span class="line">    constructor (keyConvertFn) &#123;</span><br><span class="line">        this.keyConvertFn = keyConvertFn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    convertKey (key) &#123;</span><br><span class="line">        const &#123; keyConvertFn &#125; = this</span><br><span class="line">        const initial = keyConvertFn.call(key.charAt(0))</span><br><span class="line">        return initial + key.substring(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    convert (source) &#123;</span><br><span class="line">        if (!isObject(source)) &#123;</span><br><span class="line">            return &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const result = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">        for (const key of Object.keys(source)) &#123;</span><br><span class="line">            const newKey = this.convertKey(key)</span><br><span class="line">            const value = source[key]</span><br><span class="line">    </span><br><span class="line">            if (Array.isArray(value)) &#123;</span><br><span class="line">                result[newKey] = value.map(item =&gt; isObject(item) ? this.convert(item) : item)</span><br><span class="line">            &#125; else if (isObject(value)) &#123;</span><br><span class="line">                result[newKey] = this.convert(value)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result[newKey] = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const camelToPascalConvertor = new Convertor(String.prototype.toUpperCase)</span><br><span class="line">const pascalToCamelConvertor = new Convertor(String.prototype.toLowerCase)</span><br><span class="line">const camelToPascal = (source) =&gt; camelToPascalConvertor.convert(source)</span><br><span class="line">const pascalToCamel = (source) =&gt; pascalToCamelConvertor.convert(source)</span><br><span class="line"></span><br><span class="line">const camelCasedData = &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    gender: &quot;female&quot;,</span><br><span class="line">    experiences: [</span><br><span class="line">        &#123; from: &quot;2009-09&quot;, to: &quot;2013-06&quot;, exp: &quot;School&quot; &#125;,</span><br><span class="line">        &#123; from: &quot;2013-09&quot;, to: &quot;2020-02&quot;, exp: &quot;Job&quot; &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const pascalCasedData = camelToPascal(camelCasedData)</span><br><span class="line">console.log(pascalCasedData)</span><br><span class="line">const camelCasedData2 = pascalToCamel(pascalCasedData)</span><br><span class="line">console.log(camelCasedData2)</span><br></pre></td></tr></table></figure></p>
<h2 id="15-数组转树"><a href="#15-数组转树" class="headerlink" title="15. 数组转树"></a>15. 数组转树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const locationList = [</span><br><span class="line">    &#123; id: 0, name: &quot;中国&quot; &#125;,</span><br><span class="line">    &#123; id: 1, pid: 0, name: &quot;广东省&quot; &#125;,</span><br><span class="line">    &#123; id: 2, pid: 1, name: &quot;深圳市&quot; &#125;,</span><br><span class="line">    &#123; id: 3, pid: 1, name: &quot;广州市&quot; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">function buildLocationTree (locationList) &#123;</span><br><span class="line"></span><br><span class="line">    const _findSubLocations = (location) =&gt; &#123;</span><br><span class="line">        const &#123; id &#125; = location</span><br><span class="line">        const list = locationList.filter((&#123;pid&#125;) =&gt; id === pid)</span><br><span class="line"></span><br><span class="line">        return list.length ? </span><br><span class="line">        &#123;</span><br><span class="line">            ...location,</span><br><span class="line">            subLocations: list.map(item =&gt; _findSubLocations(item))</span><br><span class="line">        &#125; :</span><br><span class="line">        location</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const root = locationList.find(item =&gt; !item.hasOwnProperty(&apos;pid&apos;))</span><br><span class="line">    const result = _findSubLocations(root)</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(buildLocationTree(locationList)))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 基本概念</title>
    <url>/post/44f8a53a.html</url>
    <content><![CDATA[<h1 id="data-为什么必须是函数？"><a href="#data-为什么必须是函数？" class="headerlink" title="data 为什么必须是函数？"></a>data 为什么必须是函数？</h1><p>要 return 一个新的 data 对象，否则修改其中一个会影响其他组件</p>
<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><ul>
<li>父子组件通信：$on、$emit、provide/inject</li>
<li>非父子组件的通信: event bus、</li>
<li>vuex</li>
</ul>
<h1 id="Vue-SSR-基本原理"><a href="#Vue-SSR-基本原理" class="headerlink" title="Vue SSR 基本原理"></a>Vue SSR 基本原理</h1><p>客户端 entry-client 主要作用挂载到 DOM 上，服务端 entry-server 除了创建和返回实例，还进行路由匹配与数据预获取。<br>webpack 打包客户端为 client-bundle，打包服务端为 server-bundle。<br>服务器接收请求，根据 url 来加载相应组件，然后生成 html 发送给客户端。<br>客户端 Vue 在浏览器端接管由服务端发送的静态 html，使其变为由 Vue 管理的动态 DOM，为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.INITIAL_STATE 发送到客户端。</p>
<h1 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h1><p>实现数据绑定的常见做法：</p>
<ul>
<li><code>Object.defineProperty</code>：劫持各个属性的setter，getter</li>
<li>发布/订阅模式：通过消息发布并将消息进行订阅</li>
<li>脏值检测：通过特定事件进行轮循  </li>
</ul>
<p>vue（vue 2.xx）采用的是<code>数据劫持</code>结合<code>发布者-订阅者模式</code>的方式，通过<code>Object.defineProperty</code>来实现对属性的劫持，并在数据变动时发布消息给订阅者，使其触发相应的监听回调。  </p>
<p>1、 实现 Observer<br>将需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。实现一个消息订阅器，维护一个数组，用来收集订阅者，数据变动触发 notify，再调用订阅者的 update 方法。  </p>
<p>2、 实现 Compiler<br>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。  </p>
<p>3、 实现 Watcher<br>Watcher 订阅者是 Observer 和 Compiler 之间通信的桥梁。<br>主要做的事情是：</p>
<ul>
<li>在自身实例化时往属性订阅器 dep 里面添加自己</li>
<li>自身必须有一个 update 方法</li>
<li>待属性变动 dep.notice 通知时，能调用自身的 update 方法，并触发 Compiler 中绑定的回调  </li>
</ul>
<p>4、 实现 MVVM<br>MVVM 作为数据绑定的入口，整合 Observer、Compiler 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compiler 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compiler 之间的通信桥梁，达到<code>数据变化 -&gt; 视图更新</code>；<code>视图交互变化(input) -&gt; 数据model变更</code>的双向绑定效果  </p>
<h1 id="Vue-的-template-编译"><a href="#Vue-的-template-编译" class="headerlink" title="Vue 的 template 编译"></a>Vue 的 template 编译</h1><p>template 会被编译成 AST 语法树，AST 会经过 generate 得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点。  </p>
<ul>
<li>parse 过程，将 template 利用正则转化成 AST 抽象语法树</li>
<li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能</li>
<li>generate 过程，生成 render 字符串  </li>
</ul>
<h1 id="Vue-为什么采用-Virtual-DOM"><a href="#Vue-为什么采用-Virtual-DOM" class="headerlink" title="Vue 为什么采用 Virtual DOM"></a>Vue 为什么采用 Virtual DOM</h1><p>一方面是出于性能方面的考量：</p>
<ul>
<li>创建真实 DOM 的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。</li>
<li>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流  </li>
</ul>
<p>但是性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好不是一个容易下定论的问题。更重要的原因是为了解耦 HTML 依赖，这带来两个非常重要的好处是：</p>
<ul>
<li>不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li>
<li>可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex 等框架应用的就是这一特性。  </li>
</ul>
<p>综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 隐式类型转换</title>
    <url>/post/45f33cfa.html</url>
    <content><![CDATA[<h1 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h1><h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(mix)</span><br><span class="line">parseInt(string, radix)</span><br><span class="line">parseFloat(string)</span><br><span class="line">toString(radix)</span><br><span class="line">String(mix)</span><br><span class="line">Boolean()</span><br><span class="line">toFixed(radix)</span><br></pre></td></tr></table></figure>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isNaN</span><br><span class="line">++/-- +/-</span><br><span class="line">+           // +&apos;&apos; === 0</span><br><span class="line">* /%</span><br><span class="line">&amp;&amp; || !</span><br><span class="line">&lt; &gt; &lt;= &gt;=</span><br><span class="line">== !=</span><br></pre></td></tr></table></figure>
<p>以上前五个会调用显式类型里面的 Number()，后两个会调用显式类型的 Boolean()。</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof 返回的六种数据类型：<code>number、string、boolean、object、undefined、function</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof &apos;1&apos; // &quot;string&quot;</span><br><span class="line">typeof 2 // &quot;number&quot;</span><br><span class="line">typeof null // &quot;object&quot;</span><br><span class="line">typeof undefined // &quot;undefined&quot;</span><br><span class="line">typeof [] // &quot;object&quot;</span><br><span class="line">typeof Array // &quot;function&quot; 构造函数</span><br><span class="line">typeof NaN // &quot;number&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a>isNaN</h2><p>isNaN() 会首先尝试将这个参数转换为数值，会隐式调用 Number()，然后才会对转换后的结果是否是 NaN 进行判断，如果是 NaN 则返回 true，否则返回 false。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isNaN(1) // false</span><br><span class="line">isNaN(&apos;2&apos;) // false</span><br><span class="line">isNaN(null) // false, 因为Number(null)为0</span><br><span class="line">isNaN(undefined) // true, 因为Number(undefined)为NaN</span><br><span class="line">isNaN(NaN) // true</span><br></pre></td></tr></table></figure></p>
<h2 id="抽象比较算法"><a href="#抽象比较算法" class="headerlink" title="抽象比较算法"></a>抽象比较算法</h2><p><img src="http://cdn.luanzhuxian.com/blog/type-conversion_1.png" alt="avatar"><br>在执行<code>抽象比较算法</code>的过程中，会发现会将 x、y 操作数进行隐式类型转化的，这也是 == 运算符副作用的体现。</p>
<h2 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h2><p><img src="http://cdn.luanzhuxian.com/blog/type-conversion_2.png" alt="avatar"><br>toPrimitive 方法的目的就是将输入的参数转化成<code>非对象类型</code>。</p>
<h2 id="DefaultValue-处理过程："><a href="#DefaultValue-处理过程：" class="headerlink" title="DefaultValue 处理过程："></a>DefaultValue 处理过程：</h2><p><img src="http://cdn.luanzhuxian.com/blog/type-conversion_3.png" alt="avatar"><br>先解读一下这个算法：  </p>
<ul>
<li>如果期望类型 hint 为字符串，那么，先调用被操作对象的 toString 方法，会在原型链中查找，如果找到且是一个可以调用的的方法的话，则将被操作对象作为 this 调用这个方法。否则如果得到值为原始值，则直接返回。如果没有得到原始值，则再调用 valueOf 方法，过程和 toString 一样，最终如果都不是原始值，则抛出异常。</li>
<li>如果期望类型为数字类型，则先调用 valueOf 后调用 toString。</li>
<li>如果没有明确知道期望类型的话，除非是 Data 类型默认为字符串。其他对象默认为数字处理，也就是说先调用 valueOf 方法后调用 toString 方法。</li>
</ul>
<h1 id="二、-false："><a href="#二、-false：" class="headerlink" title="二、[] == false："></a>二、[] == false：</h1><ol>
<li>根据<code>抽象比较算法</code>的 7、8、9、10 步骤。<br>因为 [] 和 false 不是同一类型，所以执行到 8 的时候会调用 toNumber() 将 false 转化成 0。之后对<code>[] == 0</code>继续进行抽象比较算法，执行到 10 开始使用 toPrimitive() 对 [] 进行转化。  </li>
<li>根据 DefaultValue 处理过程，对于<code>[] == 0</code> 中的 []，会沿着原型链找到 Array，但是 Array 没有实现 valueOf 方法，所以会沿着原型链最终调用 Object.prototype.valueOf()。但是 Object.prototype.valueOf() 返回的是一个对象，不是原始类型，所以还要调用 Array.prototype.toString() 方法。</li>
<li>数组的 toString 相当于 join() 得到 ‘’。之后根据<code>抽象比较算法</code>中的 4、5，会调用 toNumber() 将空字符串 ‘’ 转化成数字 ，最终变成<code>0 == 0</code>为 true。  </li>
</ol>
<h1 id="三、为什么-false-为-true，-false-为-false"><a href="#三、为什么-false-为-true，-false-为-false" class="headerlink" title="三、为什么 []==false 为 true，!![]==false 为 false"></a>三、为什么 []==false 为 true，!![]==false 为 false</h1><h2 id="为什么-false-？"><a href="#为什么-false-？" class="headerlink" title="为什么 [] == false ？"></a>为什么 [] == false ？</h2><p>首先我们知道 [] 和 false 一个是对象，一个是布尔值，类型不同，需要类型转换再做比较。<br>要注意，JS 中规定，如果 == 中有布尔值，只能转换为数字，因为如果布尔值转换成字符串那就是 true 和 false，那这种对比就毫无意义了。<br>所以此问题可以转换成：为什么 [] == 0？  </p>
<h2 id="为什么-0-？"><a href="#为什么-0-？" class="headerlink" title="为什么 [] == 0 ？"></a>为什么 [] == 0 ？</h2><p>我们知道 Primitive(原值) 和非 Primitive 比较，需要把非 Primitive 转换成 Primitive 才可以。[] 是一个对象，因此需要 toPrimitive()。而大部分对象最后都是用 toString() 来转换成 Primitive，少部分 valueOf() 转换。<br>为什么是用 toString() 不是 toNumber() 之类的呢？ 因为每个对象都有 toString() 方法，Object.prototype.toString。<br>我们来看看数组的 toString，数组的 toString 相当于 join()。<br>所以此问题可以转换成：为什么<code>&#39;&#39; == 0</code>？</p>
<h2 id="为什么-‘’-0-？"><a href="#为什么-‘’-0-？" class="headerlink" title="为什么 ‘’ == 0 ？"></a>为什么 ‘’ == 0 ？</h2><p>而 JS 中规定，字符串和数字比较会把字符串转换成数字，用的 Number()。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(&apos;&apos;)  // 0</span><br><span class="line">Number(&apos;abc&apos;) // NaN</span><br></pre></td></tr></table></figure></p>
<p>推理到此结束，我们回顾一下这个比较的转换规程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. [] == false</span><br><span class="line">2. [] == 0</span><br><span class="line">3. &apos;&apos; == 0</span><br><span class="line">4. 0 == 0</span><br></pre></td></tr></table></figure></p>
<h2 id="为什么-false-是-false-呢-？"><a href="#为什么-false-是-false-呢-？" class="headerlink" title="为什么 !![] == false 是 false 呢 ？"></a>为什么 !![] == false 是 false 呢 ？</h2><p>左边有 ! 会调用 Boolean() 进行隐式转换，可以看这个值是不是 Falsy(假值) 即可，只要不是Falsy，结果都是 true。Falsy 的值有 <code>0、&#39;&#39;、false、NaN、null、undefined</code>。<br>所以左边调用 Boolean() 得 true，右边为 false，所以<code>!![] == false</code>是 false。</p>
<h2 id="为什么-null-0-是-false-呢-？"><a href="#为什么-null-0-是-false-呢-？" class="headerlink" title="为什么 null == 0 是 false 呢 ？"></a>为什么 null == 0 是 false 呢 ？</h2><p>null 和数字 0 本身已经是 Primitive 了，没有机会再走一遍 toPrimitive()，因此等号两边始终无法转换成同类型，只能返回 false。  </p>
<h2 id="为什么-null-undefined-是-true-呢-？"><a href="#为什么-null-undefined-是-true-呢-？" class="headerlink" title="为什么 null == undefined 是 true 呢 ？"></a>为什么 null == undefined 是 true 呢 ？</h2><p>JS 专门规定了 null == undefined 就是返回 true，属于一种特殊情况。  </p>
<h1 id="四、一些例子"><a href="#四、一些例子" class="headerlink" title="四、一些例子"></a>四、一些例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] == &apos;1&apos;  // true</span><br><span class="line">&apos;[object Object]&apos; == &#123;&#125;  // true，(&#123;&#125;).toString() === [object Object]</span><br><span class="line">[&apos;0&apos;] == false  // true</span><br><span class="line">0 || false  // false</span><br><span class="line">false || 0  // 0</span><br><span class="line">false || true  // true</span><br><span class="line">false || &apos;1&apos;  // &apos;1&apos;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>记录</title>
    <url>/post/e797f254.html</url>
    <content><![CDATA[<h1 id="用户从输入url到最终页面展示，这个过程都发生了什么？"><a href="#用户从输入url到最终页面展示，这个过程都发生了什么？" class="headerlink" title="用户从输入url到最终页面展示，这个过程都发生了什么？"></a>用户从输入url到最终页面展示，这个过程都发生了什么？</h1><p>计算机网络：http请求组包、网络模型、dns解析、建立连接<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户输入url，</span><br><span class="line">浏览器缓存机制检查，</span><br><span class="line">http请求包结构，</span><br><span class="line">dns解析，</span><br><span class="line">连接建立，</span><br><span class="line">服务器端处理（如动态页面处理、静态页面处理、cdn相关知识），</span><br><span class="line">浏览器收到html内容怎么解析，</span><br><span class="line">怎么并行加载串行执行css、js，</span><br><span class="line">怎么构造渲染树渲染页面，</span><br><span class="line">怎么根据请求头把内容缓存到浏览器端，</span><br><span class="line">https、同构直出、service worker...</span><br></pre></td></tr></table></figure></p>
<h1 id="函数单一职责"><a href="#函数单一职责" class="headerlink" title="函数单一职责"></a>函数单一职责</h1><p>函数功能混乱，一个函数包含多个功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sendEmailToClients(clients) &#123;</span><br><span class="line">  clients.forEach(client =&gt; &#123;</span><br><span class="line">    const clientRecord = database.lookup(client)</span><br><span class="line">    if (clientRecord.isActive()) &#123;</span><br><span class="line">      email(client)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>功能拆解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sendEmailToActiveClients(clients) &#123;</span><br><span class="line">  clients.filter(isActiveClient).forEach(email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isActiveClient(client) &#123;</span><br><span class="line">  const clientRecord = database.lookup(client)</span><br><span class="line">  retuen clientRecord.isActive()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h1><ul>
<li>JSON.parse(JSON.stringify(obj)</li>
<li>递归<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function clone(value, isDeep) &#123;</span><br><span class="line">  if(value === null) return null</span><br><span class="line">  if(typeof value !== &apos;object&apos;) return value</span><br><span class="line">  if(Array.isArray(value)) &#123;</span><br><span class="line">    if(isDeep) &#123;</span><br><span class="line">      return value.map(item =&gt; clone(item, true))</span><br><span class="line">    &#125;</span><br><span class="line">    return [].concat(value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (isDeep) &#123;</span><br><span class="line">      var obj = &#123;&#125;</span><br><span class="line">      Object.keys(value).forEach(item =&gt; &#123;</span><br><span class="line">        obj[item] = clone(value[item], true)</span><br><span class="line">      &#125;)</span><br><span class="line">      return obj</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;...value&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objects = &#123; c: &#123; &apos;a&apos;: 1, e: [1, &#123;f: 2&#125;] &#125;, d: &#123; &apos;b&apos;: 2 &#125; &#125;</span><br><span class="line">var shallow = clone(objects, true)</span><br><span class="line">console.log(shallow.c.e[1]) // &#123; f: 2 &#125;</span><br><span class="line">console.log(shallow.c === objects.c) // false</span><br><span class="line">console.log(shallow.d === objects.d) // false</span><br><span class="line">console.log(shallow === objects) // false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="css-样式的优先级和使用时候的位置无关，只与声明的位置有关"><a href="#css-样式的优先级和使用时候的位置无关，只与声明的位置有关" class="headerlink" title="css 样式的优先级和使用时候的位置无关，只与声明的位置有关"></a>css 样式的优先级和使用时候的位置无关，只与声明的位置有关</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;red blue&quot;&gt;123&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;blue red&quot;&gt;123&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  color: red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.blue &#123;</span><br><span class="line">  color: blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h3 id="then-的返回值"><a href="#then-的返回值" class="headerlink" title="then 的返回值"></a>then 的返回值</h3><p><code>then</code>方法里接受两个函数作为参数，分别是<code>resolve</code>和<code>reject</code>后执行的回调，返回的是一个新的 Promise 实例。若回调有返回值，则将返回结果作为参数，传入下一个<code>then</code>的回调函数。若回调无返回值，仍将返回一个 Promise，但下一个<code>then</code>的回调函数的参数为<code>undefined</code>。也就是当链式调用时，不管有没有返回值，后面的<code>then</code>都会被执行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line"> .then(res =&gt; console.log(1))</span><br><span class="line"> .then(res =&gt; console.log(2))</span><br><span class="line"> .then(res =&gt; console.log(3))</span><br><span class="line"> // 打印结果 1, 2, 3</span><br></pre></td></tr></table></figure></p>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。  </p>
<ol>
<li><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getJSON(&apos;/post/1.json&apos;)</span><br><span class="line">  .then(post =&gt; getJSON(post.commentURL))</span><br><span class="line">  .then(comments =&gt; &#123;</span><br><span class="line">    // some code</span><br><span class="line">  &#125;).catch(error =&gt; &#123;</span><br><span class="line">    // 处理前面三个Promise产生的错误</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p> 上面代码中，一共有三个 Promise 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。  </p>
</li>
<li><p><code>catch</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const test = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      throw new Error(&apos;test&apos;) // 或者 reject(new Error(&apos;test&apos;))</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&apos;carry on&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p> 上面代码运行完<code>catch</code>的回调函数，会接着运行后面的<code>then</code>的回调函数。如果没有报错，则会跳过<code>catch</code>方法。</p>
</li>
</ol>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p><code>finally</code>本质上是<code>then</code>方法的特例。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    return result</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。  </p>
<p>它的实现也很简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.prototype.finally = function (callback) &#123;</span><br><span class="line">  let P = this.constructor</span><br><span class="line">  return this.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(() =&gt; value),  // 传过来的 promise 是 fulfilled，则调用 resolve 回调</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)  // 传过来的 promise 是 rejected，则调用 reject 回调</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。而且<code>finally</code>方法总是会返回原来的值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// resolve 的值是 undefined</span><br><span class="line">Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// resolve 的值是 2</span><br><span class="line">Promise.resolve(2).finally(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 undefined</span><br><span class="line">Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// reject 的值是 3</span><br><span class="line">Promise.reject(3).finally(() =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。  </p>
<p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是B的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。  </p>
<p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。  </p>
<p><strong>在普通方法中：</strong><br><code>super</code>引用相当于指向对象原型的指针，相当于<code>Object.getPrototypeOf(this)</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  p () &#123;</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    console.log(super.p())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B() // 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>super</code>指向A.prototype，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。  </p>
<p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.p = 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    console.log(super.p)</span><br><span class="line">  &#125;</span><br><span class="line">  test () &#123;</span><br><span class="line">    return super.p</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B() // undefined</span><br><span class="line">b.test() // undefined</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。如果属性定义在父类的原型对象上，<code>super</code>就可以取到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.p = 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.p = 3</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    console.log(super.p)</span><br><span class="line">  &#125;</span><br><span class="line">  test () &#123;</span><br><span class="line">    return super.p</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B() // 3</span><br><span class="line">b.test() // 3</span><br></pre></td></tr></table></figure></p>
<p>在子类普通方法中，通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。<code>super.doSth()</code>相当于<code>Object.getPrototypeOf(this).doSth.call(this)</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.x = 1</span><br><span class="line">  &#125;</span><br><span class="line">  print () &#123;</span><br><span class="line">    console.log(this.x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.x = 2</span><br><span class="line">  &#125;</span><br><span class="line">  print () &#123;</span><br><span class="line">    super.print()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B()</span><br><span class="line">b.print() // 2</span><br></pre></td></tr></table></figure></p>
<p><code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是 2，而不是 1。也就是说，实际上执行的是<code>super.print.call(this)</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myObject = &#123;</span><br><span class="line">  x: &apos;x&apos;,</span><br><span class="line">  test () &#123;</span><br><span class="line">    return this.x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x = &#123;</span><br><span class="line">  __proto__: myObject,</span><br><span class="line">  test () &#123;</span><br><span class="line">    return console.log(super.test() + &apos;x&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x.test() // &apos;xx&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123;</span><br><span class="line">  name: &apos;obj1&apos;,</span><br><span class="line">  method1 () &#123;</span><br><span class="line">    console.log(&apos;method 1&apos;)</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj2 = &#123;</span><br><span class="line">  name: &apos;obj2&apos;,</span><br><span class="line">  method2 () &#123;</span><br><span class="line">    super.method1()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用 setPrototypeOf 将第二个对象的原型设为第一个对象</span><br><span class="line">Object.setPrototypeOf(obj2, obj1)</span><br><span class="line">obj2.method2() // &apos;method 1&apos;, &apos;obj2&apos;</span><br></pre></td></tr></table></figure>
<p><code>super.method1()</code>相当于<code>obj1.method1.call(obj2)</code>。  </p>
<p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.x = 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.x = 2</span><br><span class="line">    super.x = 3</span><br><span class="line">    console.log(super.x)  // undefined</span><br><span class="line">    console.log(this.x) // 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B()</span><br></pre></td></tr></table></figure></p>
<p><code>super.x</code>赋值为 3，这时等同于对<code>this.x</code>赋值为 3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。  </p>
<p><strong>在静态方法中：</strong><br><code>super</code>将指向父类，而不是父类的原型对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.name = 1</span><br><span class="line">  &#125;</span><br><span class="line">  static method () &#123;</span><br><span class="line">    console.log(&apos;static&apos;, this.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  method () &#123;</span><br><span class="line">    console.log(&apos;instance&apos;, this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.name = 2</span><br><span class="line">  &#125;</span><br><span class="line">  static method () &#123;</span><br><span class="line">    super.method()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  method () &#123;</span><br><span class="line">    super.method()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child = new Child()</span><br><span class="line"></span><br><span class="line">Child.method() // static Child</span><br><span class="line">child.method() // instance 2</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/post/817c7d82.html</url>
    <content><![CDATA[<p><code>ls</code> 查看当前目录下的文件（或文件夹）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l：查看详细信息</span><br><span class="line"></span><br><span class="line">-a：查看隐藏文件</span><br><span class="line"></span><br><span class="line">-la：同时具备以上特点</span><br></pre></td></tr></table></figure></p>
<p><code>pwd</code> print working directory, 打印工作目录，它会显示我们当前所在的目录路径。  </p>
<p><code>cd</code> 目录切换<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ../ 返回上级目录</span><br><span class="line">cd ./ 返回当前目录</span><br><span class="line">cd / 返回根目录</span><br><span class="line">cd xxx 进入到指定文件夹</span><br><span class="line">cd E 进入到指定的磁盘</span><br></pre></td></tr></table></figure></p>
<p><code>mkdir</code> 创建文件夹  </p>
<p><code>touch</code> 创建一个空文件  </p>
<p><code>rm</code> 删除文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-r  # 递归删除（把当前文件夹中所有的后代元素遍历删除）</span><br><span class="line">-f  # 强制删除</span><br><span class="line">-rf # 上面两种合并到一起，没有办法还原，慎重使用</span><br></pre></td></tr></table></figure></p>
<p><code>vi</code> 向指定文件中插入内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先进入命令窗口模式</span><br><span class="line">按i，进入到插入内容模式</span><br><span class="line">编辑需要写的内容</span><br><span class="line">按ESC，再按:wq  # 保存并退出</span><br><span class="line">q！ # 强制退出，内容不保存</span><br></pre></td></tr></table></figure></p>
<p><code>echo</code> 文字输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo xxx &gt; y.txt  # 把 xxx 内容放到 y.txt 文件中，如果没有这个文件则创建这个文件，新存放的内容会替换原有文件的内容</span><br></pre></td></tr></table></figure></p>
<p><code>cat</code> 查看文件中的内容  </p>
<p><code>cp</code> 拷贝文件  </p>
<p><code>mv</code> 移动文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv index.html src  # index.html 是我们要移动的文件, src 是目标文件夹</span><br></pre></td></tr></table></figure></p>
<p><code>exit</code> 可以直接退出窗口  </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator 和 for-of</title>
    <url>/post/8aa98d9.html</url>
    <content><![CDATA[<h1 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h1><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找并调用<code>Symbol.iterator</code>方法。也就是说，一种数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。  </p>
<p><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回默认的遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。  </p>
<p>下面是原生具备<code>Iterator</code>接口的数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>类数组的对象（比如 arguments 对象、DOM NodeList 对象）</li>
<li>Generator 对象</li>
</ul>
<h1 id="原型链上的对象具有该方法也可"><a href="#原型链上的对象具有该方法也可" class="headerlink" title="原型链上的对象具有该方法也可"></a>原型链上的对象具有该方法也可</h1><ul>
<li>解构赋值</li>
<li>扩展运算符</li>
<li>yield*</li>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h1 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h1><p>数组原生具备 iterator 接口。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br><span class="line"></span><br><span class="line">for (let v in arr) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// 0 1 2 3</span><br><span class="line"></span><br><span class="line">for (let v of arr) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// a b c d</span><br><span class="line"></span><br><span class="line">for (let k of arr.keys()) &#123;</span><br><span class="line">  console.log(k)</span><br><span class="line">&#125;</span><br><span class="line">// 0 1 2 3</span><br><span class="line"></span><br><span class="line">for (let value of arr.values()) &#123;</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">// a b c d</span><br><span class="line"></span><br><span class="line">for (let [index, value] of arr.entries()) &#123;</span><br><span class="line">  console.log(key, &apos;-&gt;&apos;, value)</span><br><span class="line">&#125;</span><br><span class="line">// 0 -&gt; a</span><br><span class="line">// 1 -&gt; b</span><br><span class="line">// 2 -&gt; c</span><br><span class="line">// 3 -&gt; d</span><br></pre></td></tr></table></figure></p>
<h1 id="遍历类数组"><a href="#遍历类数组" class="headerlink" title="遍历类数组"></a>遍历类数组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">let str = &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">for (let s of str) &#123;</span><br><span class="line">  console.log(s)</span><br><span class="line">&#125;</span><br><span class="line">// h e l l o</span><br><span class="line"></span><br><span class="line">// DOM NodeList对象</span><br><span class="line">let paras = document.querySelectorAll(&apos;p&apos;)</span><br><span class="line"></span><br><span class="line">for (let p of paras) &#123;</span><br><span class="line">  p.classList.add(&apos;test&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// arguments 对象</span><br><span class="line">function printArgs () &#123;</span><br><span class="line">  for (let x of arguments) &#123;</span><br><span class="line">    console.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(&apos;a&apos;, &apos;b&apos;)</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br></pre></td></tr></table></figure>
<p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arrayLike = &#123; length: 2, 0: &apos;a&apos;, 1: &apos;b&apos; &#125;</span><br><span class="line"></span><br><span class="line">for (let x of arrayLike) &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">// 报错：arrayLike is not iterable</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">const array = [].slice.call(arrayLike)</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">const array = Array.from(arrayLike)</span><br><span class="line"></span><br><span class="line">for (let x of array) &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">// a</span><br><span class="line">// b</span><br></pre></td></tr></table></figure></p>
<h1 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h1><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。那么怎么做到使对象可遍历？</p>
<h2 id="方法一：部署-Iterator-接口（在-Symbol-iterator-的属性上部署遍历器生成方法）"><a href="#方法一：部署-Iterator-接口（在-Symbol-iterator-的属性上部署遍历器生成方法）" class="headerlink" title="方法一：部署 Iterator 接口（在 Symbol.iterator 的属性上部署遍历器生成方法）"></a>方法一：部署 Iterator 接口（在 Symbol.iterator 的属性上部署遍历器生成方法）</h2><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法。  </p>
<p>1、添加 next 方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.iterator] () &#123;</span><br><span class="line">    let value = 0</span><br><span class="line">    let stop = 3</span><br><span class="line">    return &#123;</span><br><span class="line">      next () &#123;</span><br><span class="line">        while (value &lt; stop) &#123;</span><br><span class="line">          value++</span><br><span class="line">          return &#123;</span><br><span class="line">            done: false,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">          done: true,</span><br><span class="line">          value: undefined</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const i = obj[Symbol.iterator]()</span><br><span class="line">i.next()  // &#123; value: 1, done: false &#125;</span><br><span class="line">i.next()  // &#123; value: 2, done: false &#125;</span><br><span class="line">i.next()  // &#123; value: 3, done: false &#125;</span><br><span class="line">i.next()  // &#123; value: 3, done: true &#125;</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line">for (const v of obj) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]</span><br><span class="line">const obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr)</span><br><span class="line"></span><br><span class="line">for (let v of obj) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// red green blue</span><br></pre></td></tr></table></figure>
<p>原型链上的对象具有该方法也可以。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RangeIterator &#123;</span><br><span class="line">  constructor (start, stop) &#123;</span><br><span class="line">    this.value = start</span><br><span class="line">    this.stop = stop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [Symbol.iterator] () &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next () &#123;</span><br><span class="line">    var value = this.value</span><br><span class="line">    if (value &lt; this.stop) &#123;</span><br><span class="line">      this.value++</span><br><span class="line">      return &#123;</span><br><span class="line">        done: false,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      done: true,</span><br><span class="line">      value: undefined</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function range (start, stop) &#123;</span><br><span class="line">  return new RangeIterator(start, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (const v of range(0, 3)) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p>
<p>2、Generator：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Collection &#123;</span><br><span class="line">  *[Symbol.iterator] () &#123;</span><br><span class="line">    let i = 0</span><br><span class="line">    while (this[i] !== undefined) &#123;</span><br><span class="line">      yield this[i]</span><br><span class="line">      ++i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const collection = new Collection()</span><br><span class="line">collection[0] = 1</span><br><span class="line">collection[1] = 2</span><br><span class="line"></span><br><span class="line">for (const v of collection) &#123;</span><br><span class="line">  console.log(v)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure></p>
<p>由于<code>Generator</code>函数就是遍历器生成函数，因此可以把<code>Generator</code>赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有<code>Iterator</code>接口。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myIterable = &#123;&#125;</span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  yield 3</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二：使用-Object-keys-、Object-values-、Object-entries"><a href="#方法二：使用-Object-keys-、Object-values-、Object-entries" class="headerlink" title="方法二：使用 Object.keys()、Object.values()、Object.entries()"></a>方法二：使用 Object.keys()、Object.values()、Object.entries()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const obj = &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line"></span><br><span class="line">for (const key of Object.keys(obj)) &#123;</span><br><span class="line">  console.log(key, &apos;-&gt;&apos;, obj[key])</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br><span class="line"></span><br><span class="line">for (const value of Object.values(obj)) &#123;</span><br><span class="line"> console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">for (const [key, value] of Object.entries(obj)) &#123;</span><br><span class="line">  console.log(key, &apos;-&gt;&apos;, value)</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure>
<h2 id="方法三：使用-Object-getOwnPropertyNames"><a href="#方法三：使用-Object-getOwnPropertyNames" class="headerlink" title="方法三：使用 Object.getOwnPropertyNames()"></a>方法三：使用 Object.getOwnPropertyNames()</h2><p>包含不可枚举属性，不包含<code>Symbol</code>属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (const key of Object.getOwnPropertyNames(obj)) &#123;</span><br><span class="line"> console.log(key + &apos;: &apos; + obj [key])</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure></p>
<h2 id="方法四：使用-Reflect-ownKeys"><a href="#方法四：使用-Reflect-ownKeys" class="headerlink" title="方法四：使用 Reflect.ownKeys()"></a>方法四：使用 Reflect.ownKeys()</h2><p>包含不可枚举属性，也包含<code>Symbol</code>属性。基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (const key of Reflect.ownKeys(obj)) &#123;</span><br><span class="line"> console.log(key + &apos;: &apos; + obj [key])</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure></p>
<h2 id="方法五：使用-Generator-函数将对象重新包装"><a href="#方法五：使用-Generator-函数将对象重新包装" class="headerlink" title="方法五：使用 Generator 函数将对象重新包装"></a>方法五：使用 Generator 函数将对象重新包装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* entries(obj) &#123;</span><br><span class="line">  for (let key of Object.keys(obj)) &#123;</span><br><span class="line">    yield [key, obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of entries(obj)) &#123;</span><br><span class="line">  console.log(key, &apos;-&gt;&apos;, value)</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure>
<h2 id="方法六：使用-Map-代替对象"><a href="#方法六：使用-Map-代替对象" class="headerlink" title="方法六：使用 Map 代替对象"></a>方法六：使用 Map 代替对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const map = new Map(Object.entries(obj))</span><br><span class="line"></span><br><span class="line">for (const [key, value] of map) &#123;</span><br><span class="line">  console.log(key, &apos;-&gt;&apos;, value)</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javascript</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/post/caff8000.html</url>
    <content><![CDATA[<h1 id="Git-的工作流程"><a href="#Git-的工作流程" class="headerlink" title="Git 的工作流程"></a>Git 的工作流程</h1><blockquote bgcolor="#FF4500">Git 是分布式版本控制系统，每一台客户端都是一个独立的 git 仓库（有 git 工作的全套机制）。<br>一个 git 仓库分为三个区域：<br>  1. 工作区：平时写代码的地方。就是你在电脑里能看到的目录。<br>  2. 暂存区：代码暂时存储的地方。英文叫 stage 或 index。一般存放在<code>.git目录</code>下的 index 文件<code>.git/index</code>中，所以我们把暂存区有时也叫作索引 index。<br>  3. 历史区(本地仓库版本库)：生成版本记录的地方。工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br></blockquote><br><img src="http://cdn.luanzhuxian.com/blog/git-flow_1.png" alt="avatar"><br><img src="http://cdn.luanzhuxian.com/blog/git-flow_2.png" alt="avatar"><br><br># 基本配置命令<br><br>## 使用 Git 生成 ssh 密钥<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><br><br>## 设置全局用户名和邮箱<br>安装完成git后，我们应该先把基础信息配置一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config -l # 查看当前本机的配置清单</span><br><span class="line">git config --global user.name &quot;name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot; # github/coding等平台的账号和邮箱</span><br></pre></td></tr></table></figure><br><br>## 初始化仓库<br>在指定目录中，打开命令行，执行<code>git init</code>，相当于以当前目录作为基础，创建了一个本地 git 仓库。<br>创建完成后，会在项目的根目录中展示<code>.git</code>这个隐藏文件：有这个<code>.git</code>文件的才叫做 git 仓库（暂存区和历史区都是存在<code>.git</code>文件夹）。<br><br><br>## 工作区提交到暂存区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;	# 添加指定文件到暂存区</span><br><span class="line">git add .	          # 添加工作区所有变动到暂存区</span><br><span class="line">git add -i	        # 交互方式添加文件到暂存区</span><br><span class="line">git add -u	        # 将工作区中已经变动的文件添加到暂存区，当新增加的文件不会被添加</span><br></pre></td></tr></table></figure><br><br>## 暂存区提交到历史区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;描述信息&quot;		 # 提交更新</span><br><span class="line">git commit -am &quot;描述信息&quot;	   # 如果工作目录中仅是已跟踪的文件被修改或被删除，使用此提交命令</span><br></pre></td></tr></table></figure><br><br>## 分支的创建、删除、合并、切换、查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch	                   # 查看本地已有的分支</span><br><span class="line">git branch -a	                 # 查看远程分支</span><br><span class="line">git branch 新分支名 [分支起点]	# 创建分支，如果没有分支起点的话，则默认在当前分支的最新提交上创建分支</span><br><span class="line">git checkout 分支名	          # 切换分支</span><br><span class="line">git checkout -b 新分支名		   # 创建同时切换到新分支</span><br><span class="line">git checkout -b 本地分支名 origin/远程分支名		   # 将远程git仓库里的指定分支拉取到本地（本地不存在的分支）</span><br><span class="line">git merge 要被合并的分支名	    # 合并分支</span><br><span class="line">git rebase 要被合并的分支名	    # 重新设置基线，将你的当前分支重新设置开始点</span><br><span class="line">git rebase -i  [startpoint]  [endpoint]	    # 合并多个提交为一个提交</span><br><span class="line">git rebase   [startpoint]   [endpoint]  --onto  [branchName]	    # 将某一段commit粘贴到另一个分支上</span><br><span class="line">git branch -d 要删除的分支名	   # 删除指定分支（如果分支没有被合并过，该命令会执行失败）</span><br><span class="line">git branch -D 要删除的分支名	   # 删除指定分支，不管有没有被合并过</span><br><span class="line">gitk				                   # 用图形界面查看分支提交历史</span><br></pre></td></tr></table></figure><br><br>使用例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch                // 新建一个分支，并切换到该分支</span><br><span class="line">$ git branch                              // 命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;提交分支branch&quot;</span><br><span class="line">$ git checkout master                     // 切换回master分支</span><br><span class="line">$ git merge branch or $ git merge branch master  // 把branch分支合并到master分支</span><br><span class="line">$ git branch -d branch                    // 合并完成后删除branch分支</span><br></pre></td></tr></table></figure><br><br>合并分支过程中如果发生冲突则需要自己手动解决冲突，然后再提交。有冲突时，Git 会显示哪个文件有冲突，并在冲突的文件中加上特殊的标识符号，解决完冲突后，要手动去掉这些被添加的标识符号。如果冲突比较复杂的话，最好使用其他工具来协助，通过<code>git merge tool</code>来启动。冲突一般是在不同的分支上对同一文件的同一位置内容进行了改动，并已提交到仓库中，这样在合并的时候就会发生冲突。<br><br>## 标签的添加、删除、查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag		                     # 查看标签</span><br><span class="line">git tag 标签名	                 # 创建简单的标签</span><br><span class="line">git tag -a 标签名 -m &apos;附加信息&apos;	# 创建附加信息的标签</span><br><span class="line">git show 标签名	               # 通过标签查看信息</span><br><span class="line">git tag -d 标签名	             # 删除标签</span><br></pre></td></tr></table></figure><br><br>标签可以在需要的地方，为某个提交对象创建别名，这样以后我们就可以通过标签来查看一些信息，创建分支等。<br><br>## 查看工作目录状态<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><br><br>在 git 命令执行后，要养成通过<code>git status</code>查看 git 状态的习惯，以便及时了解文件变化的情况。通过<code>git status</code>可以知道文件的状态（已修改未暂存、已删除、已修改并已暂存等待提交、未跟踪）。<br><br>## 查看提交历史<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -p	# 显示每次提交文件变化</span><br><span class="line">git reflog	# 显示提交历史的简介</span><br></pre></td></tr></table></figure><br><br>通过<code>git log</code>可以查看当前分支的所有提交历史，知道每次提交的 commit 对象的 ID 以及提交时附加的描述信息等。要显示更多的信息，需要使用其支持的选项，如<code>git log -p</code>可以将每次提交的文件变化也显示出来。<br><br>## 查看指定的提交对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show commit_id	# 查看指定的某次提交内容</span><br><span class="line">git show --all		# 显示所有的提交历史内容</span><br><span class="line">git shortlog -s -n	# 显示总的提交次数</span><br></pre></td></tr></table></figure><br><br>通过<code>git log</code>可以显示整个提交历史，而通过<code>git show commit-id</code>则可以查看指定的某次提交内容，当然<code>git show -all</code>也可以显示出提交历史，另外还可以格式化显示内容。<br><code>commit-id</code>可以是 commit 对象对应的 ID，也可以是 HEAD，分支名，tag 等。<br><br>## 查看工作区、暂存区、仓库之间的差异<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff		        # 比较工作区与暂存区的差异</span><br><span class="line">git diff HEAD		    # 比较工作区与历史区最近一次的提交间的差异</span><br><span class="line">git diff --cached	  # 比较暂存区与历史区最近一次提交的差异</span><br><span class="line">git blame filename	# 可以列出该文件每次被修改的时间和内容。</span><br></pre></td></tr></table></figure><br><br>## 版本回退、撤销操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog	                # 显示提交历史的简介</span><br><span class="line">git reset --hard            # 重置暂存区与工作区，与上一次 commit 保持一致（暂存区先回滚一次，适用于丢弃已提交的内容）</span><br><span class="line">git reset --hard HEAD^		  # 回退到上一个版本，即上一次暂存区中记录的内容</span><br><span class="line">git reset --hard commit_id	# 回退到指定版本，重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git checkout .              # 丢弃工作区的所有修改，把最新暂存区的内容回滚到工作区，替换工作区中的内容（适用于丢弃工作区还未提交的内容）</span><br><span class="line">git checkout -- filename	  # 丢弃工作区的指定修改</span><br><span class="line">git ls-files -d			        # 列出工作区被删除的文件（文件之前被提交到仓库中）</span><br></pre></td></tr></table></figure><br><br>有时候，由于我们的误操作，产生了一些错误，我们发现后希望能够及时纠正这些因为误操作而产生的结果，将工作目录恢复到某个正常状态。<br>- 丢弃还没有添加到暂存区的，某个文件的修改：<code>git checkout -- filename</code>修改的文件会被恢复到上次提交时的状态，修改的内容会丢失。<br>- 丢弃已添加到暂存区的，某个文件的修改：先通过<code>$ git reset HEAD file</code>回到上面的场景，第二步<code>git checkout -- filename</code>。<br>- 已经提交了不合适的修改到版本库，想要撤销本次提交：<code>$ git reset --hard</code>。<br><br><strong>注意：已经push到远程仓库的 commit 不允许 reset。如果 commit 已经被 push 到远程仓库上了，也就意味着其他开发人员就可能基于这个 commit 形成了新的 commit，这时你去 reset，就会造成其他开发人员的提交历史莫名其妙的丢失，或者其他灾难性的后果。</strong><br><br>## 备份工作区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash			            # 将工作区文件保存在Git内部栈中</span><br><span class="line">git stash list			      # 列出Git内部栈中保存的工作区文件列表</span><br><span class="line">git stash apply stash_id	# 恢复工作区到指定的内部栈状态</span><br><span class="line">git stash pop			        # 恢复工作区到上一个内部栈状态</span><br><span class="line">git stash clear			      # 清空Git内部栈</span><br></pre></td></tr></table></figure><br><br>如果正在一个<code>develop</code>分支上正在开发新功能，但这时<code>master</code>分支(稳定版本)突然发现了 bug，并需要及时修复，而<code>develop</code>分支此时的工作还没有完成，且不希望将之前的工作就这样提交到仓库中时，这时就可以用<code>git stash</code>来暂时保存这些状态到 Git 内部栈中，并用当前分支上一次的提交内容来恢复工作目录，然后切换到<code>master</code>分支进行 bug 修复工作，等修复完毕并提交到仓库上后，再使用<code>git stash apply [stash@{0}]</code>或者<code>git stash pop</code>将工作目录恢复到之前的状态，继续之前的工作。<br><br>同时也可以多次使用<code>git stash</code>将未提交的代码压入到 Git 栈中，但当多次使用<code>git stash</code>命令后，Git 栈里将充满了未提交的代码，这时候到底要用哪个版本来恢复工作目录呢？<code>git stash list</code>命令可以将当前的 Git 栈信息打印出来，我们只需要将找到对应的版本号，例如使用<code>git stash apply stash@{1}</code>就可以用版本号为<code>stash@{1}</code>的内容来恢复工作目录。<br><br>当 Git 栈中所有的内容都被恢复后，可以使用<code>git stash clear</code>来将栈清空。<br><br><blockquote bgcolor="#FF4500">实用技巧：当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再使用<code>git stash pop</code>，回到工作现场.</blockquote>

<h2 id="将当前工作区目录文件压缩归档"><a href="#将当前工作区目录文件压缩归档" class="headerlink" title="将当前工作区目录文件压缩归档"></a>将当前工作区目录文件压缩归档</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git archive --format=zip -o arch.zip HEAD</span><br><span class="line">git arch --format zip head&gt;arch.zip</span><br></pre></td></tr></table></figure>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><p>Git 相比其他版本控制软件的一个优点就是大多数的操作都可以在本地进行，而不用管远程的仓库，因为操作是在本地，且操作的数据也是在本地，加上指针等原因，所以执行的速度就会比较快。 在多人协作的项目中，就需要涉及与远程仓库交互的问题，主要是如何从远程仓库抓取最新数据合并到自己的本地分支上，将自己的最新成果分享给其他人或让别人审查等 。</p>
<h2 id="远程仓库的克隆、添加、查看"><a href="#远程仓库的克隆、添加、查看" class="headerlink" title="远程仓库的克隆、添加、查看"></a>远程仓库的克隆、添加、查看</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote	                              # 显示已关联的远程仓库</span><br><span class="line">git remote -v 	                          # 显示已关联的远程仓库和地址</span><br><span class="line">git remote add 远程仓库名 远程仓库地址	     # 在本地关联远程仓库</span><br><span class="line">git remote rm 远程仓库名		               	# 移除本地关联的远程仓库</span><br><span class="line">git remote rename 原名 新名		             # 重命名远程仓库</span><br><span class="line">git clone 远程仓库地址 [克隆到指定的文件夹]	# 克隆远程仓库到本地</span><br><span class="line">git fetch 远程仓库名		                    # 从远程仓库抓取最新数据到本地但不与本地分支进行合并</span><br><span class="line">git pull 远程仓库名	本地要合并的分支名	     # 从远程仓库抓取最新数据并自动与本地分支进行合并</span><br><span class="line">git push 远程仓库名 本地分支名	            # 将本地仓库推送到远程仓库中</span><br><span class="line">git remote show 远程仓库名	                # 查看远程仓库信息</span><br><span class="line">git remote show		      	                # 查看所有远程仓库</span><br><span class="line">git push 远程仓库名 标签名                	# 将标签推送到远程仓库（Git默认不推送标签）</span><br><span class="line">git rm file_path                          # 删除暂存区和工作区上的文件</span><br><span class="line">git rm --cached file_path                 # 删除暂存区或分支上的文件, 已提交内容也会被删除，但工作区保留</span><br></pre></td></tr></table></figure>
<h2 id="协同流程"><a href="#协同流程" class="headerlink" title="协同流程"></a>协同流程</h2><ul>
<li>Fork 远程项目</li>
<li>把 Fork 的项目 clone 到本地</li>
<li><p>执行以下命令，将别人的库添加为远端库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add 远端仓库名 远端的分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令，拉去合并到本地，在本地编辑内容前必须执行 pull 操作同步别人的远端库（这样避免冲突）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull 远端仓库名 远端分支名</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑内容</p>
</li>
<li>commit 之后 push 到自己的库</li>
<li>登录 Github，在你的首页可以看到一个<code>pull request</code>按钮，点击它，填写一些说明信息，提交即可</li>
</ul>
<h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><h2 id="创建中央仓库"><a href="#创建中央仓库" class="headerlink" title="创建中央仓库"></a>创建中央仓库</h2><p>中央仓库可能是在：GitHub，Coding，自己公司的 Git 仓库服务平台，自己公司的服务器等…</p>
<ol>
<li><p>基于gitHub创建远程仓库，创建完成后会生成一个远程地址，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https//github.com/username/Repository name.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>还需要把项目中一些基础的信息提交到远程仓库上：</p>
</li>
</ol>
<ul>
<li>在自己本地创建一个仓库，把一些基础内容都放在仓库中</li>
<li>把新增加的内容提交到本地仓库历史区中</li>
<li>让本地仓库和远程仓库保持关联<code>git remote add 远程仓库名 远程仓库地址</code></li>
<li>把本地仓库历史区中的信息同步（推送）到远程仓库上<code>git push</code></li>
</ul>
<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>创建完成后远程仓库后，可以直接通过<code>git clone 仓库地址 [仓库别名]</code>的方式把远程仓库克隆到本地，相当于在本地创建了一个仓库，也让本地这个仓库和远程仓库保持了连接。团队成员可以创建本地分支在上面开发修改，合并提交等操作:</p>
<ul>
<li>看远程库信息：使用<code>git remote -v</code>；  </li>
<li>在本地创建和远程分支对应的分支：使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；  </li>
<li>建立本地分支和远程分支的关联：使用<code>git branch --set-upstream branch-name origin/branch-name</code>；  </li>
<li>从本地推送分支：使用<code>git push 远程仓库名 分支名</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；  </li>
<li>从远程抓取分支：使用<code>git pull</code>，如果有冲突，要先处理冲突；  </li>
<li>合并多个 commit 为一个完整 commit：<code>git rebase -i</code>。  </li>
</ul>
<h2 id="避免拉取更新后提交有两条记录："><a href="#避免拉取更新后提交有两条记录：" class="headerlink" title="避免拉取更新后提交有两条记录："></a>避免拉取更新后提交有两条记录：</h2><ul>
<li>在 pull 之前，先将本地修改存储起来<code>$ git stash</code>，</li>
<li>暂存了本地修改之后，就可以 pull 了，</li>
<li>还原暂存的内容，<code>$ git stash pop stash@{0}</code>，</li>
<li>有冲突的话解决冲突</li>
<li>之后提交  </li>
</ul>
<h2 id="分支管理："><a href="#分支管理：" class="headerlink" title="分支管理："></a>分支管理：</h2><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<ul>
<li>master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>
<li>干活都在 dev 分支上，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本；</li>
<li>团队成员每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。</li>
</ul>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//我们在dev分支上，发现master分支上有代号101号bug</span><br><span class="line">$ git stash                                               // 冷冻现在在dev分支上的工作状态 冻结吧！  </span><br><span class="line">$ git checkout master                                     // 这个bug发生在master主分支上,我们切回master分支</span><br><span class="line">$ git checkout -b issue-101                               // 创建代号101的修复bug分支</span><br><span class="line">修改你的bug</span><br><span class="line">$ git add .                                               // 提交到暂存区</span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;                             // 注意填写信息，以免日后查证</span><br><span class="line">$ git checkout master                                     // 切换回master分支</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101     // 合并分支，注意不使用fast forward模式</span><br><span class="line">$ git branch -d issue-101                                 // 删除issue-101分支</span><br><span class="line">$ git checkout dev                                        // bug 改完了，是时候回到dev继续写bug了</span><br><span class="line">$ git stash list                                          // 查看刚刚的冻结现场</span><br><span class="line">$ git stash pop                                           // git stash pop，恢复的同时把stash内容也删了</span><br><span class="line">                                                          // 或者用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next 主题博客提交百度谷歌收录</title>
    <url>/post/82d92ad4.html</url>
    <content><![CDATA[<blockquote bgcolor="#FF4500">SEO（Search Engine Optimization）：中文译为搜索引擎优化，即利用搜索引擎的规则提高网站搜索引擎内自然排名。主要通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化等方式实现。</blockquote>

<p>主要是给各个搜索引擎提交你的 sitemap，让别人能搜到你博客的内容。<br>先确认博客是否被搜索引擎收录，在百度或者谷歌输入下面格式来判断，如果能搜索到就说明被收录，否则就没有。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">site:写你要搜索的域名 # site:xxx.github.io</span><br></pre></td></tr></table></figure></p>
<h2 id="开启-Next-主题的-SEO-优化项"><a href="#开启-Next-主题的-SEO-优化项" class="headerlink" title="开启 Next 主题的 SEO 优化项"></a>开启 Next 主题的 SEO 优化项</h2><p> Next 提供了 seo 优化选项，在主题配置文件<code>_config.yml</code>中有个选项是<code>seo</code>，设置成<code>true</code>即开启了 seo 优化。<br>百度无法搜索到博客信息，是因为 Github Pages 屏蔽了百度爬虫，所以可以将博客同步到两个平台上，一个 <a href="https://github.com/" target="_blank" rel="noopener">Github</a>，一个国内的 <a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>。</p>
<h2 id="让百度收录博客"><a href="#让百度收录博客" class="headerlink" title="让百度收录博客"></a>让百度收录博客</h2><p>打开<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长平台</a>，注册登陆后，提示要绑定熊掌ID，注册验证绑定熊掌ID。<br>之后在<code>用户中心 &gt; 站点管理</code>下添加网站。根据提示输入站点地址等信息，建议输入的域名为<code>www</code>开头的，不要输入<code>github.io</code>的，因为 github 是不允许百度的 spider 爬取 github 上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名。<br><img src="http://cdn.luanzhuxian.com/blog/seo-baidu-add.png" alt="avatar"></p>
<h3 id="验证站点"><a href="#验证站点" class="headerlink" title="验证站点"></a>验证站点</h3><p>在选择完网站的类型之后需要验证网站的所有权，有三种验证方式，文件验证、html 标签验证、cname 解析验证。<br><img src="http://cdn.luanzhuxian.com/blog/seo-baidu-verify.png" alt="avatar"></p>
<h4 id="1、文件验证"><a href="#1、文件验证" class="headerlink" title="1、文件验证"></a>1、文件验证</h4><ul>
<li>下载验证文件</li>
<li>将验证文件放置于您所配置域名的根目录下，即放在博客的本地根目录的<code>source</code>文件夹下。</li>
<li>控制台输入<code>hexo g -d</code>，部署更新。</li>
<li>根据提示检查是否验证文件可以正常访问</li>
<li>点击完成验证按钮<br><strong>注意：使用文件验证文件存放的位置需要放在 source 文件夹下，如果是 html 文件会被 hexo 编译导致之后验证不通过，所以必须要加上的<code>layout:false</code>，这样就不会被 hexo 编译。（如果验证文件是 txt 格式的就不需要）</strong>  </li>
</ul>
<h4 id="2、HTML-标签验证"><a href="#2、HTML-标签验证" class="headerlink" title="2、HTML 标签验证"></a>2、HTML 标签验证</h4><ul>
<li><p>方法一：打开<code>themes/next/layout/_partials/head.swig</code>文件，将百度站长给你的<code>meta</code>标签添加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot;/&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;/&gt;</span><br><span class="line">&lt;meta name=&quot;theme-color&quot; content=&quot;&#123;&#123; theme.android_chrome_color &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;hDU7MGKZcM&quot; /&gt;  # 此为新添加的</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：打开 Hexo 主题配置文件，按如下修改/添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google_site_verification: #索引擎提供给你的HTML标签的content后的内容</span><br><span class="line">baidu_site_verification: #索引擎提供给你的HTML标签content后的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后控制台输入<code>hexo g -d</code>，部署更新。</p>
</li>
<li>最后点击完成验证按钮  </li>
</ul>
<h4 id="3、cname-解析验证"><a href="#3、cname-解析验证" class="headerlink" title="3、cname 解析验证"></a>3、cname 解析验证</h4><p>只需添加一条解析  </p>
<h3 id="生成-sitemap-站点地图"><a href="#生成-sitemap-站点地图" class="headerlink" title="生成 sitemap 站点地图"></a>生成 sitemap 站点地图</h3><p><blockquote bgcolor="#FF4500">站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知 Google 等搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</blockquote><br>我们需要使用插件自动生成网站的 sitemap，然后将生成的 sitemap 提交到百度和其他搜索引擎。<br>先安装谷歌和百度的插件，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p>
<p>在博客根目录的<code>_config.yml</code>中改<code>url</code>为你的站点地址：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://luanzhuxian.github.io/</span><br><span class="line">root: /</span><br><span class="line"># permalink: :year/:month/:day/:title/</span><br><span class="line">permalink: post/:abbrlink.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p>
<p>在博客根目录的<code>_config.yml</code>中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br></pre></td></tr></table></figure></p>
<p>之后重新打包<code>hexo g -d</code>，若在你的博客根目录的<code>public</code>下面发现生成了<code>sitemap.xml</code>以及<code>baidusitemap.xml</code>就表示成功了，其中<code>sitemap.xml</code>文件是搜索引擎通用的文件，<code>baidusitemap.xml</code>是百度专用的 sitemap 文件。可以通过<code>https://xxx.github.io/baidusitemap.xml</code>查看该文件。</p>
<h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p>之后就可以将生成的 sitemap 文件提交给百度，可加快爬虫抓取速度。<br>还是在百度站长平台，找到<code>网站支持 &gt; 数据引入 &gt; 链接提交</code>。这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和 sitemap。<br>如何选择链接提交方式：</p>
<ul>
<li>自动提交：<ul>
<li>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li>
<li>自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 。</li>
<li>sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</li>
</ul>
</li>
<li>手动提交：在<code>数据引入 &gt; 手动提交</code>下一次性填写链接地址，并提交给百度。  </li>
</ul>
<p>一般主动提交比手动提交效果好，这里介绍主动提交的三种方法。从效率上来说：<code>主动推送&gt;自动推送&gt;sitemap</code>。</p>
<h4 id="1、主动推送"><a href="#1、主动推送" class="headerlink" title="1、主动推送"></a>1、主动推送</h4><p><img src="http://cdn.luanzhuxian.com/blog/seo-baidu-sitemap1.png" alt="avatar"><br>安装插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure></p>
<p>根目录配置文件<code>_config.ym</code>新增字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 100 # 提交最新的一个链接</span><br><span class="line">  host: xxx.github.io # 在百度站长平台中注册的域名</span><br><span class="line">  token: xxxxxx # 秘钥，百度站长平台 &gt; 推送接口 &gt; 接口调用地址中token字段</span><br><span class="line">  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里</span><br><span class="line">  xz_appid: xxxxxx # 你的熊掌号 appid</span><br></pre></td></tr></table></figure></p>
<p>其次，记得查看<code>_config.ym</code>文件中<code>url</code>， 必须是百度站长平台注册的域名（包含www）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://xxx.github.io/</span><br><span class="line">root: /</span><br><span class="line">permalink: post/:abbrlink.html</span><br></pre></td></tr></table></figure></p>
<p>最后，根目录配置文件新增 deploy：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: baidu_url_submitter</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：参考 <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">hexo官网</a> 多个 deploy 时要这样写，前面加横杠：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># You can use multiple deployers. Hexo will execute each deployer in order.</span><br><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">- type: heroku</span><br><span class="line">  repo:</span><br></pre></td></tr></table></figure></p>
<p>这样以后每次执行<code>hexo deploy</code>，链接就会被推送给百度了。</p>
<h4 id="2、自动推送"><a href="#2、自动推送" class="headerlink" title="2、自动推送"></a>2、自动推送</h4><p><img src="http://cdn.luanzhuxian.com/blog/seo-baidu-sitemap2.png" alt="avatar"><br>在主题配置文件下设置，将<code>baidu_push</code>设置为<code>true</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure></p>
<p>然后查看<code>themes/next/layout/_third-party/seo/baidu-push.swig</code>文件中是否包含如下百度提供的自动推送代码，没有的话要添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp = document.createElement(&apos;script&apos;);</span><br><span class="line">    var curProtocol = window.location.protocol.split(&apos;:&apos;)[0];</span><br><span class="line">    if (curProtocol === &apos;https&apos;) &#123;</span><br><span class="line">        bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样每次访问博客中的页面就会自动向百度提交 sitemap。</p>
<h4 id="3、sitemap"><a href="#3、sitemap" class="headerlink" title="3、sitemap"></a>3、sitemap</h4><p><img src="http://cdn.luanzhuxian.com/blog/seo-baidu-sitemap3.png" alt="avatar"><br>将上面生成的 sitemap 文件，填写到<code>请填写数据文件地址</code>下面的文本框，再提交就可以了，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xxx.github.io/sitemap.xml</span><br><span class="line">https://xxx.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure></p>
<h2 id="让谷歌收录博客"><a href="#让谷歌收录博客" class="headerlink" title="让谷歌收录博客"></a>让谷歌收录博客</h2><p><a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">google站点平台</a>，首先登陆注册。之后点击添加资源。<br><img src="http://cdn.luanzhuxian.com/blog/seo-google-add.png" alt="avatar"></p>
<h3 id="验证站点-1"><a href="#验证站点-1" class="headerlink" title="验证站点"></a>验证站点</h3><p><img src="http://cdn.luanzhuxian.com/blog/seo-google-verify1.png" alt="avatar"><br><img src="http://cdn.luanzhuxian.com/blog/seo-google-verify2.png" alt="avatar"><br>有几种验证方法：</p>
<ul>
<li>Domain 网域验证</li>
<li>URL prefix 网址前缀验证，包含以下验证方法：<ul>
<li>HTML file（文件验证）</li>
<li>HTML taghtml（标签验证）</li>
<li>Google Analytics</li>
<li>Google Tag Manager</li>
<li>Google name provider  </li>
</ul>
</li>
</ul>
<p>URL prefix 验证下的，文件验证、标签验证和百度类似，我选的标签验证，在主题配置文件中修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https://www.google.com/webmasters/</span><br><span class="line">google_site_verification: xxxxxxxxxxxxx # 此处改为google提供给你的HTML标签content后的内容</span><br></pre></td></tr></table></figure></p>
<h3 id="提交-sitemap"><a href="#提交-sitemap" class="headerlink" title="提交 sitemap"></a>提交 sitemap</h3><p>打开 <a href="https://search.google.com/search-console/" target="_blank" rel="noopener">google search console</a>，点击左侧<code>sitemap (站点地图)</code>栏，在<code>Add a new sitemap (添加新的站点地图)</code>下面添加，如<code>https://xxx.github.io/sitemap.xml</code>：<br><img src="http://cdn.luanzhuxian.com/blog/seo-google-sitemap.png" alt="avatar"><br>最后在 google 搜索你的站点地址，如：<code>site:xxx.github.io</code>来检查是否收录成功。</p>
<h2 id="添加-robots-txt"><a href="#添加-robots-txt" class="headerlink" title="添加 robots.txt"></a>添加 robots.txt</h2><p><code>robots.txt</code>是搜索引擎蜘蛛协议，告诉引擎哪些要收录，哪些禁止收录。<br><code>source</code>文件夹下新建 robots.txt，内容如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line">Allow: /archives/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://luanzhuxian.github.io/sitemap.xml</span><br><span class="line">Sitemap: https://luanzhuxian.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure></p>
<h2 id="hexo-abbrlink-链接持久化"><a href="#hexo-abbrlink-链接持久化" class="headerlink" title="hexo-abbrlink 链接持久化"></a>hexo-abbrlink 链接持久化</h2><p>大家知道 hexo 默认的链接是 <code>http://xxx.yy.com/2018/07/14/hello-world</code> 这种类型的，这源于站点目录下的配置 <code>_config.yml</code> 里的配置 <code>:permalink: :year/:month/:day/:title/</code>，这种默认配置的缺点就是一般文件名是中文，导致 url 链接里有中文出现，这会造成很多问题，如使用<code>gitment</code>，也不利于 SEO，另外年月日都会有分隔符。<br><code>hexo-abbrlink</code>这个插件，猜测是根据时间点算出的最终链接，这样就确保了博文链接的唯一化，只要不修改 md 文件的<code>abbrlink</code>的值， url 就永久不会改变。如此 md 文件名和文件内容也可以随便改了。后面的层级更短，这样也有利于 SEO 优化。</p>
<ul>
<li><p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<br>站点配置文件里:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: post/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line"> alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line"> rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外可以修改<code>scaffolds</code>里的模版文件，修改<code>post.md</code>为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">comments: true</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p><blockquote bgcolor="#FF4500">百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</blockquote><br>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以<code>permalink</code>后面跟着的最好不要超过2个斜杠。</p>
<h2 id="hexo-autonofollow"><a href="#hexo-autonofollow" class="headerlink" title="hexo-autonofollow"></a>hexo-autonofollow</h2><p>nofollow 标签是由谷歌领头创新的一个反垃圾链接的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。<br>这里推荐 <code>hexo-autonofollow</code> 插件来解决。  </p>
<ul>
<li><p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-autonofollow  --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<br>在站点配置文件中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude: # 例外的链接，可将友情链接放置此处</span><br><span class="line">  - exclude1.com</span><br><span class="line">  - exclude2.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 添加文章时自动打开编辑器</title>
    <url>/post/e7fa2d4f.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中键入以下命令然后回车即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;The title of your blog&quot;</span><br></pre></td></tr></table></figure></p>
<p>此后便会在 Hexo 的根目录的<code>source/_posts</code>目录下自动帮你创建相应的 md 文件。然后我们打开该目录，找到刚刚 Hexo 自动生成的文件打开编辑即可。</p>
<p>但是当我们的博文比较多，这样我们就需要在成堆的 Markdown 文件中找到刚才自动生成的文件，这样做显然是一件比较痛苦的事情。下面介绍一种添加文章时自动打开编辑器的方法。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用 NodeJS 的事件监听机制实现监听 Hexo 的 new 事件来启动编辑器，完成自动启动编辑器的操作。  </p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>首先在 Hexo 目录下的<code>scripts</code>目录中创建一个 JavaScript 脚本文件。</li>
<li>如果没有这个<code>scripts</code>目录，则新建一个。</li>
<li><code>scripts</code>目录新建的 JavaScript 脚本文件可以任意取名。</li>
</ul>
<p>通过这个脚本，我们用其来监听<code>hexo new</code>这个动作，并在检测到<code>hexo new</code>之后，执行编辑器打开的命令。</p>
<p>如果你是 Windows 平台的用户，则将下列内容写入你的脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var spawn = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">  spawn(&apos;start  &quot;markdown编辑器绝对路径.exe&quot; &apos; + path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">  spawn(&apos;start  &quot;markdown编辑器绝对路径.exe&quot; &apos; + data.path)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你是 Mac 平台用户，则将下列内容写入你的脚本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(path)&#123;</span><br><span class="line">    exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + path)</span><br><span class="line">&#125;)</span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on(&apos;new&apos;, function(data)&#123;</span><br><span class="line">    exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + data.path)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>保存并退出脚本之后，在命令行中键入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;auto open editor test&quot;</span><br></pre></td></tr></table></figure></p>
<p>就可以顺利的自动打开自动生成的md文件啦~</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 自动备份博客文件</title>
    <url>/post/a433710c.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次更新博文都需要输入两三行重复的Git命令比较麻烦，下面介绍一种自动备份 Hexo 博客源文件的方法。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过通过监听 Hexo 的事件来完成自动执行Git命令完成自动备份。通过查阅 <a href="https://hexo.io/zh-cn/api/events.html" target="_blank" rel="noopener">Hexo文档</a>，找到了 Hexo 的主要事件，见下表：</p>
<table>
<thead>
<tr>
<th>事件名</th>
<th>事件发生时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>deployBefore</td>
<td>在部署完成前发布</td>
</tr>
<tr>
<td>deployAfter</td>
<td>在部署成功后发布</td>
</tr>
<tr>
<td>exit</td>
<td>在 Hexo 结束前发布</td>
</tr>
<tr>
<td>generateBefore</td>
<td>在静态文件生成前发布</td>
</tr>
<tr>
<td>generateAfter</td>
<td>在静态文件生成后发布</td>
</tr>
<tr>
<td>new</td>
<td>在文章文件建立后发布</td>
</tr>
</tbody>
</table>
<p>于是我们就可以通过监听 Hexo 的<code>deployAfter</code>事件，待上传完成之后自动运行 Git 备份命令，从而达到自动备份的目的。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="删除-Next-主题的-git-缓存文件夹"><a href="#删除-Next-主题的-git-缓存文件夹" class="headerlink" title="删除 Next 主题的 .git 缓存文件夹"></a>删除 Next 主题的 .git 缓存文件夹</h2><p>我们如果要将项目上传到远程仓库，先要<code>git add .</code>添加到暂存区，然后<code>git commit</code>，这时会出现如下报错：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span><br><span class="line">        modified:   themes/xxx</span><br></pre></td></tr></table></figure></p>
<p>并且提交后会发现远程仓库主题文件夹都是空的。因为位于<code>themes</code>文件夹下的主题是从另一个 git 仓库上 clone 过来的，由于你 clone 下来的文件夹也是一个 git 仓库，因此正常的<code>git add .</code>是无法提交该文件夹下的文件的，会和 Hexo 仓库冲突，每次提交只会提交 Hexo 项目的修改，而不会提交 Next 主题的修改。  所以我们要先删除<code>.git缓存文件</code>。  </p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>1、先强行删除 clone 来的主题目录下的 .git 文件夹：<br>在<code>themes/next</code>目录下打开命令行工具，执行<code>rd/s/q .git</code>命令，删除成功后执行<code>ls .git</code>命令提示如下内容说明删除成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls .git</span><br><span class="line">ls: cannot access &apos;.git&apos;: No such file or directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、回到仓库根目录删除已经托管的空主题文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -rf --cached &quot;themes/next&quot;</span><br><span class="line">git commit -m &quot;remove empty folder&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使名为主题目录不再接受版本控制，所以就没有子模块的冲突了。之后上传不会报上面的错。  </p>
<h2 id="将-Hexo-博客源文件上传-Git-仓库"><a href="#将-Hexo-博客源文件上传-Git-仓库" class="headerlink" title="将 Hexo 博客源文件上传 Git 仓库"></a>将 Hexo 博客源文件上传 Git 仓库</h2><p>上传后也可以随时拉取代码，方便更新管理项目。<br>在 Github 下创建一个新的<code>repository</code>，命名与本地的源码文件夹同名即可。<br>进入本地的源码根目录，执行以下命令创建仓库:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p>设置远程仓库地址，并更新：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:用户名/版本库名(xxx/hexo.git)</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p>
<p>修改<code>.gitignore</code>文件（如果没有请手动创建一个）。如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。 .gitignore 的匹配规则：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">build/    # 忽略 build/ 目录下的所有文件</span><br><span class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：若有不该提交的文件已经提交后，仅仅在 .gitignore 中加入忽略是不行的。这个时候需要执行：<code>git rm -r --cached 文件/文件夹名字</code>。</strong>  </p>
<p>在 .gitignore 文件里面加入<code>*.log</code>和 <code>public/</code>以及<code>.deploy*/</code>。因为每次执行<code>hexo generate</code>命令时，上述目录都会被重写更新。因此忽略这两个目录下的文件更新，加快 push 速度。</p>
<p>执行命令以下命令，完成 Hexo 源码在本地的提交，并将本地的仓库文件推送到 Github。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxx&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>这样就可以从其他计算机拉取项目了。</p>
<h2 id="安装-shelljs-模块"><a href="#安装-shelljs-模块" class="headerlink" title="安装 shelljs 模块"></a>安装 shelljs 模块</h2><p>要实现这个自动备份功能，需要依赖 NodeJs 的一个 shelljs 模块，该模块重新包装了<code>child_process</code>，调用系统命令更加的方便。<br>在命令中键入以下命令，完成 shelljs 模块的安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev shelljs</span><br></pre></td></tr></table></figure></p>
<h2 id="编写自动备份脚本"><a href="#编写自动备份脚本" class="headerlink" title="编写自动备份脚本"></a>编写自动备份脚本</h2><p>模块安装完成，在 Hexo 根目录的<code>scripts</code>文件夹下新建一个 js 文件，文件名随意取。（如果没有<code>scripts</code>目录，请新建一个。）<br>然后在脚本中，写入以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require(&apos;shelljs/global&apos;)</span><br><span class="line">const platform = require(&apos;os&apos;).platform()</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份</span><br><span class="line">    run()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(&apos;Error:&apos; + e.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function run () &#123;</span><br><span class="line">  if (!which(&apos;git&apos;)) &#123;</span><br><span class="line">    echo(&apos;Sorry, this script requires git&apos;)</span><br><span class="line">    exit(1)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    echo(&apos;====================== Auto Backup Begin ======================&apos;)</span><br><span class="line">    echo(`====================== Current platform is $&#123;platform&#125; ======================`)</span><br><span class="line"></span><br><span class="line">    if (/^win/.test(platform)) &#123;			</span><br><span class="line">      // windows 环境下项目路径</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cd(&apos;/Users/666/Desktop/code/project/blog&apos;)    // linux 环境下项目路径</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exec(&apos;git add --all&apos;).code !== 0) &#123;</span><br><span class="line">      echo(&apos;Error: Git add failed&apos;)</span><br><span class="line">      exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exec(&apos;git commit -am &quot;Form auto backup script\&apos;s commit&quot;&apos;).code !== 0) &#123;</span><br><span class="line">      echo(&apos;Error: Git commit failed&apos;)</span><br><span class="line">      exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (exec(&apos;git push origin master&apos;).code !== 0) &#123;</span><br><span class="line">      echo(&apos;Error: Git push failed&apos;)</span><br><span class="line">      exit(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    echo(&apos;====================== Auto Backup Complete ======================&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>cd(&#39;/Users/666/Desktop/code/project/Blog&#39;)</code>路径为本地 Hexo 的根目录路径。</li>
<li>如果你的 Git 远程仓库名称不为 origin 的话，还需要修改执行的 push 命令，修改成自己的远程仓库名和相应的分支名。</li>
</ul>
<p>保存脚本并退出，然后执行<code>hexo deploy</code>命令，将会得到类似以下结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Deploy done: git</span><br><span class="line">INFO  Deploying: baidu_url_submitter</span><br><span class="line">INFO  Submitting urls</span><br><span class="line">...省略</span><br><span class="line">INFO  Deploy done: baidu_url_submitter</span><br><span class="line">[master 3db66ca] Form auto backup script&apos;s commit</span><br><span class="line"> 4 files changed, 93 insertions(+), 8 deletions(-)</span><br><span class="line"> create mode 100644 source/_posts/hexo-compress.md</span><br><span class="line">To https://github.com/luanzhuxian/Blog.git</span><br><span class="line">   f7e5190..3db66ca  master -&gt; master</span><br><span class="line">==================Auto Backup Complete============================</span><br></pre></td></tr></table></figure></p>
<p>这样子，每次更新博文并<code>deploy</code>到服务器上之后，备份就自动启动并完成备份啦~</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 发布前压缩</title>
    <url>/post/e5ac3b51.html</url>
    <content><![CDATA[<p>只压缩<code>hexo g</code>生成的<code>public</code>文件夹下的要发布到 Github Page 的源码。  </p>
<p>首先全局安装 <a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp</a>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i gulp -g</span><br></pre></td></tr></table></figure></p>
<p>到项目根目录本地安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i gulp gulp-htmlclean gulp-htmlmin gulp-imagemin gulp-minify-css gulp-uglify --save-dev</span><br></pre></td></tr></table></figure></p>
<p><code>gulp -v</code>查看版本。<br><strong>注意：本文用的是<code>gulp 4 (4.0.2)</code>，安装时注意有没有版本冲突。</strong>  </p>
<p>项目根目录新建<code>gulpfile.js</code>，添加如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var htmlclean = require(&apos;gulp-htmlclean&apos;);</span><br><span class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;);</span><br><span class="line">var cleanCSS = require(&apos;gulp-clean-css&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line">var imagemin = require(&apos;gulp-imagemin&apos;)</span><br><span class="line"></span><br><span class="line">// 压缩 public 目录 html</span><br><span class="line">gulp.task(&apos;minify-html&apos;, function() &#123;</span><br><span class="line">    return gulp.src(&apos;./public/**/*.html&apos;)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true,  //清除HTML注释</span><br><span class="line">            collapseWhitespace: true,  //压缩HTML</span><br><span class="line">            collapseBooleanAttributes: true,  //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input checked /&gt;</span><br><span class="line">            removeEmptyAttributes: true,  //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">            removeScriptTypeAttributes: true,  //删除&lt;script&gt;的type=&quot;text/javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true,  //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;</span><br><span class="line">            minifyJS: true,  //压缩页面JS</span><br><span class="line">            minifyCSS: true  //压缩页面CSS</span><br><span class="line">        &#125;))</span><br><span class="line">        .on(&apos;error&apos;, function(err) &#123;</span><br><span class="line">            console.log(&apos;html Error!&apos;, err.message);</span><br><span class="line">            this.end();</span><br><span class="line">        &#125;)</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩 public 目录 css</span><br><span class="line">gulp.task(&apos;minify-css&apos;, function() &#123;</span><br><span class="line">    return gulp.src(&apos;./public/**/*.css&apos;)</span><br><span class="line">        .pipe(cleanCSS())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩 public 目录 js</span><br><span class="line">gulp.task(&apos;minify-js&apos;, function() &#123;</span><br><span class="line">    return gulp.src(&apos;./public/**/*.js&apos;)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 压缩图片</span><br><span class="line">gulp.task(&apos;images&apos;, function () &#123;</span><br><span class="line">    return gulp.src(&apos;./photos/*.*&apos;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            progressive: true</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;dist/images&apos;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;build&apos;, gulp.series(&apos;minify-html&apos;, &apos;minify-css&apos;, &apos;minify-js&apos;, &apos;images&apos;));</span><br></pre></td></tr></table></figure></p>
<p>终端执行<code>gulp build</code>就会执行<code>gulp.task(&#39;build&#39;, [&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;images&#39;]);</code>任务，即分别压缩<code>public</code>下的<code>html、css、js和图片</code>。<br>之后每次发布前先执行<code>gulp build</code>，再执行<code>hexo deploy</code>，这样提交上线的是压缩后的<code>public</code>下的代码。</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next 添加 Valine 评论功能</title>
    <url>/post/c49d1b87.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于 <a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a> 这家服务提供商，实现 Hexo 博客文章的浏览数统计功能。<br><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 是基于 LeanCloud 的评论系统，评论数据都存储在 LeanCloud 平台，洁面很简洁，没有后台，删除和管理评论只能直接操作数据库。  </p>
<p>本文用的 Next 版本为 5.1.4，已经合并这个功能，相关代码在<code>themes\next\layout\_third-party\comments\valine.swig</code>，可以不用修改主题模版，直接在<code>_config.yml</code>中配置即可。如果低于这个版本的可以考虑升级或者自己手动修改。  </p>
<h1 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a>配置LeanCloud</h1><p>在注册完成 LeanCloud 帐号并验证邮箱之后，我们就可以登录帐号。</p>
<h2 id="1、创建一个开发版应用（免费）："><a href="#1、创建一个开发版应用（免费）：" class="headerlink" title="1、创建一个开发版应用（免费）："></a>1、创建一个开发版应用（免费）：</h2><p><img src="http://cdn.luanzhuxian.com/blog/leancloud-application.png" alt="avatar"></p>
<h2 id="2、设置"><a href="#2、设置" class="headerlink" title="2、设置"></a>2、设置</h2><p>在<code>LeanCloud &gt; 设置 &gt; 安全中心</code>中，把除<code>数据存储</code>外其他选项都关闭。并将你的博客域名添加到<code>Web 安全域名</code>中：<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-setting.png" alt="avatar"></p>
<h2 id="3、创建Class"><a href="#3、创建Class" class="headerlink" title="3、创建Class"></a>3、创建Class</h2><p><strong>Comment 实例在配置好 next 后会自动生成</strong>  </p>
<p>在<code>LeanCloud &gt; 存储 &gt; 创建Class</code>，选择<code>无限制的Class</code>并创建：<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-class.png" alt="avatar"></p>
<h2 id="4、修改next配置"><a href="#4、修改next配置" class="headerlink" title="4、修改next配置"></a>4、修改next配置</h2><p>在<code>LeanCloud &gt; 设置 &gt; 应用 Key</code>中，找到<code>App ID</code>和<code>App Key</code>。之后修改 Next 的配置文件<code>_config.yml</code>如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: xxxxxxxxx  # your leancloud application appid</span><br><span class="line">  appkey: xxxxxxxxx # your leancloud application appkey</span><br><span class="line">  notify: true # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder:  # comment box placeholder</span><br><span class="line">  avatar:  # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure></p>
<ul>
<li>enable: 开启评论功能</li>
<li>appid: leancloud 的 appid</li>
<li>appkey: leancloud 的 appkey</li>
<li>notify: 开启评论提醒，见下文</li>
<li>verify: 评论前开启验证</li>
<li>placeholder: 占位</li>
<li>avatar: 头像，见下文</li>
<li>guest_info: 评论框的 header 内容</li>
<li>pageSize: 分页 </li>
</ul>
<p>之后重新执行<code>hexo g -d</code>就可以看到文章下的评论框了：<br><img src="http://cdn.luanzhuxian.com/blog/comment-view.png" alt="avatar"><br>评论成功后，在相应的表里能看新插入的数据，可以删除编辑：<br><img src="http://cdn.luanzhuxian.com/blog/comment-data.png" alt="avatar"></p>
<h2 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h2><p>可在文章模板<code>scaffolds/post.md</code> 或文章头部中设置<code>comments</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">comments: true</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>在<code>source/categories/index.md</code>和<code>source/tags/index.md</code>里要禁用<code>comments</code>，否则分类和标签页面会显示评论框：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-12-06 22:54:28</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>如果明明有评论，但标题下方的评论数却为0，如图：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/comment_1.png" alt="avatar"></p>
<p>那么打开浏览器调试工具看看这个标签的类名是不是包含<code>valine-comment-count</code>：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/comment_2.png" alt="avatar"></p>
<p>如上如所示，类名是<code>fb-comments-count</code>，说明模板渲染错了。打开<code>themes\next\layout\_macro\post.swig</code>找到下面的部分：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// facebook</span><br><span class="line">&#123;% elseif theme.facebook_comments_plugin.enable %&#125;</span><br><span class="line">  &lt;span class=&quot;post-comments-count&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-comment-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#comments&quot; itemprop=&quot;discussionUrl&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;post-comments-count fb-comments-count&quot; data-href=&quot;&#123;&#123; post.permalink &#125;&#125;&quot; itemprop=&quot;commentCount&quot;&gt;0&lt;/span&gt; comments</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  // 省略。。。。。。</span><br><span class="line"></span><br><span class="line">// valine</span><br><span class="line">&#123;% elseif theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">  &lt;span class=&quot;post-comments-count&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-comment-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#comments&quot; itemprop=&quot;discussionUrl&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;post-comments-count valine-comment-count&quot; data-xid=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; itemprop=&quot;commentCount&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实是根据<code>_config.yml</code>里的主题配置用<code>if...else...</code>来渲染模板。把配置文件里<code>theme.facebook_comments_plugin.enable</code>改为<code>false</code>，则<code>facebook</code>那部分不会渲染：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">facebook_comments_plugin:</span><br><span class="line">  enable:       false</span><br><span class="line">  num_of_posts: 10    # min posts num is 1</span><br><span class="line">  width:        100%  # default width is 550px</span><br><span class="line">  scheme:       light # default scheme is light (light or dark)</span><br></pre></td></tr></table></figure></p>
<p>刷新后<code>valine</code>那部分渲染出来了，可以看到评论数。</p>
<p><img src="http://cdn.luanzhuxian.com/blog/comment_3.png" alt="avatar"></p>
<h1 id="头像配置"><a href="#头像配置" class="headerlink" title="头像配置"></a>头像配置</h1><p>参考 <strong><a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">Valine 评论系统中的头像配置</a></strong>  </p>
<p>上面<code>valine &gt; avatar</code>字段用来设置评论头像，可选值如下:<br><img src="http://cdn.luanzhuxian.com/blog/comment-avatar_1.png" alt="avatar"><br>之后注册登录<a href="https://cn.gravatar.com" target="_blank" rel="noopener">Gravatar</a>，并设置头像<br><img src="http://cdn.luanzhuxian.com/blog/comment-avatar_2.png" alt="avatar"><br>之后在<code>Next</code>配置文件中增加<code>avatar_cdn</code>字段，如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: xxxxxxxxx</span><br><span class="line">  appkey: xxxxxxxxx</span><br><span class="line">  notify: true # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder:  # comment box placeholder</span><br><span class="line">  avatar:  # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  avatar_cdn: https://www.gravatar.com/avatar/</span><br></pre></td></tr></table></figure></p>
<p>之后修改<code>Valine</code>模板文件<code>/themes/next/layout/_third-party/comments/valine.swig</code>，末尾增加<code>avatar_cnd</code>字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Valine(&#123;</span><br><span class="line">    el: &apos;#comments&apos; ,</span><br><span class="line">    verify: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class="line">    notify: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class="line">    appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;,</span><br><span class="line">    appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;,</span><br><span class="line">    placeholder: &apos;&#123;&#123; theme.valine.placeholder &#125;&#125;&apos;,</span><br><span class="line">    avatar:&apos;&#123;&#123; theme.valine.avatar &#125;&#125;&apos;,</span><br><span class="line">    guest_info:guest,</span><br><span class="line">    pageSize:&apos;&#123;&#123; theme.valine.pageSize &#125;&#125;&apos; || 10,</span><br><span class="line">    avatar_cdn:&apos;&#123;&#123; theme.valine.avatar_cdn &#125;&#125;&apos;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>刷新头像变成自定义的了：<br><img src="http://cdn.luanzhuxian.com/blog/comment-avatar_3.png" alt="avatar"></p>
<h1 id="邮件提醒"><a href="#邮件提醒" class="headerlink" title="邮件提醒"></a>邮件提醒</h1><h2 id="1、官方邮件提醒功能"><a href="#1、官方邮件提醒功能" class="headerlink" title="1、官方邮件提醒功能"></a>1、官方邮件提醒功能</h2><p>参考 <strong><a href="https://valine.js.org/notify.html" target="_blank" rel="noopener">Valine 评论系统中的邮件提醒设置</a></strong><br><strong>注意：目前邮件提醒正处于测试阶段，仅在子级对存在邮件地址的父级发表评论时发送邮件</strong>   </p>
<p><code>Valine</code>官方提供的邮件提醒功能是基于<code>Leancloud</code>的密码重置邮件提醒。所以要<code>开启email通知</code>除了修改配置文件<code>valine &gt; notify</code>为<code>true</code>外，还需对<code>LeanCloud &gt; 设置 &gt; 邮件模板 &gt; 用于重置密码的邮件主题</code>进行修改。如下图：<br><img src="http://cdn.luanzhuxian.com/blog/comment-notify_1.png" alt="avatar"><br>可参考以下内容修改并保存，修改后的内容会被插入提醒邮件中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 邮件主题</span><br><span class="line">你在&#123;&#123;appname&#125;&#125;的评论收到了新的回复</span><br><span class="line"></span><br><span class="line">// 内容</span><br><span class="line">&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;https://luanzhuxian.github.io&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<p>之后对一级评论回复并同时填写邮箱的话，就能收到邮件提醒了。<br><img src="http://cdn.luanzhuxian.com/blog/comment-notify_2.png" alt="avatar"></p>
<h2 id="第三方支持"><a href="#第三方支持" class="headerlink" title="第三方支持"></a>第三方支持</h2><p>还可以使用更完善的第三方邮件提醒：<strong><a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">Valine-Admin</a></strong><br><a href="https://deserts.io/valine-admin-document/" target="_blank" rel="noopener">参考</a><br><a href="https://github.98.tn/hexo-valine-admin/" target="_blank" rel="noopener">参考</a>  </p>
<p>其中的设置云引擎的自定义环境变量：</p>
<ul>
<li>SITE_NAME : 网站名称</li>
<li>SITE_URL : 网站地址, 最后不要加 / </li>
<li>SMTP_USER : SMTP 服务用户名，一般为邮箱地址</li>
<li>SMTP_PASS : SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式</li>
<li>SMTP_SERVICE : 邮件服务提供商</li>
<li>SENDER_NAME : 寄件人名称</li>
<li>TO_EMAIL：这个是填收邮件提醒的邮箱地址，若没有这个字段，则将邮件发到 SMTP_USER</li>
<li>TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default </li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next 添加文章阅读量统计</title>
    <url>/post/ec069b41.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于 <a href="https://leancloud.cn" target="_blank" rel="noopener">LeanCloud</a> 这家服务提供商，实现 Hexo 博客文章的浏览数统计功能。  </p>
<p> Next 主题目前已经合并这个功能，相关代码在<code>themes\next\layout\_third-party\analytics\lean-analytics.swig</code>，可以不用修改主题模版，直接在<code>_config.yml</code>中配置即可。</p>
<h2 id="配置LeanCloud"><a href="#配置LeanCloud" class="headerlink" title="配置LeanCloud"></a>配置LeanCloud</h2><p>在注册完成 LeanCloud 帐号并验证邮箱之后，我们就可以登录帐号。</p>
<h3 id="1、创建一个开发版应用（免费）："><a href="#1、创建一个开发版应用（免费）：" class="headerlink" title="1、创建一个开发版应用（免费）："></a>1、创建一个开发版应用（免费）：</h3><p>我们新建一个应用来专门进行博客的访问统计的数据操作。首先，打开控制台点击创建应用：<br><img src="http://cdn.luanzhuxian.com/blog/leancloud.png" alt="avatar"><br>在接下来的页面，新建的应用名称我们可以随意输入，即便是输入的不满意我们后续也是可以更改的：<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-application.png" alt="avatar"></p>
<h3 id="2、设置"><a href="#2、设置" class="headerlink" title="2、设置"></a>2、设置</h3><p>在<code>LeanCloud &gt; 设置 &gt; 安全中心</code>中，<code>服务开关</code>部分只开启<code>数据存储</code>。<br>因为<code>AppID</code>以及<code>AppKey</code>是暴露在外的，为了确保只用于我们自己的博客，建议开启<code>Web安全选项</code>，这样就只能通过我们自己的域名才有权访问后台的数据了，可以进一步提升安全性。<code>Web安全域名</code>下面要添加你的 Github Page 域名，来确保数据调用的安全：<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-setting.png" alt="avatar"></p>
<h3 id="3、创建Class"><a href="#3、创建Class" class="headerlink" title="3、创建Class"></a>3、创建Class</h3><p>在应用的数据配置界面，左侧数据栏下，下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。<br>点击顶部的加号图标<code>新建Class</code>。在弹出的选项中选择<code>创建Class</code>用来专门保存我们博客的文章访问量等数据:<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-class.png" alt="avatar"><br><strong>注意：</strong></p>
<ul>
<li><strong>为了保证我们前面对 NexT 主题的修改兼容，此处的<font color="red">Class名称必须为Counter</font>。</strong></li>
<li><strong>由于 LeanCloud 升级了默认的 ACL 权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择无限制。</strong>  </li>
</ul>
<p>创建完成之后，左侧数据栏应该会多出一栏名为<code>Counter</code>的栏目，这个时候我们点击最左侧菜单栏的设置。<br>在设置界面中，选择左侧的<code>应用Key</code>选项，即可发现我们创建应用的<code>App ID</code>以及<code>App Key</code>，有了它，我们就有权限能够通过主题中配置好的 Javascript 代码与这个应用的<code>Counter表</code>进行数据存取操作了:<br><img src="http://cdn.luanzhuxian.com/blog/leancloud-key.png" alt="avatar"></p>
<h3 id="4、修改next配置"><a href="#4、修改next配置" class="headerlink" title="4、修改next配置"></a>4、修改next配置</h3><p>复制<code>AppID</code>以及<code>AppKey</code>并在 Next 主题的<code>_config.yml</code>文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: xscfkohc1AtS7Px8SMRn4SeR-gzGzoHsz</span><br><span class="line">  app_key: qODRtEtDSVo4Mxj6DkhVAqd9</span><br></pre></td></tr></table></figure></p>
<p>这个时候重新生成部署 Hexo 博客，应该就可以正常使用文章阅读量统计的功能了。需要特别说明的是：记录文章访问量的唯一标识符是文章的发布日期以及文章的标题，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><p>当你配置部分完成之后，初始的文章统计量显示为0，但是这个时候我们 LeanCloud 对应的应用的<code>Counter 表</code>中并没有相应的记录，只是单纯的显示为0而已，当博客文章在配置好阅读量统计服务之后第一次打开时，便会自动向服务器发送数据来创建一条数据，该数据会被记录在对应的应用的<code>Counter表</code>中。</p>
<ul>
<li><code>url</code>字段被当作唯一<code>ID</code>来使用，因此如果你不知道带来的后果的话请不要修改。</li>
<li><code>title</code>字段显示的是博客文章的标题，用于后台管理的时候区分文章之用，没有什么实际作用。</li>
<li>其他字段皆为自动生成，具体作用请查阅 LeanCloud 官方文档，如果你不知道有什么作用请不要随意修改。</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO 主题之 Next 主题</title>
    <url>/post/df6058cd.html</url>
    <content><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我用的是 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a> 主题。<br><strong>注意：我使用的<code>Hexo</code>版本为<code>3.8.0</code>，<code>Next</code>版本为<code>5.1.4</code>，也就是文章是基于上述版本写的。</strong></p>
<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>进入 hexo 站点文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br></pre></td></tr></table></figure></p>
<p>拉取 Next 代码并存放到 themes/next 目录下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p> 修改站点_config.yml 文件主题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── .github            # git信息</span><br><span class="line">├── languages          # 多语言</span><br><span class="line">|   ├── default.yml    # 默认语言</span><br><span class="line">|   └── zh-Hans.yml    # 简体中文</span><br><span class="line">├── layout             # 布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</span><br><span class="line">|   ├── _custom        # 可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── _header.swig    # 头部样式</span><br><span class="line">|   |   ├── _sidebar.swig   # 侧边栏样式</span><br><span class="line">|   ├── _macro        # 可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig    # 文章模板</span><br><span class="line">|   |   ├── reward.swig    # 打赏模板</span><br><span class="line">|   |   ├── sidebar.swig   # 侧边栏模板</span><br><span class="line">|   ├── _partial       # 局部的布局</span><br><span class="line">|   |   ├── head       # 头部模板</span><br><span class="line">|   |   ├── search     # 搜索模板</span><br><span class="line">|   |   ├── share      # 分享模板</span><br><span class="line">|   ├── _script        # 局部的布局</span><br><span class="line">|   ├── _third-party   # 第三方模板</span><br><span class="line">|   ├── _layout.swig   # 主页面模板</span><br><span class="line">|   ├── index.swig     # 主页面模板</span><br><span class="line">|   ├── page           # 页面模板</span><br><span class="line">|   └── tag.swig       # tag模板</span><br><span class="line">├── scripts            # script源码</span><br><span class="line">|   ├── tags           # tags的script源码</span><br><span class="line">|   ├── marge.js       # 页面模板</span><br><span class="line">├── source             # 源码</span><br><span class="line">|   ├── css            # css源码</span><br><span class="line">|   |   ├── _common    # *.styl基础css</span><br><span class="line">|   |   ├── _custom    # *.styl局部css</span><br><span class="line">|   |   └── _mixins    # mixins的css</span><br><span class="line">|   ├── fonts          # 字体</span><br><span class="line">|   ├── images         # 图片</span><br><span class="line">|   ├── js             # javascript源代码</span><br><span class="line">|   └── lib            # 第三方库</span><br><span class="line">├── _config.yml        # 主题配置文件</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>接下来我们就可以来按需配置主题内容了，所有内容都在themes/next文件夹下的config.yml文件里修改。  </p>
<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line"> home: / || home</span><br><span class="line"> # about: /about/ || user</span><br><span class="line"> tags: /tags/ || tags</span><br><span class="line"> categories: /categories/ || th</span><br><span class="line"> archives: /archives/ || archive</span><br><span class="line"> # schedule: /schedule/ || calendar</span><br><span class="line"> # sitemap: /sitemap.xml || sitemap</span><br><span class="line"> # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>如果事先没有通过hexo new page <pagename>来创建页面的话，即使在配置文件中取消注释，页面也没法显示</pagename></li>
<li>|| 后面是fontAwesome里的文件对应的名称</li>
<li>menu_icons记得选enable: true（默认应该是true）</li>
</ul>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>修改主题_config.yml 文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar: http://....  # 头像的URL或路径</span><br></pre></td></tr></table></figure></p>
<h3 id="主题风格"><a href="#主题风格" class="headerlink" title="主题风格"></a>主题风格</h3><p>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure></p>
<h3 id="底部建站时间和图标修改"><a href="#底部建站时间和图标修改" class="headerlink" title="底部建站时间和图标修改"></a>底部建站时间和图标修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2018</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: envira</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used `author` from Hexo main config.</span><br><span class="line">  copyright:</span><br><span class="line">  # -------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    version: false</span><br><span class="line">  #</span><br></pre></td></tr></table></figure>
<p>我在这部分做了这样几件事，使底部信息更简单：</p>
<ul>
<li>把用户的图标从 user 改成了 envira</li>
<li>copyright 留空</li>
<li>powered 设为 false 把 hexo 的授权图片取消了</li>
<li>theme 的 enable 设为 false 把主题的内容也取消了  </li>
</ul>
<p>修改后的footer如下图：<br><img src="http://cdn.luanzhuxian.com/blog/blog-footer.png" alt="avatar"></p>
<h3 id="统计文章字数和阅读时间"><a href="#统计文章字数和阅读时间" class="headerlink" title="统计文章字数和阅读时间"></a>统计文章字数和阅读时间</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: false  # 文章字数</span><br><span class="line">  min2read: false   # 阅读时间</span><br><span class="line">  totalcount: false # 总共字数</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>
<p>我在这里关闭了字数统计，使底部信息更简单  </p>
<h3 id="个人社交信息"><a href="#个人社交信息" class="headerlink" title="个人社交信息"></a>个人社交信息</h3><p>在 social 里我们可以自定义自己想要在个人信息部分展现的账号，同时给他们加上图标。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  E-Mail: mailto:xxx@hotmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br></pre></td></tr></table></figure></p>
<h3 id="博客主页自定义样式修改"><a href="#博客主页自定义样式修改" class="headerlink" title="博客主页自定义样式修改"></a>博客主页自定义样式修改</h3><p>打开博客根目录<code>/themes/next/source/css/_custom/custom.styl</code>文件，修改自己想要的主页样式就可以，会覆盖主题的样式。</p>
<h3 id="修改-html-css"><a href="#修改-html-css" class="headerlink" title="修改 html/css"></a>修改 html/css</h3><p>1、html<br>在<code>themes\next\layout\</code>目录下找到相应的<code>swig</code>文件进行修改。和组件类似，目录下有：<code>page.swig、post.swig、category.swig、tag.swig、header.swig、sidebar.swig...</code><br>比如要修改 sidebar 的结构，可以打开<code>themes\next\layout\_macro\sidebar.swig</code>进行修改。  </p>
<p>2、css<br>在<code>themes\next\source\css\</code>目录下找到相应的<code>styl</code>文件进行修改。<br>例如要修改列表的样式，将列表前的空心圆改成实心，则打开<code>themes\next\source\css\_common\components\post\post-expand.styl</code>修改如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ul li &#123; list-style: disc; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要将分类页列表前的原点去掉，则打开<code>themes\next\source\css\_common\components\pages\categories.styl</code>修改如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.category-list-item &#123;</span><br><span class="line">   margin: 5px 10px;</span><br><span class="line">   list-style: none !important;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加自定义-js-css-文件"><a href="#添加自定义-js-css-文件" class="headerlink" title="添加自定义 js/css 文件"></a>添加自定义 js/css 文件</h3><ul>
<li>首先把<code>js</code>文件放在<code>\themes\next\source\js\src</code>文件目录下</li>
<li>首先把<code>css</code>文件放在<code>\themes\next\source\css\src</code>文件目录下</li>
<li>找到<code>\themes\next\layout</code>目录下的布局文件<code>_layout.swig</code></li>
<li>把引用代码加入到该文件中即可<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/xxx.js&quot;&gt;&lt;/script&gt;</code></li>
<li>也可以在<code>\themes\next\source\css\_custom\custom.styl</code>文件中进行样式的添加</li>
</ul>
<h3 id="网站动画效果"><a href="#网站动画效果" class="headerlink" title="网站动画效果"></a>网站动画效果</h3><p>开关网站的动画。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">motion:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure></p>
<p>主题自带四种动画效果，可以选自己喜欢的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: true</span><br><span class="line"></span><br><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br><span class="line"></span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"></span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"></span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure></p>
<h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><ul>
<li>找<code>16*16</code>与<code>32*32</code>的icon图标，并将图标名称改为<code>favicon16.ico</code>与<code>favicon32.ico</code>。</li>
<li>把图标放在<code>/themes/next/source/images</code>或者放在根目录的<code>/source/images</code>文件夹里。</li>
<li>在主题配置文件<code>_config</code>内搜索<code>favicon</code>字段，把<code>small</code>、<code>medium</code>字段的地址修改为<code>/images/favicon16.ico</code>与<code>/images/favicon32.ico</code>。。</li>
</ul>
<h3 id="网站标题栏背景颜色"><a href="#网站标题栏背景颜色" class="headerlink" title="网站标题栏背景颜色"></a>网站标题栏背景颜色</h3><p>打开<code>themes/next/source/css/_custom/custom.styl</code>，在里面写下如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.site-meta &#123;</span><br><span class="line">  background: #FF0033; //修改为自己喜欢的颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加Fork-me-on-GitHub"><a href="#添加Fork-me-on-GitHub" class="headerlink" title="添加Fork me on GitHub"></a>添加Fork me on GitHub</h3><p>打开 <a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">此链接</a> 挑选自己喜欢的样式，并复制代码，添加到<code>themes\next\layout\_layout.swig</code>的相应标签内即可，记得把<code>&lt;a href=&quot;https://github.com/you&quot;&gt;</code>里面的url换成自己的github地址。最后添加到<code>&lt;main id=&quot;main&quot; class=&quot;main&quot;&gt;</code>标签下，并修改样式，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;main id=&quot;main&quot; class=&quot;main&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;https://github.com/luanzhuxian&quot; style=&quot;display:block; position:absolute; top:3px ; left:0; border:none;&quot;&gt;</span><br><span class="line">    &lt;img width=&quot;149&quot; height=&quot;149&quot; src=&quot;https://github.blog/wp-content/uploads/2008/12/forkme_left_orange_ff7600.png?resize=149%2C149&quot; class=&quot;attachment-full size-full&quot; alt=&quot;Fork me on GitHub&quot; data-recalc-dims=&quot;1&quot;&gt;</span><br><span class="line">  &lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="添加静态背景"><a href="#添加静态背景" class="headerlink" title="添加静态背景"></a>添加静态背景</h3><p>打开博客根目录<code>/themes/next/source/css/_custom/custom.styl</code>文件，编辑如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">body &#123;</span><br><span class="line">    background-image: url(/images/xxx.png); // 动图也可以添加</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动</span><br><span class="line">    background-repeat: repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span><br><span class="line">    background-size: contain; // 等比例铺满屏幕</span><br></pre></td></tr></table></figure></p>
<h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p>在<code>themes\next\layout\_layout.swig</code>文件<code>&lt;/body&gt;</code>标签前添加如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改主题配置文件<code>next/_config.yml</code>如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p>
<h3 id="限制首页显示字数"><a href="#限制首页显示字数" class="headerlink" title="限制首页显示字数"></a>限制首页显示字数</h3><p>博客首页会显示文章的内容（默认显示文章的全部内容），如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简。<br>在主题配置文件中找到<code>auto_excerpt</code>，将<code>enable</code>变为<code>true</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150 #长度可自由调节</span><br></pre></td></tr></table></figure></p>
<h3 id="加载页面顶部显示进度条"><a href="#加载页面顶部显示进度条" class="headerlink" title="加载页面顶部显示进度条"></a>加载页面顶部显示进度条</h3><p>在主题的<code>_config</code>文件，<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">  pace: true</span><br><span class="line">  pace_theme: pace-theme-minimal</span><br></pre></td></tr></table></figure></p>
<h3 id="增加回到顶部按钮及显示当前浏览进度"><a href="#增加回到顶部按钮及显示当前浏览进度" class="headerlink" title="增加回到顶部按钮及显示当前浏览进度"></a>增加回到顶部按钮及显示当前浏览进度</h3><p>主题配置文件搜索<code>b2t</code>字段，改为<code>true</code>即可，（注意此功能只能用于<code>Pisces</code>和<code>Gemini</code>主题）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Back to top in sidebar (only for Pisces | Gemini).</span><br><span class="line">  b2t: true</span><br><span class="line"></span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  # scrollpercent字段设置为true即可实现当前浏览进度的显示。</span><br><span class="line">  scrollpercent: true</span><br><span class="line"></span><br><span class="line">  # Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">  onmobile: true</span><br></pre></td></tr></table></figure></p>
<h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><p>首先文章要有标题，所谓标题就是例如这种一级标题(#)，二级标题(##)，三级标题(###)的。<br>在主题的<code>_config</code>文件里面，将<code>toc</code>的<code>enable</code>设置为<code>true</code>，默认的目录是有序号的，如果你不想要序号，你需要把<code>number</code>置为<code>false</code> 。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Table Of Contents in the Sidebar</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  number: true</span><br><span class="line">  wrap: false</span><br></pre></td></tr></table></figure></p>
<h3 id="增加本地搜索功能"><a href="#增加本地搜索功能" class="headerlink" title="增加本地搜索功能"></a>增加本地搜索功能</h3><p>首先安装插件，根目录命令行输入:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p>
<p>编辑博客配置文件，新增以下内容到任意位置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<p>主题配置文件搜索local_search字段，设置enable为true<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
<p>开启此功能成功后，在博客菜单栏会多一项搜索，点击后即可搜索</p>
<h3 id="添加图片懒加载"><a href="#添加图片懒加载" class="headerlink" title="添加图片懒加载"></a>添加图片懒加载</h3><p>博客根目录打开命令输入（若主题已包含则不用安装）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-jquery-lazyload themes/next/source/lib/jquery_lazyload</span><br></pre></td></tr></table></figure></p>
<p>然后在配置文件中搜索<code>lazyload</code>,将其修改为true<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Added switch option for separated repo in 6.0.0.</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-jquery-lazyload</span><br><span class="line">lazyload: true</span><br></pre></td></tr></table></figure></p>
<p>但是开启<code>lazyload</code>后博客的所有文字内容都无法加载，不知为何原因，所以我没有启用懒加载</p>
<h3 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h3><p><a href="http://www.luanzhuxian.com/post/c49d1b87.html">Hexo + Next添加 Valine 评论功能</a>  </p>
<h3 id="统计阅读次数"><a href="#统计阅读次数" class="headerlink" title="统计阅读次数"></a>统计阅读次数</h3><p><a href="http://www.luanzhuxian.com/post/ec069b41.html">Hexo + Next添加文章阅读量统计</a>  </p>
<h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p><a href="http://www.luanzhuxian.com/post/82d92ad4.html">Hexo + Next主题博客提交百度谷歌收录</a>  </p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><a href="http://www.luanzhuxian.com/post/e5ac3b51.html">使用 Gulp 压缩 Hexo</a>  </p>
<h3 id="增加七牛图床"><a href="#增加七牛图床" class="headerlink" title="增加七牛图床"></a>增加七牛图床</h3><p>将图片上传至七牛，然后获得外链，在我们使用markdown写博客的时候直接插入外链。还可以直接获取带水印、压缩、剪裁过后的图片。  </p>
<p>首先打开 <a href="https://portal.qiniu.com/" target="_blank" rel="noopener">七牛</a>，注册登录，实名认证。<br>之后在左侧找到对象存储，第一次要新建存储空间：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/qiniu-space.png" alt="avatar"></p>
<p>之后在该<code>存储空间 &gt; 内容管理 &gt; 上传文件</code>上传图片：</p>
<p><img src="http://cdn.luanzhuxian.com/blog/qiniu-uplpad.png" alt="avatar"></p>
<p>上传后可以在<code>存储空间 &gt; 内容管理</code>图片列表管理图片，还可以找到图片的外链，之前可以直接使用，现在不行了，必须要绑定已备案的域名。具体可以看我另一篇文章：  </p>
<p><a href="https://www.luanzhuxian.com/post/a13d0f96.html">Github Page 添加自定义域名 + 开启 HTTPS + 支持七牛云图片</a>  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/qiniu-list.png" alt="avatar"></p>
<p>另外在图片样式下可以对图片进行处理，比如缩放、裁剪、增加水印、设置输出格式等。使用时只要在图片外链后加上设置的样式分隔符和样式名称，即可得到处理后的图片。  </p>
<p><img src="http://cdn.luanzhuxian.com/blog/qiniu-style.png" alt="avatar"></p>
<h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><h3 id="hexo-douban"><a href="#hexo-douban" class="headerlink" title="hexo-douban"></a>hexo-douban</h3><p><a href="https://github.com/mythsman/hexo-douban" target="_blank" rel="noopener"><code>hexo-douban</code></a> 插件可以在博客中添加豆瓣电影、读书和游戏页面，关联我们自己的账号。  </p>
<ul>
<li><p>安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置：<br>在 hexo 根目录下的 config.yml 文件中添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: 你的豆瓣userid</span><br><span class="line">  builtin: false</span><br><span class="line">  book:</span><br><span class="line">    title: &apos;This is my book title&apos;</span><br><span class="line">    quote: &apos;This is my book quote&apos;</span><br><span class="line">  movie:</span><br><span class="line">    title: &apos;This is my movie title&apos;</span><br><span class="line">    quote: &apos;This is my movie quote&apos;</span><br><span class="line">  game:</span><br><span class="line">    title: &apos;This is my game title&apos;</span><br><span class="line">    quote: &apos;This is my game quote&apos;</span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>title 和 quote 后面的内容会分别作为电影/读书/游戏页面的标题和副标题（引言）呈现在博客里。<br>user 就写我们豆瓣的 id，可以在我的豆瓣页面中找到。builtin 指是否将生成页面功能嵌入 hexo s 和 hexo g 中，建议选 false，因为true会导致页面每次启动本地服务器都需要很长时间生成豆瓣页面。  </p>
<ul>
<li><p>生成页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo douban   # 生成读书、电影、游戏三个页面</span><br><span class="line">hexo douban -b  # 生成读书页面</span><br><span class="line">hexo douban -m  # 生成电影页面</span><br><span class="line">hexo douban -g  # 生成游戏页面</span><br></pre></td></tr></table></figure>
</li>
<li><p>在博客中生成页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page books</span><br><span class="line">hexo new page movies</span><br><span class="line">hexo new page games</span><br></pre></td></tr></table></figure>
</li>
<li><p>在博客中添加页面：<br>在menu部分添加我们需要添加的页面名称和相对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories/</span><br><span class="line">  archives: /archives/</span><br><span class="line">  Books: /books/     # This is your books page</span><br><span class="line">  Movies: /movies/   # This is your movies page</span><br><span class="line">  Games: /games/     # This is your games page</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客</title>
    <url>/post/73f1724d.html</url>
    <content><![CDATA[<blockquote bgcolor="#FF4500"><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页</blockquote>

<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h3><p>作用：用来做博客的远程创库、域名、服务器<br><a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册账号。</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>作用：用来生成静态页面的<br><a href="https://nodejs.org/" target="_blank" rel="noopener">官网下载</a>并安装。安装成功后可用 <code>node -v</code> 查看版本号。</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>作用：把本地的 Hexo 内容提交到 Github 上去<br>Mac 安装 Xcode 自带有 Git，WSindows 可去<a href="https://git-scm.com/" target="_blank" rel="noopener">官网下载</a>。<br>安装完成后，还需要设置你 Github 的用户名密码，在命令行输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>因为 Git 是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和 Email 地址。安装成功后可用 <code>git --version</code> 查看版本号。</p>
<h2 id="安装并本地部署Hexo"><a href="#安装并本地部署Hexo" class="headerlink" title="安装并本地部署Hexo"></a>安装并本地部署Hexo</h2><p>执行如下命令安装 Hexo<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>创建一个文件夹，用来存放 Hexo 的配置文件，进入该文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>现在项目根目录结构如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── public // 执行 hexo generate 命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds // 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件</span><br><span class="line">├── scripts // 存放自定义 javascript 脚本</span><br><span class="line">├── source // 存放用户资源的地方</span><br><span class="line">|   ├── _drafts // 草稿文章</span><br><span class="line">|   └── _posts // 发布文章</span><br><span class="line">├── themes // 存放博客的主题，Hexo会根据主题来生成静态页面</span><br><span class="line">├── _config.yml // 博客的配置信息，你可以在此配置大部分的参数</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></p>
<p>生成静态页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p>
<p>启动本地服务，打开浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p>
<h2 id="将博客托管到Github"><a href="#将博客托管到Github" class="headerlink" title="将博客托管到Github"></a>将博客托管到Github</h2><h3 id="配置-SSH-Key，将本地目录与-Github-关联"><a href="#配置-SSH-Key，将本地目录与-Github-关联" class="headerlink" title="配置 SSH Key，将本地目录与 Github 关联"></a>配置 SSH Key，将本地目录与 Github 关联</h3><p>配置SSH Key是让本地 git 项目与远程仓库建立联系。SSH Keys不配置的话每次项目有改动提交的时候就要手动输入账号密码，配置了就不需要了。   </p>
<p>首先检查是否已经有SSH Key<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></p>
<p>如果没有目录.ssh，则要生成一个新的SSH Key，执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your e-mail&quot;</span><br></pre></td></tr></table></figure></p>
<p>接下来几步都直接按回车键，然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。  </p>
<p>成功后进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></p>
<p>打开id_rsa.pub文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>复制SSH Key后，去 github 的 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a> 页面配置，将其添加到Add SSH Key里。  </p>
<h3 id="测试-SSH-Key-是否配置成功"><a href="#测试-SSH-Key-是否配置成功" class="headerlink" title="测试 SSH Key 是否配置成功"></a>测试 SSH Key 是否配置成功</h3><p>执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如配置了密码则要输入密码，输完按回车。如果显示以下内容，则说明Github中的 ssh 配置成功。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi username! You have successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure></p>
<h3 id="创建仓库-Github-Pages"><a href="#创建仓库-Github-Pages" class="headerlink" title="创建仓库 Github Pages"></a>创建仓库 Github Pages</h3><blockquote bgcolor="#FF4500">GitHub Pages 分两种，一种是你的 GitHub 用户名建立的 username.github.io 这样的用户/组织页，另一种是依附项目的pages。想建立个人博客是用的第一种，每个用户名下面只能建立一个。</blockquote>

<p>登陆Github官网成功后，新建 New repository，建立与你github用户名对应的仓库，仓库名必须为 your_user_name.github.io  </p>
<h3 id="修改Hexo的-config-yml文件"><a href="#修改Hexo的-config-yml文件" class="headerlink" title="修改Hexo的_config.yml文件"></a>修改Hexo的<code>_config.yml</code>文件</h3><p>根目录<code>_config.yml</code>是博客的配置文件，以后修改博客会用到。  </p>
<p>现在我们需要修改<code>_config.yml</code>文件，来建立关联，执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure></p>
<p>找到相应部分并修改：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git,master # yourname替换成你的Github账户名</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：在<code>yml</code>文件中，冒号后面都是要带空格的</strong></p>
<h3 id="将博客项目上传到仓库"><a href="#将博客项目上传到仓库" class="headerlink" title="将博客项目上传到仓库"></a>将博客项目上传到仓库</h3><p>然后执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>然后执行命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g #生成静态网页</span><br><span class="line"></span><br><span class="line">hexo d #部署到远程仓库</span><br></pre></td></tr></table></figure></p>
<p>此时，通过访问 <a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 可以看到默认的 Hexo 首页</p>
<p>每次部署的命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">或者 hexo g -d</span><br></pre></td></tr></table></figure></p>
<p>一些常用命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line"></span><br><span class="line">hexo new page &quot;pageName&quot; # 新建页面</span><br><span class="line"></span><br><span class="line">hexo generate # 生成静态页面至public目录，markdown转html</span><br><span class="line"></span><br><span class="line">hexo server # 开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line"></span><br><span class="line">hexo deploy # 将.deploy目录部署到GitHub</span><br><span class="line"></span><br><span class="line">hexo clean # 清楚public文件夹，清除缓存数据</span><br><span class="line"></span><br><span class="line">hexo help # 查看帮助</span><br><span class="line"></span><br><span class="line">hexo version # 查看Hexo的版本</span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate</span><br><span class="line"></span><br><span class="line">hexo s == hexo server</span><br><span class="line"></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p>
<h2 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h2><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>新建一个页面，命名为 categories<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></p>
<p>在 source 目录下会生成 categories 目录，修改 source/categories 目录的 index.md :<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-12-06 22:54:28</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>在主题的_config.yml 中取消注释:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories: /categories</span><br></pre></td></tr></table></figure></p>
<p>给模板添加分类属性，打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure></p>
<p>给文章添加分类，在要分类的文章顶部加入 category 属性，值为某个分类名:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line">date: 2018-12-09 17:46:34</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><p>新建一个页面，命名为 tags<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></p>
<p>在 source 目录下会生成 tags 目录，修改 source/tags 目录的 index.md :<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-12-06 22:54:28</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>在主题的_config.yml 中取消注释:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags: /tags</span><br></pre></td></tr></table></figure></p>
<p>以后写文章时，在要分类的文章顶部加入 tags 属性，值为标签名:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: [a, b]      # 添加a和b两个标签</span><br><span class="line">date: 2018-12-09 17:46:34</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>上面是数组的形式，下面是短横线的形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line">date: 2018-12-09 17:46:34</span><br><span class="line">tags:</span><br><span class="line">- node.js</span><br><span class="line">- express</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h2 id="头部设置"><a href="#头部设置" class="headerlink" title="头部设置"></a>头部设置</h2><p>在博客文章的开头会有对文章的说明文字，叫做文章头部，文章的头部除了可以设置文章标题、书写日期等基础信息外，还可以对文章添加标签、分类等，一个简单的示例如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Title # 标题</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS # 文件建立日期</span><br><span class="line">tags: # 标签（不适用于分页）</span><br><span class="line">- 标签1</span><br><span class="line">- 标签2</span><br><span class="line">categories: # 分类（不适用于分页）</span><br><span class="line">- 分类1</span><br><span class="line">- 分类2</span><br><span class="line">layout: # 布局</span><br><span class="line">updated: YYYY-MM-DD HH:MM:SS # 文件更新日期</span><br><span class="line">comments：true # 开启文章的评论功能</span><br><span class="line">permalink：# 覆盖文章网址</span><br><span class="line">abbrlink：# 覆盖文章网址</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
