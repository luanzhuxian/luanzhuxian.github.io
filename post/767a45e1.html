<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta name="baidu-site-verification" content="hDU7MGKZcM"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="nqN9EwI9Vtq3CuJ37FtbIQ_4ufw6-aAGD8ERKGcyEbM"><meta name="baidu-site-verification" content="hDU7MGKZcM"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet"><link href="/css/main.css?v=5.1.4" rel="stylesheet"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="javascript,"><meta name="description" content="执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执"><meta name="keywords" content="javascript"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript 中的执行栈、执行上下文和作用域"><meta property="og:url" content="http://www.luanzhuxian.com/post/767a45e1.html"><meta property="og:site_name" content="栾铸显的博客"><meta property="og:description" content="执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_1.png"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_2.png"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_3.png"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_4.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_5.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_6.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_11.jpg"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_12.jpg"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_13.png"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_9.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_10.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_7.gif"><meta property="og:image" content="http://cdn.luanzhuxian.com/blog/execution-context_8.gif"><meta property="og:updated_time" content="2020-11-14T02:08:54.947Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaScript 中的执行栈、执行上下文和作用域"><meta name="twitter:description" content="执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执"><meta name="twitter:image" content="http://cdn.luanzhuxian.com/blog/execution-context_1.png"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.luanzhuxian.com/post/767a45e1.html"><title>JavaScript 中的执行栈、执行上下文和作用域 | 栾铸显的博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">栾铸显的博客</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">No road to follow</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><a href="https://github.com/luanzhuxian" style="display:none;position:absolute;top:3px;left:0;border:none"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.luanzhuxian.com/post/767a45e1.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="栾铸显的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">JavaScript 中的执行栈、执行上下文和作用域</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T14:11:31+08:00">2019-05-09</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/post/767a45e1.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/767a45e1.html" itemprop="commentCount"></span></a></span> <span id="/post/767a45e1.html" class="leancloud_visitors" data-flag-title="JavaScript 中的执行栈、执行上下文和作用域"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>首次运行 JS 代码时，会创建一个全局执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并 Push 到当前执行栈的栈顶。<br>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的下一个执行上下文。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;Hello World!&apos;;</span><br><span class="line"></span><br><span class="line">function first() &#123;  </span><br><span class="line">  console.log(&apos;Inside first function&apos;);  </span><br><span class="line">  second();  </span><br><span class="line">  console.log(&apos;Again inside first function&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;  </span><br><span class="line">  console.log(&apos;Inside second function&apos;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first();  </span><br><span class="line">console.log(&apos;Inside Global Execution Context&apos;);</span><br><span class="line"></span><br><span class="line">// Inside first function</span><br><span class="line">// Inside second function</span><br><span class="line">// Again inside first function</span><br><span class="line">// Inside Global Execution Context</span><br></pre></td></tr></table></figure><p></p><h1 id="执行上下文（execution-context）"><a href="#执行上下文（execution-context）" class="headerlink" title="执行上下文（execution context）"></a>执行上下文（execution context）</h1><p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。帮助 JavaScript 引擎管理整个解析和运行代码的复杂过程。<br>执行上下文是在代码运行的时候确定的，是可以改变的。</p><h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>分为全局执行上下文和函数执行上下文。</p><h3 id="1-全局执行上下文"><a href="#1-全局执行上下文" class="headerlink" title="1. 全局执行上下文"></a>1. 全局执行上下文</h3><p>Javascript 引擎首次开始解析代码时创建。只有一个。<br>最初，这个全局上下文由一个全局对象和一个 this 变量组成。浏览器中的全局对象就是 window 对象，Node 环境中是 global 对象，this 指向这个全局对象。<br>即使没有任何代码，全局执行上下文中仍然有 window 和 this。这就是最基本的全局执行上下文：<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_1.png" alt="avatar"><br>让我们看看添加了代码会怎么样：<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_2.png" alt="avatar"><br><img src="http://cdn.luanzhuxian.com/blog/execution-context_3.png" alt="avatar"><br>能看出上面两张图的区别吗？关键在于每个执行上下文有两个独立的阶段，一个是创建阶段，一个是执行阶段，每个阶段都有其各自职责。</p><p>在全局执行上下文的创建阶段，Javascript 引擎会：</p><ol><li>创建一个全局对象；</li><li>创建 this 对象；</li><li>给变量和函数分配内存；</li><li>给变量赋默认值 undefined，把所有函数声明放进内存。</li></ol><p>直到执行阶段，Javascript 引擎才会一行一行地运行你的代码并执行它们。</p><h3 id="2-函数执行上下文"><a href="#2-函数执行上下文" class="headerlink" title="2. 函数执行上下文"></a>2. 函数执行上下文</h3><p><strong>只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</strong>。存在无数个。</p><p>在函数执行上下文的创建阶段，Javascript 引擎会：</p><ol><li>创建一个 arguments 对象；</li><li>创建 this 对象；</li><li>给变量和函数分配内存；</li><li>给变量赋默认值 undefined，把所有函数声明放进内存。</li></ol><p>让我们回过头看看之前的代码，但这次我们不仅仅定义 getUser，还要调用一次，看看实际效果是什么。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_4.gif" alt="avatar"><br>当调用了 getUser，就创建了新的执行上下文。在 getUser 执行上下文的创建阶段的创建阶段，Javascript 引擎创建了 this 对象和 arguments 对象。getUser 没有任何变量，所以 Javascript 引擎不需要再次分配内存或进行提升。</p><p>你可能注意到了，当 getUser 函数执行完毕，它就从视图中消失了。事实上，Javascript 引擎创建了一个叫 执行栈（调用栈）的东西。每当函数被调用，就创建一个新的执行上下文并把它加入到调用栈；每当一个函数运行完毕，就被从调用栈中弹出来。因为 Javascript 是单线程的，每一个新的执行上下文都嵌套在另一个中，形成了调用栈。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_5.gif" alt="avatar"></p><p>我们来改写之前的代码，让函数拥有局部变量。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_6.gif" alt="avatar"><br>这里有几处重要细节需要注意。<br>首先，传入函数的所有参数都作为局部变量存在于该函数的执行上下文中。在例子中，handle 同时存在与全局执行上下文和 getURL 执行上下文中，因为我们把它传入了 getURL 函数做为参数。<br>其次，在函数中声明的变量存在于函数的执行上下文中。所以当我们创建 twitterURL，它就会存于 getURL 执行上下文中。这看起来显而易见，但却是<code>作用域</code>的基础。</p><h3 id="3-Eval-函数执行上下文"><a href="#3-Eval-函数执行上下文" class="headerlink" title="3. Eval 函数执行上下文"></a>3. Eval 函数执行上下文</h3><p>指的是运行在 eval 函数中的代码，很少用而且不建议使用。<br><br></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：创建阶段、执行阶段。</p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><blockquote bgcolor="#FF4500">JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</blockquote><p><br>先看看执行上下文包含的内容。An execution context has the following fields:<br>Environments: LexicalEnvironment and VariableEnvironment are what keep track of variables during runtime. Two references to environments. Both are usually the same.</p><ul><li>LexicalEnvironment (lookup and change existing): resolve identifiers.</li><li>VariableEnvironment (add new): hold bindings made by variable declarations and function declarations.</li><li>ThisBinding: the current value of this.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,     // 确定this</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,   // 词法环境</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,  // 变量环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-确定-this-的值（This-Binding）"><a href="#1-确定-this-的值（This-Binding）" class="headerlink" title="1. 确定 this 的值（This Binding）"></a>1. 确定 this 的值（This Binding）</h4><ul><li>全局执行上下文中，this 的值指向全局对象。</li><li>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定、new 绑定、箭头函数。</li></ul><h4 id="2-创建词法环境（Lexical-Environment）"><a href="#2-创建词法环境（Lexical-Environment）" class="headerlink" title="2. 创建词法环境（Lexical Environment）"></a>2. 创建词法环境（Lexical Environment）</h4><blockquote bgcolor="#FF4500" style="margin-bottom:30px"><strong>Lexical environments</strong> hold variables and parameters. The currently active environment is managed via a stack of execution contexts (which grows and shrinks in sync with the call stack). Nested scopes are handled by chaining environments: each environment points to its outer environment (whose scope surrounds its scope). In order to enable lexical scoping, functions remember the scope (=environment) they were defined in. When a function is invoked, a new environment is created for it’s arguments and local variables. That environment’s outer environment is the function’s scope.</blockquote><p>在规范中作用域更官方的叫法是词法环境，词法环境是 JavaScript 作用域的内部实现机制。<br>词法环境有三种类型：</p><ul><li>全局环境（Global Environment）：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</li><li>函数环境（Function Environment）：用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code>对象。其外部环境可以是全局环境，也可以是包含内部函数的外部函数环境。</li><li>模块环境（Module Environment）：每个模块有自己的词法环境，存储了包括<code>imports</code>在内的所有的<code>top-level declarations</code>。其外部环境引用为全局环境。</li></ul><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_11.jpg" alt="avatar"></p><p><strong>Data Structures：A (lexical) environment is the following data structure</strong><br>每种词法环境由两部分组成：一个<code>Environment Record</code>，还有一个指向外层<code>Lexical Environment</code>的可空引用。</p><ul><li><strong>环境记录（Environment Record）：</strong>An environment record maps identifiers to value. that maps variable names to variable values. This is where JavaScript stores variables. One key-value entry in the environment record is called a binding. 存储变量、函数声明的实际位置。它包括3个子类：<ul><li><strong>Declarative Environment Record：</strong>store the effects of variable declarations, and function declarations.</li><li><strong>Object Environment Record：</strong>are used by the with statement and for the global environment. They turn an object into an environment. For with, that is the argument of the statement. For the global environment, that is the global object.</li><li><strong>Global Environment Record</strong></li></ul></li><li><strong>对外部环境的引用：</strong>A reference to the outer environment (null in the global environment) - the environment representing the outer scope of the scope represented by the current environment. 可以访问其外部词法环境。</li></ul><p>其中<code>Declarative Environment Record</code>又有两个子类：<code>Function Environment Records</code>和<code>Module Environment Records</code>。<br><img src="http://cdn.luanzhuxian.com/blog/execution-context_12.jpg" alt="avatar"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;     // 全局执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;    	  // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;   		// 环境记录</span><br><span class="line">      Type: &quot;Object&quot;,      		// 全局环境</span><br><span class="line">      outer: &lt;null&gt;  	   		  // 对外部环境的引用</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;      // 函数执行上下文</span><br><span class="line">  LexicalEnvironment: &#123;  	       // 词法环境</span><br><span class="line">    EnvironmentRecord: &#123;  		   // 环境记录</span><br><span class="line">      Type: &quot;Declarative&quot;,  	   // 函数环境</span><br><span class="line">      outer: &lt;Global or outer function environment reference&gt;  // 对外部环境的引用</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建变量环境（Variable-Environment）"><a href="#3-创建变量环境（Variable-Environment）" class="headerlink" title="3. 创建变量环境（Variable Environment）"></a>3. 创建变量环境（Variable Environment）</h4><p>变量环境也是一个词法环境，variable environment is a certain type of lexical environment，因此它具有上面定义的词法环境的所有属性。<br>在 ES6 中，<code>词法环境</code>和<code>变量环境</code>的区别在于前者用于存储<code>函数声明和变量（let const）</code>绑定，而后者仅用于存储<code>变量（var）</code>绑定。</p><p>例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = 20</span><br><span class="line">const b = 30</span><br><span class="line">var c</span><br><span class="line"></span><br><span class="line">function multiply(e, f) &#123;  </span><br><span class="line"> var g = 20</span><br><span class="line"> return e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(20, 30)</span><br></pre></td></tr></table></figure><p></p><p>执行上下文如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 全局执行上下文</span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  // 词法环境</span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 变量环境</span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      c: undefined</span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数执行上下文，函数被调用的时候才会被创建</span><br><span class="line">FunctionExectionContext = &#123;  </span><br><span class="line"></span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>此阶段，完成对所有变量的分配，最后执行代码。<br>如果 Javascript 引擎在源代码中声明的实际位置找不到 let 变量的值，那么将为其分配 undefined 值。</p><h3 id="LexicalEnvironment-和-VariableEnvironment-的区别"><a href="#LexicalEnvironment-和-VariableEnvironment-的区别" class="headerlink" title="LexicalEnvironment 和 VariableEnvironment 的区别"></a>LexicalEnvironment 和 VariableEnvironment 的区别</h3><p>Both are usually the same. The following explain situations where they diverge.</p><p><strong>Handling temporary scopes via LexicalEnvironment and VariableEnvironment：</strong></p><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_13.png" alt="avatar"><br>LexicalEnvironment and VariableEnvironment are always the same, except in one case: When there is a dominant outer scope and one temporarily wants to enter an inner scope. In the inner scope, a few new bindings should be accessible, but all new bindings made inside of it should be added to the outer scope. This is done as follows:</p><ul><li>LexicalEnvironment temporarily points to a new environment that has been put in front of the old LexicalEnvironment. The new environment holds the temporary bindings of the inner scope.</li><li>VariableEnvironment does not change its value and is thus still the same as the old LexicalEnvironment, denoting the outer scope. New bindings are added here and will also be found when doing a lookup via LexicalEnvironment, because the latter comes before the former in the environment chain.</li><li>After leaving the temporary scope, LexicalEnvironment’s old value is restored and it is again the same as VariableEnvironment.</li></ul><p>These differences matter for with statements and catch clauses, which create temporary scopes. In both cases, the dominant scope is the surrounding function.</p><ul><li>with statement: the object that is the argument of the statement becomes a temporary environment.</li><li>catch clause: the exception that is the argument of this clause is made available via a temporary environment.</li></ul><p>举个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function do_something() &#123;</span><br><span class="line">    let b = 2</span><br><span class="line">    var a = 1</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        var c = 3</span><br><span class="line">        let d = 4</span><br><span class="line">        console.log(b)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">do_something()</span><br></pre></td></tr></table></figure><p></p><p>当调用该方法时，创建了一个<code>ExecutionContext</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">    LexicalEnvironment:</span><br><span class="line">        b: &lt; uninitialized &gt;,</span><br><span class="line">        outer: VariableEnvironment</span><br><span class="line">    VariableEnvironment:</span><br><span class="line">        a: undefined,</span><br><span class="line">        c: undefined, // 变量提升</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p></p><p>当今图<code>while循环</code>时创建了一个新的<code>LexicalEnvironment</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">    LexicalEnvironment:</span><br><span class="line">        d: &lt; uninitialized &gt;,</span><br><span class="line">        outer: &lt;LexicalEnvironment&gt;</span><br><span class="line">                b: 2</span><br><span class="line">                outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    VariableEnvironment:</span><br><span class="line">        a: 1,</span><br><span class="line">        c: undefined, // 变量提升</span><br><span class="line">        outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p></p><p>Now when we look up variables, we can always fall back on whatever is contained in outer.<br>当<code>while block</code>结束，我们恢复 <code>LexicalEnvironment</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext:</span><br><span class="line">      LexicalEnvironment:</span><br><span class="line">          b: 2,</span><br><span class="line">          outer: GlobalLexicalEnvironment</span><br><span class="line">      VariableEnvironment:</span><br><span class="line">          a: 1,</span><br><span class="line">          c: 3,</span><br><span class="line">          outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p></p><p>无法访问到 d 了。所以当<code>while</code>循环结束后，它的<code>execution context</code>被销毁。<br><br></p><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><p>在创建阶段，函数声明存储在环境中，而变量会被设置为 undefined（在 var 的情况下）或保持未初始化（在 let 和 const 的情况下）。所以这就是为什么可以在声明之前访问 var 定义的变量（尽管是 undefined ），但如果在声明之前访问 let 和 const 定义的变量就会提示引用错误的原因。这就是所谓的变量提升。</p><h1 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h1><p>作用域指的是代码中特定变量的有效范围，规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript采用静态作用域。代码写在哪里作用域就在哪里确定，函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。作用域确定了就不会再变化。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>这就带来一个问题，要是当前执行上下文里没有要找的变量呢？Javascript 会就此罢手吗？下面的例子里有答案。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name=&apos;Tyler&apos;</span><br><span class="line">function logName() &#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">logName()</span><br></pre></td></tr></table></figure><p></p><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_9.gif" alt="avatar"><br>如果 Javascript 引擎在函数执行上下文找不到匹配的局部变量，它会到最接近的父级上下文中查找。这条查找链会一直延伸到全局执行上下文。如果此时仍然找不到该变量，Javascript 引擎就会抛出一个引用错误。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>之前我们了解到函数中创建的变量仅局部有效，一旦函数执行上下文从调用栈弹出，这些变量就访问不到了。<br>如果你在一个函数中嵌入了另一个函数，情况就变了。这种函数套函数的情况下，即使父级函数的执行上下文从调用栈弹出了，子级函数仍然能够访问父级函数的作用域。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var count=0</span><br><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function inner(y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var add5 = makeAdder(5)</span><br><span class="line">count += add5(2) // 7</span><br></pre></td></tr></table></figure><p></p><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_10.gif" alt="avatar"><br>注意，makeAdder 执行上下文从调用栈弹出后，创建了一个 Closure Scope（闭包作用域）。Closure Scope 中的变量环境和 makeAdder 执行上下文中的变量环境相同。这是因为我们在函数中嵌入了另一个函数。<br>在本例中，inner 函数嵌在 makeAdder 中，所以 inner 在 makeAdder 变量环境的基础上创建了一个闭包。因为闭包作用域的存在，即使 makeAdder 已经从调用栈弹出了，inner 仍然能够访问到 x 变量（通过作用域链）。</p><h1 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h1><p>函数的每次调用都有与之紧密相关的作用域和上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。 换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字的值， 它是拥有（控制）当前所执行代码的对象的引用。</p><p>作用域只是一个“地盘”，一个区域，是在函数声明的时候就确定的一套变量访问规则，而执行上下文是函数执行时才产生的一系列变量的集合体。<br>在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中。<br><strong>作用域中没有变量，变量是通过作用域对应的执行上下文环境中的变量对象来实现的。也就是说作用域定义了执行上下文中的变量的访问规则，执行上下文是在这个作用域规则的前提下执行代码的。</strong></p><p>所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。有闭包存在时，一个作用域存在两个上下文环境也是有的。</p><p>同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。</p><p>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。</p><h3 id="变量的查找规则："><a href="#变量的查找规则：" class="headerlink" title="变量的查找规则："></a>变量的查找规则：</h3><p>先从当前的执行上下文中找保存的作用域（对象），在当前作用域里面的 Environment Record（对应的执行上下文）中查找对应的属性, 如果有直接返回, 否则通过作用域链向上查找，顺着<code>__outer__</code>在上一级作用域的里面的 Environment Record 中查找对应的属性，直到全局作用域, 如果还找不到就抛出找不到的异常。</p><p>这里有一个小测试。下面代码中，打印出来的 bar 将会是什么？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var bar = &apos;Declared in foo&apos;</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">console.log(bar)</span><br></pre></td></tr></table></figure><p></p><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_7.gif" alt="avatar"><br>当我们调用了 foo，就在调用栈中新增了一个执行上下文。在其创建阶段，产生了 this、arguments，bar 被设为 undefined。<br>然后到了执行阶段，把字符串’Declare in foo’赋予 bar。到这里执行阶段就结束了，foo 执行上下文从调用栈弹出。<br>foo 弹出后，代码就运行到了打印 bar 到控制台的部分。此刻会报错：<code>Uncaught ReferenceError: bar is not defined</code>。这告诉我们，在函数中创建的变量，它的作用域是局部的。<strong>因为一旦函数的执行上下文从调用栈弹出，该函数中声明的变量就访问不到了。</strong></p><p>再看一个例子。代码执行完毕后控制台会打印出什么？<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function first() &#123;</span><br><span class="line">  var name = &apos;Jordyn&apos;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function second() &#123;</span><br><span class="line">  var name = &apos;Jake&apos;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name)</span><br><span class="line"></span><br><span class="line">var name = &apos;Tyler&apos;</span><br><span class="line">first()</span><br><span class="line">second()</span><br><span class="line">console.log(name)</span><br></pre></td></tr></table></figure><p></p><p><img src="http://cdn.luanzhuxian.com/blog/execution-context_8.gif" alt="avatar"></p><p>控制台会依次打印出 undefined、Jordyn、Jake、Tyler。<br>因为每个新的执行上下文都有它自己的变量环境。就算另有其他执行上下文包含变量 name，Javascript 引擎仍会先从当前执行上下文里找起。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/javascript/" rel="tag"># javascript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/post/d877f8a3.html" rel="next" title="CSS 实现水平垂直居中的"><i class="fa fa-chevron-left"></i> CSS 实现水平垂直居中的</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/post/1690d21b.html" rel="prev" title="函数式编程">函数式编程<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt><p class="site-author-name" itemprop="name"></p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">标签</span></a></div></nav><embed style="margin-top:50px" autostart src="https://www.xiami.com/widget/5411220_832495252_235_346_cccccc_dddddd_1/collectPlayer.swf" type="application/x-shockwave-flash" width="235" height="346" wmode="opaque"></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#执行栈"><span class="nav-number">1.</span> <span class="nav-text">执行栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#执行上下文（execution-context）"><span class="nav-number">2.</span> <span class="nav-text">执行上下文（execution context）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#执行上下文的类型"><span class="nav-number">2.1.</span> <span class="nav-text">执行上下文的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-全局执行上下文"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 全局执行上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-函数执行上下文"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. 函数执行上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Eval-函数执行上下文"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. Eval 函数执行上下文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行上下文的创建"><span class="nav-number">2.2.</span> <span class="nav-text">执行上下文的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建阶段"><span class="nav-number">2.2.1.</span> <span class="nav-text">创建阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-确定-this-的值（This-Binding）"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1. 确定 this 的值（This Binding）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建词法环境（Lexical-Environment）"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2. 创建词法环境（Lexical Environment）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-创建变量环境（Variable-Environment）"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3. 创建变量环境（Variable Environment）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行阶段"><span class="nav-number">2.2.2.</span> <span class="nav-text">执行阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LexicalEnvironment-和-VariableEnvironment-的区别"><span class="nav-number">2.2.3.</span> <span class="nav-text">LexicalEnvironment 和 VariableEnvironment 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量提升"><span class="nav-number">3.</span> <span class="nav-text">变量提升</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作用域（scope）"><span class="nav-number">4.</span> <span class="nav-text">作用域（scope）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作用域链"><span class="nav-number">5.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包"><span class="nav-number">6.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作用域与执行上下文"><span class="nav-number">7.</span> <span class="nav-text">作用域与执行上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的查找规则："><span class="nav-number">7.0.1.</span> <span class="nav-text">变量的查找规则：</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-envira"></i></span> <span class="author" itemprop="copyrightHolder">lzx</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.4"></script><script src="/js/src/motion.js?v=5.1.4"></script><script src="/js/src/scrollspy.js?v=5.1.4"></script><script src="/js/src/post-details.js?v=5.1.4"></script><script src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'xscfkohc1AtS7Px8SMRn4SeR-gzGzoHsz',
        appKey: 'qODRtEtDSVo4Mxj6DkhVAqd9',
        placeholder: '留下点什么吧~',
        avatar:'',
        guest_info:guest,
        pageSize:'15' || 10,
        avatar_cdn:'https://www.gravatar.com/avatar/',
    });</script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("xscfkohc1AtS7Px8SMRn4SeR-gzGzoHsz","qODRtEtDSVo4Mxj6DkhVAqd9")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>